
TinyG_001.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003dcc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000032  00802000  00003dcc  00003e60  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000026c  00802032  00802032  00003e92  2**0
                  ALLOC
  3 .debug_aranges 000001c0  00000000  00000000  00003e92  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000007c4  00000000  00000000  00004052  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000415d  00000000  00000000  00004816  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000011ba  00000000  00000000  00008973  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000025ab  00000000  00000000  00009b2d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000005b0  00000000  00000000  0000c0d8  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000012a1  00000000  00000000  0000c688  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000018fa  00000000  00000000  0000d929  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000030  00000000  00000000  0000f223  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__ctors_end>
       4:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
       8:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
       c:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      10:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      14:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      18:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      1c:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      20:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      24:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      28:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      2c:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      30:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      34:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      38:	0c 94 2f 15 	jmp	0x2a5e	; 0x2a5e <__vector_14>
      3c:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      40:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      44:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      48:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      4c:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      50:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      54:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      58:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      5c:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      60:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      64:	0c 94 b6 15 	jmp	0x2b6c	; 0x2b6c <__vector_25>
      68:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      6c:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      70:	0c 94 e0 15 	jmp	0x2bc0	; 0x2bc0 <__vector_28>
      74:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      78:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      7c:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      80:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      84:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      88:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      8c:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      90:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      94:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      98:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      9c:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      a0:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      a4:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      a8:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      ac:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      b0:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      b4:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      b8:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      bc:	0c 94 7c 14 	jmp	0x28f8	; 0x28f8 <__vector_47>
      c0:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      c4:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      c8:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      cc:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      d0:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      d4:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      d8:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      dc:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      e0:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      e4:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      e8:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      ec:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      f0:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      f4:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      f8:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
      fc:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     100:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     104:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     108:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     10c:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     110:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     114:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     118:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     11c:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     120:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     124:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     128:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     12c:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     130:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     134:	0c 94 d3 14 	jmp	0x29a6	; 0x29a6 <__vector_77>
     138:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     13c:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     140:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     144:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     148:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     14c:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     150:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     154:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     158:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     15c:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     160:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     164:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     168:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     16c:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     170:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     174:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     178:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     17c:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     180:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     184:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     188:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     18c:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     190:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     194:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     198:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     19c:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     1a0:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     1a4:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     1a8:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     1ac:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     1b0:	0c 94 25 14 	jmp	0x284a	; 0x284a <__vector_108>
     1b4:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     1b8:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     1bc:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     1c0:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     1c4:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     1c8:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     1cc:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     1d0:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     1d4:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     1d8:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     1dc:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     1e0:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     1e4:	0c 94 71 02 	jmp	0x4e2	; 0x4e2 <__bad_interrupt>
     1e8:	08 4a       	sbci	r16, 0xA8	; 168
     1ea:	d7 3b       	cpi	r29, 0xB7	; 183
     1ec:	3b ce       	rjmp	.-906    	; 0xfffffe64 <__eeprom_end+0xff7efe64>
     1ee:	01 6e       	ori	r16, 0xE1	; 225
     1f0:	84 bc       	out	0x24, r8	; 36
     1f2:	bf fd       	.word	0xfdbf	; ????
     1f4:	c1 2f       	mov	r28, r17
     1f6:	3d 6c       	ori	r19, 0xCD	; 205
     1f8:	74 31       	cpi	r23, 0x14	; 20
     1fa:	9a bd       	out	0x2a, r25	; 42
     1fc:	56 83       	std	Z+6, r21	; 0x06
     1fe:	3d da       	rcall	.-2950   	; 0xfffff67a <__eeprom_end+0xff7ef67a>
     200:	3d 00       	.word	0x003d	; ????
     202:	c7 7f       	andi	r28, 0xF7	; 247
     204:	11 be       	out	0x31, r1	; 49
     206:	d9 e4       	ldi	r29, 0x49	; 73
     208:	bb 4c       	sbci	r27, 0xCB	; 203
     20a:	3e 91       	ld	r19, -X
     20c:	6b aa       	std	Y+51, r6	; 0x33
     20e:	aa be       	out	0x3a, r10	; 58
     210:	00 00       	nop
     212:	00 80       	ld	r0, Z
     214:	3f 05       	cpc	r19, r15
     216:	a8 4c       	sbci	r26, 0xC8	; 200
     218:	cd b2       	in	r12, 0x1d	; 29
     21a:	d4 4e       	sbci	r29, 0xE4	; 228
     21c:	b9 38       	cpi	r27, 0x89	; 137
     21e:	36 a9       	ldd	r19, Z+54	; 0x36
     220:	02 0c       	add	r0, r2
     222:	50 b9       	out	0x00, r21	; 0
     224:	91 86       	std	Z+9, r9	; 0x09
     226:	88 08       	sbc	r8, r8
     228:	3c a6       	std	Y+44, r3	; 0x2c
     22a:	aa aa       	std	Y+50, r10	; 0x32
     22c:	2a be       	out	0x3a, r2	; 58
     22e:	00 00       	nop
     230:	00 80       	ld	r0, Z
     232:	3f 27       	eor	r19, r31

00000233 <__c.3587>:
     233:	27 24 27 20 74 6f 20 64 75 6d 70 20 63 75 72 72     '$' to dump curr
     243:	65 6e 74 20 73 65 74 74 69 6e 67 73 0d 0a 00        ent settings...

00000252 <__c.3578>:
     252:	53 74 6f 72 65 64 20 6e 65 77 20 73 65 74 74 69     Stored new setti
     262:	6e 67 0d 0a 00                                      ng...

00000267 <__c.3576>:
     267:	55 6e 6b 6e 6f 77 6e 20 70 61 72 61 6d 65 74 65     Unknown paramete
     277:	72 0d 0a 00                                         r...

0000027b <__c.3539>:
     27b:	29 0d 0a 0d 0a 27 24 78 3d 76 61 6c 75 65 27 20     )....'$x=value' 
     28b:	74 6f 20 73 65 74 20 70 61 72 61 6d 65 74 65 72     to set parameter
     29b:	20 6f 72 20 6a 75 73 74 20 27 24 27 20 74 6f 20      or just '$' to 
     2ab:	64 75 6d 70 20 63 75 72 72 65 6e 74 20 73 65 74     dump current set
     2bb:	74 69 6e 67 73 0d 0a 00                             tings...

000002c3 <__c.3537>:
     2c3:	20 28 73 74 65 70 20 70 6f 72 74 20 69 6e 76 65      (step port inve
     2d3:	72 74 20 6d 61 73 6b 2e 20 62 69 6e 61 72 79 20     rt mask. binary 
     2e3:	3d 20 00                                            = .

000002e6 <__c.3535>:
     2e6:	20 28 6d 6d 2f 61 72 63 20 73 65 67 6d 65 6e 74      (mm/arc segment
     2f6:	29 0d 0a 24 37 20 3d 20 00                          )..$7 = .

000002ff <__c.3533>:
     2ff:	20 28 6d 6d 2f 73 65 63 20 64 65 66 61 75 6c 74      (mm/sec default
     30f:	20 73 65 65 6b 20 72 61 74 65 29 0d 0a 24 36 20      seek rate)..$6 
     31f:	3d 20 00                                            = .

00000322 <__c.3531>:
     322:	20 28 6d 6d 2f 73 65 63 20 64 65 66 61 75 6c 74      (mm/sec default
     332:	20 66 65 65 64 20 72 61 74 65 29 0d 0a 24 35 20      feed rate)..$5 
     342:	3d 20 00                                            = .

00000345 <__c.3529>:
     345:	20 28 6d 69 63 72 6f 73 65 63 6f 6e 64 73 20 73      (microseconds s
     355:	74 65 70 20 70 75 6c 73 65 29 0d 0a 24 34 20 3d     tep pulse)..$4 =
     365:	20 00                                                .

00000367 <__c.3527>:
     367:	20 28 73 74 65 70 73 2f 6d 6d 20 7a 29 0d 0a 24      (steps/mm z)..$
     377:	33 20 3d 20 00                                      3 = .

0000037c <__c.3525>:
     37c:	20 28 73 74 65 70 73 2f 6d 6d 20 79 29 0d 0a 24      (steps/mm y)..$
     38c:	32 20 3d 20 00                                      2 = .

00000391 <__c.3523>:
     391:	20 28 73 74 65 70 73 2f 6d 6d 20 78 29 0d 0a 24      (steps/mm x)..$
     3a1:	31 20 3d 20 00                                      1 = .

000003a6 <__c.3521>:
     3a6:	24 30 20 3d 20 00                                   $0 = .

000003ac <__c.3509>:
     3ac:	0d 0a 00                                            ...

000003af <__c.3507>:
     3af:	0d 0a 20 45 58 45 43 3e 3e 20 00                    .. EXEC>> .

000003ba <__c.3502>:
     3ba:	0d 0a 00                                            ...

000003bd <__c.3500>:
     3bd:	30 2e 30 31 00                                      0.01.

000003c2 <__c.3498>:
     3c2:	0d 0a 54 69 6e 79 47 20 5b 54 45 53 54 20 4d 4f     ..TinyG [TEST MO
     3d2:	44 45 5d 20 2d 20 56 65 72 73 69 6f 6e 20 00        DE] - Version .

000003e1 <__c.3494>:
     3e1:	54 69 6e 79 47 3e 3e 20 00                          TinyG>> .

000003ea <__c.3756>:
     3ea:	0d 0a 00                                            ...

000003ed <__c.3754>:
     3ed:	41 43 54 49 56 45 3d 20 00                          ACTIVE= .

000003f6 <__c.3749>:
     3f6:	5d 00                                               ].

000003f8 <__c.3747>:
     3f8:	20 44 6f 6e 65 5b 00                                 Done[.

000003ff <__c.3737>:
     3ff:	20 75 53 3d 00                                       uS=.

00000404 <__c.3735>:
     404:	2c 20 5a 3d 00                                      , Z=.

00000409 <__c.3733>:
     409:	2c 20 59 3d 00                                      , Y=.

0000040e <__c.3731>:
     40e:	45 78 65 63 20 58 3d 00                             Exec X=.

00000416 <__c.3729>:
     416:	0d 0a 00                                            ...

00000419 <__c.3719>:
     419:	20 75 53 3d 00                                       uS=.

0000041e <__c.3717>:
     41e:	2c 20 5a 3d 00                                      , Z=.

00000423 <__c.3715>:
     423:	2c 20 59 3d 00                                      , Y=.

00000428 <__c.3713>:
     428:	4c 69 6e 65 20 58 3d 00                             Line X=.

00000430 <__c.3711>:
     430:	0d 0a 00                                            ...

00000433 <__c.3706>:
     433:	0d 0a 00                                            ...

00000436 <__c.3704>:
     436:	20 75 53 3d 00                                       uS=.

0000043b <__c.3702>:
     43b:	20 5a 3d 00                                          Z=.

0000043f <__c.3700>:
     43f:	20 59 3d 00                                          Y=.

00000443 <__c.3698>:
     443:	4c 69 6e 65 3a 20 58 3d 00                          Line: X=.

0000044c <__c.3686>:
     44c:	0d 0a 00                                            ...

0000044f <__c.3684>:
     44f:	20 50 6f 72 74 3d 00                                 Port=.

00000456 <__c.3682>:
     456:	20 43 6f 75 6e 74 3d 00                              Count=.

0000045e <__c.3680>:
     45e:	20 61 78 69 73 3a 00                                 axis:.

00000465 <pstr_inf>:
     465:	49 4e 46                                            INF

00000468 <pstr_inity>:
     468:	49 4e 49 54 59                                      INITY

0000046d <pstr_nan>:
     46d:	4e 41 4e                                            NAN

00000470 <pwr_m10>:
     470:	cd cc cc 3d 0a d7 23 3c 17 b7 d1 38 77 cc 2b 32     ...=..#<...8w.+2
     480:	95 95 e6 24 1f b1 4f 0a                             ...$..O.

00000488 <pwr_p10>:
     488:	00 00 20 41 00 00 c8 42 00 40 1c 46 20 bc be 4c     .. A...B.@.F ..L
     498:	ca 1b 0e 5a ae c5 9d 74                             ...Z...t

000004a0 <__ctors_end>:
     4a0:	11 24       	eor	r1, r1
     4a2:	1f be       	out	0x3f, r1	; 63
     4a4:	cf ef       	ldi	r28, 0xFF	; 255
     4a6:	df e5       	ldi	r29, 0x5F	; 95
     4a8:	de bf       	out	0x3e, r29	; 62
     4aa:	cd bf       	out	0x3d, r28	; 61
     4ac:	00 e0       	ldi	r16, 0x00	; 0
     4ae:	0c bf       	out	0x3c, r16	; 60

000004b0 <__do_copy_data>:
     4b0:	10 e2       	ldi	r17, 0x20	; 32
     4b2:	a0 e0       	ldi	r26, 0x00	; 0
     4b4:	b0 e2       	ldi	r27, 0x20	; 32
     4b6:	ec ec       	ldi	r30, 0xCC	; 204
     4b8:	fd e3       	ldi	r31, 0x3D	; 61
     4ba:	00 e0       	ldi	r16, 0x00	; 0
     4bc:	0b bf       	out	0x3b, r16	; 59
     4be:	02 c0       	rjmp	.+4      	; 0x4c4 <__do_copy_data+0x14>
     4c0:	07 90       	elpm	r0, Z+
     4c2:	0d 92       	st	X+, r0
     4c4:	a2 33       	cpi	r26, 0x32	; 50
     4c6:	b1 07       	cpc	r27, r17
     4c8:	d9 f7       	brne	.-10     	; 0x4c0 <__do_copy_data+0x10>

000004ca <__do_clear_bss>:
     4ca:	12 e2       	ldi	r17, 0x22	; 34
     4cc:	a2 e3       	ldi	r26, 0x32	; 50
     4ce:	b0 e2       	ldi	r27, 0x20	; 32
     4d0:	01 c0       	rjmp	.+2      	; 0x4d4 <.do_clear_bss_start>

000004d2 <.do_clear_bss_loop>:
     4d2:	1d 92       	st	X+, r1

000004d4 <.do_clear_bss_start>:
     4d4:	ae 39       	cpi	r26, 0x9E	; 158
     4d6:	b1 07       	cpc	r27, r17
     4d8:	e1 f7       	brne	.-8      	; 0x4d2 <.do_clear_bss_loop>
     4da:	0e 94 73 02 	call	0x4e6	; 0x4e6 <main>
     4de:	0c 94 e4 1e 	jmp	0x3dc8	; 0x3dc8 <_exit>

000004e2 <__bad_interrupt>:
     4e2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000004e6 <main>:


int main(void) 
{
	/* These inits are order dependent */
	cli();
     4e6:	f8 94       	cli
	xmega_init();				// xmega setup
     4e8:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <xmega_init>
	config_init();				// get config record from eeprom
     4ec:	0e 94 07 0a 	call	0x140e	; 0x140e <config_init>
	st_init(); 					// stepper subsystem
     4f0:	0e 94 40 10 	call	0x2080	; 0x2080 <st_init>
	mc_init();					// motion control subsystem
     4f4:	0e 94 06 0c 	call	0x180c	; 0x180c <mc_init>
	spindle_init();				// spindle controller
     4f8:	0e 94 bd 0f 	call	0x1f7a	; 0x1f7a <spindle_init>
	en_init();					// encoders
     4fc:	0e 94 e9 0b 	call	0x17d2	; 0x17d2 <en_init>
	gc_init();					// gcode-parser
     500:	0e 94 18 03 	call	0x630	; 0x630 <gc_init>
	sp_init();					// serial protocol
     504:	0e 94 a4 0f 	call	0x1f48	; 0x1f48 <sp_init>

	PMIC_SetVectorLocationToApplication();  // as opposed to boot rom
     508:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <PMIC_SetVectorLocationToApplication>
//	PMIC_EnableLowLevel();		// nothing at this level
	PMIC_EnableMediumLevel(); 	// enable serial IO
     50c:	e0 ea       	ldi	r30, 0xA0	; 160
     50e:	f0 e0       	ldi	r31, 0x00	; 0
     510:	80 91 a2 00 	lds	r24, 0x00A2
     514:	82 60       	ori	r24, 0x02	; 2
     516:	82 83       	std	Z+2, r24	; 0x02
	PMIC_EnableHighLevel();		// enable stepper timers
     518:	80 91 a2 00 	lds	r24, 0x00A2
     51c:	84 60       	ori	r24, 0x04	; 4
     51e:	82 83       	std	Z+2, r24	; 0x02
	sei();						// enable global interrupts
     520:	78 94       	sei

	for(;;){
		sleep_mode();
     522:	80 91 48 00 	lds	r24, 0x0048
     526:	81 60       	ori	r24, 0x01	; 1
     528:	80 93 48 00 	sts	0x0048, r24
     52c:	88 95       	sleep
     52e:	80 91 48 00 	lds	r24, 0x0048
     532:	8e 7f       	andi	r24, 0xFE	; 254
     534:	80 93 48 00 	sts	0x0048, r24
		sp_process(); 			// process the serial protocol
     538:	0e 94 4e 0f 	call	0x1e9c	; 0x1e9c <sp_process>
		st_execute_line();		// run next motor move
     53c:	0e 94 cb 12 	call	0x2596	; 0x2596 <st_execute_line>
     540:	f0 cf       	rjmp	.-32     	; 0x522 <main+0x3c>

00000542 <select_plane>:

/* select_plane() - select axis plane */

void select_plane(uint8_t axis_0, uint8_t axis_1, uint8_t axis_2) 
{
	gc.plane_axis_0 = axis_0;
     542:	80 93 75 20 	sts	0x2075, r24
	gc.plane_axis_1 = axis_1;
     546:	60 93 76 20 	sts	0x2076, r22
	gc.plane_axis_2 = axis_2;
     54a:	40 93 77 20 	sts	0x2077, r20
}
     54e:	08 95       	ret

00000550 <read_double>:
/* read_double() - read a double from a Gcode statement */

int read_double(char *textline,   //!< string: line of RS274/NGC code being processed
                int *counter,     //!< pointer to a counter for position on the line
                double *double_ptr) //!< pointer to double to be read
{
     550:	af 92       	push	r10
     552:	bf 92       	push	r11
     554:	cf 92       	push	r12
     556:	df 92       	push	r13
     558:	ef 92       	push	r14
     55a:	ff 92       	push	r15
     55c:	0f 93       	push	r16
     55e:	1f 93       	push	r17
     560:	df 93       	push	r29
     562:	cf 93       	push	r28
     564:	0f 92       	push	r0
     566:	0f 92       	push	r0
     568:	cd b7       	in	r28, 0x3d	; 61
     56a:	de b7       	in	r29, 0x3e	; 62
     56c:	6c 01       	movw	r12, r24
     56e:	5b 01       	movw	r10, r22
     570:	7a 01       	movw	r14, r20
  char *start = textline + *counter;
     572:	fb 01       	movw	r30, r22
     574:	00 81       	ld	r16, Z
     576:	11 81       	ldd	r17, Z+1	; 0x01
     578:	08 0f       	add	r16, r24
     57a:	19 1f       	adc	r17, r25
  char *end;
  
  *double_ptr = strtod(start, &end);
     57c:	c8 01       	movw	r24, r16
     57e:	be 01       	movw	r22, r28
     580:	6f 5f       	subi	r22, 0xFF	; 255
     582:	7f 4f       	sbci	r23, 0xFF	; 255
     584:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <strtod>
     588:	f7 01       	movw	r30, r14
     58a:	60 83       	st	Z, r22
     58c:	71 83       	std	Z+1, r23	; 0x01
     58e:	82 83       	std	Z+2, r24	; 0x02
     590:	93 83       	std	Z+3, r25	; 0x03
  if(end == start) { 
     592:	89 81       	ldd	r24, Y+1	; 0x01
     594:	9a 81       	ldd	r25, Y+2	; 0x02
     596:	80 17       	cp	r24, r16
     598:	91 07       	cpc	r25, r17
     59a:	31 f4       	brne	.+12     	; 0x5a8 <read_double+0x58>
    FAIL(GCSTATUS_BAD_NUMBER_FORMAT); 
     59c:	81 e0       	ldi	r24, 0x01	; 1
     59e:	80 93 56 20 	sts	0x2056, r24
     5a2:	20 e0       	ldi	r18, 0x00	; 0
     5a4:	30 e0       	ldi	r19, 0x00	; 0
     5a6:	07 c0       	rjmp	.+14     	; 0x5b6 <read_double+0x66>
    return(0); 
  };

  *counter = end - textline;
     5a8:	8c 19       	sub	r24, r12
     5aa:	9d 09       	sbc	r25, r13
     5ac:	f5 01       	movw	r30, r10
     5ae:	80 83       	st	Z, r24
     5b0:	91 83       	std	Z+1, r25	; 0x01
     5b2:	21 e0       	ldi	r18, 0x01	; 1
     5b4:	30 e0       	ldi	r19, 0x00	; 0
  return(1);
}
     5b6:	c9 01       	movw	r24, r18
     5b8:	0f 90       	pop	r0
     5ba:	0f 90       	pop	r0
     5bc:	cf 91       	pop	r28
     5be:	df 91       	pop	r29
     5c0:	1f 91       	pop	r17
     5c2:	0f 91       	pop	r16
     5c4:	ff 90       	pop	r15
     5c6:	ef 90       	pop	r14
     5c8:	df 90       	pop	r13
     5ca:	cf 90       	pop	r12
     5cc:	bf 90       	pop	r11
     5ce:	af 90       	pop	r10
     5d0:	08 95       	ret

000005d2 <next_statement>:
	Parses the next statement and leaves the counter on the first character following
	the statement. Returns 1 if there was a statement, 0 if end of string was reached
	or there was an error (check state.status_code).

*/
int next_statement(char *letter, double *double_ptr, char *textline, int *counter) {
     5d2:	0f 93       	push	r16
     5d4:	1f 93       	push	r17
     5d6:	cf 93       	push	r28
     5d8:	df 93       	push	r29
     5da:	ec 01       	movw	r28, r24
     5dc:	8b 01       	movw	r16, r22
     5de:	d9 01       	movw	r26, r18
  if (textline[*counter] == 0) {
     5e0:	ed 91       	ld	r30, X+
     5e2:	fc 91       	ld	r31, X
     5e4:	11 97       	sbiw	r26, 0x01	; 1
     5e6:	e4 0f       	add	r30, r20
     5e8:	f5 1f       	adc	r31, r21
     5ea:	e0 81       	ld	r30, Z
     5ec:	ee 23       	and	r30, r30
     5ee:	39 f0       	breq	.+14     	; 0x5fe <next_statement+0x2c>
    return(0); // No more statements
  }
  
  *letter = textline[*counter];
     5f0:	e8 83       	st	Y, r30
  if((*letter < 'A') || (*letter > 'Z')) {
     5f2:	e1 54       	subi	r30, 0x41	; 65
     5f4:	ea 31       	cpi	r30, 0x1A	; 26
     5f6:	30 f0       	brcs	.+12     	; 0x604 <next_statement+0x32>
    FAIL(GCSTATUS_EXPECTED_COMMAND_LETTER);
     5f8:	82 e0       	ldi	r24, 0x02	; 2
     5fa:	80 93 56 20 	sts	0x2056, r24
     5fe:	20 e0       	ldi	r18, 0x00	; 0
     600:	30 e0       	ldi	r19, 0x00	; 0
     602:	10 c0       	rjmp	.+32     	; 0x624 <next_statement+0x52>
    return(0);
  }
  (*counter)++;
     604:	8d 91       	ld	r24, X+
     606:	9c 91       	ld	r25, X
     608:	11 97       	sbiw	r26, 0x01	; 1
     60a:	01 96       	adiw	r24, 0x01	; 1
     60c:	8d 93       	st	X+, r24
     60e:	9c 93       	st	X, r25
  if (!read_double(textline, counter, double_ptr)) {
     610:	ca 01       	movw	r24, r20
     612:	b9 01       	movw	r22, r18
     614:	a8 01       	movw	r20, r16
     616:	0e 94 a8 02 	call	0x550	; 0x550 <read_double>
     61a:	00 97       	sbiw	r24, 0x00	; 0
     61c:	11 f0       	breq	.+4      	; 0x622 <next_statement+0x50>
     61e:	81 e0       	ldi	r24, 0x01	; 1
     620:	90 e0       	ldi	r25, 0x00	; 0
     622:	9c 01       	movw	r18, r24
    return(0);
  };
  return(1);
}
     624:	c9 01       	movw	r24, r18
     626:	df 91       	pop	r29
     628:	cf 91       	pop	r28
     62a:	1f 91       	pop	r17
     62c:	0f 91       	pop	r16
     62e:	08 95       	ret

00000630 <gc_init>:
int next_statement(char *letter, double *double_ptr, char *line, int *counter);

/* gc_init() */

void gc_init() {
	memset(&gc, 0, sizeof(gc));
     630:	82 e2       	ldi	r24, 0x22	; 34
     632:	e6 e5       	ldi	r30, 0x56	; 86
     634:	f0 e2       	ldi	r31, 0x20	; 32
     636:	df 01       	movw	r26, r30
     638:	1d 92       	st	X+, r1
     63a:	8a 95       	dec	r24
     63c:	e9 f7       	brne	.-6      	; 0x638 <gc_init+0x8>
	gc.feed_rate = settings.default_feed_rate/60;
     63e:	60 91 49 20 	lds	r22, 0x2049
     642:	70 91 4a 20 	lds	r23, 0x204A
     646:	80 91 4b 20 	lds	r24, 0x204B
     64a:	90 91 4c 20 	lds	r25, 0x204C
     64e:	20 e0       	ldi	r18, 0x00	; 0
     650:	30 e0       	ldi	r19, 0x00	; 0
     652:	40 e7       	ldi	r20, 0x70	; 112
     654:	52 e4       	ldi	r21, 0x42	; 66
     656:	0e 94 52 19 	call	0x32a4	; 0x32a4 <__divsf3>
     65a:	60 93 5e 20 	sts	0x205E, r22
     65e:	70 93 5f 20 	sts	0x205F, r23
     662:	80 93 60 20 	sts	0x2060, r24
     666:	90 93 61 20 	sts	0x2061, r25
	gc.seek_rate = settings.default_seek_rate/60;
     66a:	60 91 4d 20 	lds	r22, 0x204D
     66e:	70 91 4e 20 	lds	r23, 0x204E
     672:	80 91 4f 20 	lds	r24, 0x204F
     676:	90 91 50 20 	lds	r25, 0x2050
     67a:	20 e0       	ldi	r18, 0x00	; 0
     67c:	30 e0       	ldi	r19, 0x00	; 0
     67e:	40 e7       	ldi	r20, 0x70	; 112
     680:	52 e4       	ldi	r21, 0x42	; 66
     682:	0e 94 52 19 	call	0x32a4	; 0x32a4 <__divsf3>
     686:	60 93 62 20 	sts	0x2062, r22
     68a:	70 93 63 20 	sts	0x2063, r23
     68e:	80 93 64 20 	sts	0x2064, r24
     692:	90 93 65 20 	sts	0x2065, r25

/* select_plane() - select axis plane */

void select_plane(uint8_t axis_0, uint8_t axis_1, uint8_t axis_2) 
{
	gc.plane_axis_0 = axis_0;
     696:	10 92 75 20 	sts	0x2075, r1
	gc.plane_axis_1 = axis_1;
     69a:	91 e0       	ldi	r25, 0x01	; 1
     69c:	90 93 76 20 	sts	0x2076, r25
	gc.plane_axis_2 = axis_2;
     6a0:	82 e0       	ldi	r24, 0x02	; 2
     6a2:	80 93 77 20 	sts	0x2077, r24
void gc_init() {
	memset(&gc, 0, sizeof(gc));
	gc.feed_rate = settings.default_feed_rate/60;
	gc.seek_rate = settings.default_seek_rate/60;
	select_plane(X_AXIS, Y_AXIS, Z_AXIS);
	gc.absolute_mode = TRUE;
     6a6:	90 93 5a 20 	sts	0x205A, r25
}
     6aa:	08 95       	ret

000006ac <theta>:
/* theta(double x, double y)
	Find the angle in radians of deviance from the positive y axis. 
	negative angles to the left of y-axis, positive to the right.
*/
double theta(double x, double y)
{
     6ac:	af 92       	push	r10
     6ae:	bf 92       	push	r11
     6b0:	cf 92       	push	r12
     6b2:	df 92       	push	r13
     6b4:	ef 92       	push	r14
     6b6:	ff 92       	push	r15
     6b8:	0f 93       	push	r16
     6ba:	1f 93       	push	r17
     6bc:	79 01       	movw	r14, r18
     6be:	8a 01       	movw	r16, r20
	double theta = atan(x/fabs(y));
     6c0:	5f 77       	andi	r21, 0x7F	; 127
     6c2:	0e 94 52 19 	call	0x32a4	; 0x32a4 <__divsf3>
     6c6:	0e 94 10 19 	call	0x3220	; 0x3220 <atan>
     6ca:	5b 01       	movw	r10, r22
     6cc:	6c 01       	movw	r12, r24

	if (y>0) {
     6ce:	c8 01       	movw	r24, r16
     6d0:	b7 01       	movw	r22, r14
     6d2:	20 e0       	ldi	r18, 0x00	; 0
     6d4:	30 e0       	ldi	r19, 0x00	; 0
     6d6:	40 e0       	ldi	r20, 0x00	; 0
     6d8:	50 e0       	ldi	r21, 0x00	; 0
     6da:	0e 94 3b 1b 	call	0x3676	; 0x3676 <__gesf2>
     6de:	18 16       	cp	r1, r24
     6e0:	cc f0       	brlt	.+50     	; 0x714 <theta+0x68>
		return(theta);
	} else {
		if (theta>0) 
     6e2:	c6 01       	movw	r24, r12
     6e4:	b5 01       	movw	r22, r10
     6e6:	20 e0       	ldi	r18, 0x00	; 0
     6e8:	30 e0       	ldi	r19, 0x00	; 0
     6ea:	40 e0       	ldi	r20, 0x00	; 0
     6ec:	50 e0       	ldi	r21, 0x00	; 0
     6ee:	0e 94 3b 1b 	call	0x3676	; 0x3676 <__gesf2>
     6f2:	18 16       	cp	r1, r24
     6f4:	2c f4       	brge	.+10     	; 0x700 <theta+0x54>
	    {
			return(M_PI-theta);
     6f6:	6b ed       	ldi	r22, 0xDB	; 219
     6f8:	7f e0       	ldi	r23, 0x0F	; 15
     6fa:	89 e4       	ldi	r24, 0x49	; 73
     6fc:	90 e4       	ldi	r25, 0x40	; 64
     6fe:	04 c0       	rjmp	.+8      	; 0x708 <theta+0x5c>
    	} else {
			return(-M_PI-theta);
     700:	6b ed       	ldi	r22, 0xDB	; 219
     702:	7f e0       	ldi	r23, 0x0F	; 15
     704:	89 e4       	ldi	r24, 0x49	; 73
     706:	90 ec       	ldi	r25, 0xC0	; 192
     708:	a6 01       	movw	r20, r12
     70a:	95 01       	movw	r18, r10
     70c:	0e 94 ab 18 	call	0x3156	; 0x3156 <__subsf3>
     710:	5b 01       	movw	r10, r22
     712:	6c 01       	movw	r12, r24
		}
	}
}
     714:	b5 01       	movw	r22, r10
     716:	c6 01       	movw	r24, r12
     718:	1f 91       	pop	r17
     71a:	0f 91       	pop	r16
     71c:	ff 90       	pop	r15
     71e:	ef 90       	pop	r14
     720:	df 90       	pop	r13
     722:	cf 90       	pop	r12
     724:	bf 90       	pop	r11
     726:	af 90       	pop	r10
     728:	08 95       	ret

0000072a <gc_execute_line>:

/* gc_execute_line() - executes one line of 0-terminated G-Code. 
	The line is assumed to contain only uppercase characters and 
	signed floats (no whitespace).
*/
uint8_t gc_execute_line(char *textline) {
     72a:	2f 92       	push	r2
     72c:	3f 92       	push	r3
     72e:	4f 92       	push	r4
     730:	5f 92       	push	r5
     732:	6f 92       	push	r6
     734:	7f 92       	push	r7
     736:	8f 92       	push	r8
     738:	9f 92       	push	r9
     73a:	af 92       	push	r10
     73c:	bf 92       	push	r11
     73e:	cf 92       	push	r12
     740:	df 92       	push	r13
     742:	ef 92       	push	r14
     744:	ff 92       	push	r15
     746:	0f 93       	push	r16
     748:	1f 93       	push	r17
     74a:	df 93       	push	r29
     74c:	cf 93       	push	r28
     74e:	cd b7       	in	r28, 0x3d	; 61
     750:	de b7       	in	r29, 0x3e	; 62
     752:	ee 97       	sbiw	r28, 0x3e	; 62
     754:	cd bf       	out	0x3d, r28	; 61
     756:	de bf       	out	0x3e, r29	; 62
     758:	5c 01       	movw	r10, r24
	int counter = 0;  
     75a:	1a 82       	std	Y+2, r1	; 0x02
     75c:	1b 82       	std	Y+3, r1	; 0x03
  
	uint8_t absolute_override = FALSE; // 1=absolute motion for this block only {G53}
	uint8_t next_action = NEXT_ACTION_DEFAULT; // One of the NEXT_ACTION_-constants
  
	double target[3], offset[3];  
  	double p = 0, r = 0;
     75e:	80 e0       	ldi	r24, 0x00	; 0
     760:	90 e0       	ldi	r25, 0x00	; 0
     762:	a0 e0       	ldi	r26, 0x00	; 0
     764:	b0 e0       	ldi	r27, 0x00	; 0
     766:	88 87       	std	Y+8, r24	; 0x08
     768:	99 87       	std	Y+9, r25	; 0x09
     76a:	aa 87       	std	Y+10, r26	; 0x0a
     76c:	bb 87       	std	Y+11, r27	; 0x0b
	int int_value;
  
	clear_vector(target);
     76e:	8c e0       	ldi	r24, 0x0C	; 12
     770:	fe 01       	movw	r30, r28
     772:	3c 96       	adiw	r30, 0x0c	; 12
     774:	df 01       	movw	r26, r30
     776:	28 2f       	mov	r18, r24
     778:	1d 92       	st	X+, r1
     77a:	2a 95       	dec	r18
     77c:	e9 f7       	brne	.-6      	; 0x778 <gc_execute_line+0x4e>
	clear_vector(offset);
     77e:	fe 01       	movw	r30, r28
     780:	78 96       	adiw	r30, 0x18	; 24
     782:	df 01       	movw	r26, r30
     784:	1d 92       	st	X+, r1
     786:	8a 95       	dec	r24
     788:	e9 f7       	brne	.-6      	; 0x784 <gc_execute_line+0x5a>

	gc.status_code = GCSTATUS_OK;
     78a:	10 92 56 20 	sts	0x2056, r1

  // First: parse all statements
  
	if (textline[0] == '(') { 
     78e:	f5 01       	movw	r30, r10
     790:	80 81       	ld	r24, Z
     792:	88 32       	cpi	r24, 0x28	; 40
     794:	b1 f0       	breq	.+44     	; 0x7c2 <gc_execute_line+0x98>
		return(gc.status_code); 
	}
	if (textline[0] == '/') { 	// ignore block delete
     796:	8f 32       	cpi	r24, 0x2F	; 47
     798:	29 f4       	brne	.+10     	; 0x7a4 <gc_execute_line+0x7a>
		counter++; 
     79a:	8a 81       	ldd	r24, Y+2	; 0x02
     79c:	9b 81       	ldd	r25, Y+3	; 0x03
     79e:	01 96       	adiw	r24, 0x01	; 1
     7a0:	8a 83       	std	Y+2, r24	; 0x02
     7a2:	9b 83       	std	Y+3, r25	; 0x03
	} 
  	if (textline[0] == '$') { 	// This is a parameter line intended to change 
     7a4:	d5 01       	movw	r26, r10
     7a6:	8c 91       	ld	r24, X
     7a8:	84 32       	cpi	r24, 0x24	; 36
     7aa:	09 f0       	breq	.+2      	; 0x7ae <gc_execute_line+0x84>
     7ac:	2e c1       	rjmp	.+604    	; 0xa0a <gc_execute_line+0x2e0>
								// EEPROM-settings
    							// Parameter lines are on the form '$4=374.3'
								// or '$' to dump current settings
		counter = 1;
     7ae:	81 e0       	ldi	r24, 0x01	; 1
     7b0:	90 e0       	ldi	r25, 0x00	; 0
     7b2:	8a 83       	std	Y+2, r24	; 0x02
     7b4:	9b 83       	std	Y+3, r25	; 0x03
		if(textline[counter] == 0) {
     7b6:	11 96       	adiw	r26, 0x01	; 1
     7b8:	8c 91       	ld	r24, X
     7ba:	88 23       	and	r24, r24
     7bc:	21 f4       	brne	.+8      	; 0x7c6 <gc_execute_line+0x9c>
			dump_settings(); return(GCSTATUS_OK); 
     7be:	0e 94 89 09 	call	0x1312	; 0x1312 <dump_settings>
     7c2:	80 e0       	ldi	r24, 0x00	; 0
     7c4:	cb c4       	rjmp	.+2454   	; 0x115c <gc_execute_line+0xa32>
		}
	    read_double(textline, &counter, &p);
     7c6:	8e 01       	movw	r16, r28
     7c8:	0e 5f       	subi	r16, 0xFE	; 254
     7ca:	1f 4f       	sbci	r17, 0xFF	; 255
     7cc:	c5 01       	movw	r24, r10
     7ce:	b8 01       	movw	r22, r16
     7d0:	ae 01       	movw	r20, r28
     7d2:	48 5f       	subi	r20, 0xF8	; 248
     7d4:	5f 4f       	sbci	r21, 0xFF	; 255
     7d6:	0e 94 a8 02 	call	0x550	; 0x550 <read_double>

    	if(textline[counter++] != '=') { 
     7da:	2a 81       	ldd	r18, Y+2	; 0x02
     7dc:	3b 81       	ldd	r19, Y+3	; 0x03
     7de:	f5 01       	movw	r30, r10
     7e0:	e2 0f       	add	r30, r18
     7e2:	f3 1f       	adc	r31, r19
     7e4:	80 81       	ld	r24, Z
     7e6:	8d 33       	cpi	r24, 0x3D	; 61
     7e8:	09 f0       	breq	.+2      	; 0x7ec <gc_execute_line+0xc2>
     7ea:	b7 c4       	rjmp	.+2414   	; 0x115a <gc_execute_line+0xa30>
     7ec:	2f 5f       	subi	r18, 0xFF	; 255
     7ee:	3f 4f       	sbci	r19, 0xFF	; 255
     7f0:	2a 83       	std	Y+2, r18	; 0x02
     7f2:	3b 83       	std	Y+3, r19	; 0x03
			return(GCSTATUS_UNSUPPORTED_STATEMENT); 
		}
    	read_double(textline, &counter, &value);
     7f4:	c5 01       	movw	r24, r10
     7f6:	b8 01       	movw	r22, r16
     7f8:	ae 01       	movw	r20, r28
     7fa:	4c 5f       	subi	r20, 0xFC	; 252
     7fc:	5f 4f       	sbci	r21, 0xFF	; 255
     7fe:	0e 94 a8 02 	call	0x550	; 0x550 <read_double>

    	if(textline[counter] != 0) { 
     802:	ea 81       	ldd	r30, Y+2	; 0x02
     804:	fb 81       	ldd	r31, Y+3	; 0x03
     806:	ea 0d       	add	r30, r10
     808:	fb 1d       	adc	r31, r11
     80a:	80 81       	ld	r24, Z
     80c:	88 23       	and	r24, r24
     80e:	09 f0       	breq	.+2      	; 0x812 <gc_execute_line+0xe8>
     810:	a4 c4       	rjmp	.+2376   	; 0x115a <gc_execute_line+0xa30>
			return(GCSTATUS_UNSUPPORTED_STATEMENT); 
		}
    	store_setting(p, value);
     812:	68 85       	ldd	r22, Y+8	; 0x08
     814:	79 85       	ldd	r23, Y+9	; 0x09
     816:	8a 85       	ldd	r24, Y+10	; 0x0a
     818:	9b 85       	ldd	r25, Y+11	; 0x0b
     81a:	0e 94 ba 19 	call	0x3374	; 0x3374 <__fixsfsi>
     81e:	dc 01       	movw	r26, r24
     820:	cb 01       	movw	r24, r22
     822:	4c 81       	ldd	r20, Y+4	; 0x04
     824:	5d 81       	ldd	r21, Y+5	; 0x05
     826:	6e 81       	ldd	r22, Y+6	; 0x06
     828:	7f 81       	ldd	r23, Y+7	; 0x07
     82a:	0e 94 18 09 	call	0x1230	; 0x1230 <store_setting>
     82e:	ed c0       	rjmp	.+474    	; 0xa0a <gc_execute_line+0x2e0>
  	}
  
  // Pass 1: Commands
	while(next_statement(&letter, &value, textline, &counter)) {
    	int_value = trunc(value);
     830:	6c 81       	ldd	r22, Y+4	; 0x04
     832:	7d 81       	ldd	r23, Y+5	; 0x05
     834:	8e 81       	ldd	r24, Y+6	; 0x06
     836:	9f 81       	ldd	r25, Y+7	; 0x07
     838:	0e 94 0e 1d 	call	0x3a1c	; 0x3a1c <trunc>
     83c:	7b 01       	movw	r14, r22
     83e:	8c 01       	movw	r16, r24
     840:	0e 94 ba 19 	call	0x3374	; 0x3374 <__fixsfsi>
    	switch(letter) {
     844:	49 81       	ldd	r20, Y+1	; 0x01
     846:	4d 34       	cpi	r20, 0x4D	; 77
     848:	09 f4       	brne	.+2      	; 0x84c <gc_execute_line+0x122>
     84a:	a3 c0       	rjmp	.+326    	; 0x992 <gc_execute_line+0x268>
     84c:	44 35       	cpi	r20, 0x54	; 84
     84e:	09 f4       	brne	.+2      	; 0x852 <gc_execute_line+0x128>
     850:	d1 c0       	rjmp	.+418    	; 0x9f4 <gc_execute_line+0x2ca>
     852:	47 34       	cpi	r20, 0x47	; 71
     854:	09 f0       	breq	.+2      	; 0x858 <gc_execute_line+0x12e>
     856:	d4 c0       	rjmp	.+424    	; 0xa00 <gc_execute_line+0x2d6>
			case 'G':
				switch(int_value) {
     858:	64 31       	cpi	r22, 0x14	; 20
     85a:	71 05       	cpc	r23, r1
     85c:	09 f4       	brne	.+2      	; 0x860 <gc_execute_line+0x136>
     85e:	81 c0       	rjmp	.+258    	; 0x962 <gc_execute_line+0x238>
     860:	65 31       	cpi	r22, 0x15	; 21
     862:	71 05       	cpc	r23, r1
     864:	4c f5       	brge	.+82     	; 0x8b8 <gc_execute_line+0x18e>
     866:	63 30       	cpi	r22, 0x03	; 3
     868:	71 05       	cpc	r23, r1
     86a:	09 f4       	brne	.+2      	; 0x86e <gc_execute_line+0x144>
     86c:	62 c0       	rjmp	.+196    	; 0x932 <gc_execute_line+0x208>
     86e:	64 30       	cpi	r22, 0x04	; 4
     870:	71 05       	cpc	r23, r1
     872:	6c f4       	brge	.+26     	; 0x88e <gc_execute_line+0x164>
     874:	61 30       	cpi	r22, 0x01	; 1
     876:	71 05       	cpc	r23, r1
     878:	09 f4       	brne	.+2      	; 0x87c <gc_execute_line+0x152>
     87a:	55 c0       	rjmp	.+170    	; 0x926 <gc_execute_line+0x1fc>
     87c:	62 30       	cpi	r22, 0x02	; 2
     87e:	71 05       	cpc	r23, r1
     880:	0c f0       	brlt	.+2      	; 0x884 <gc_execute_line+0x15a>
     882:	54 c0       	rjmp	.+168    	; 0x92c <gc_execute_line+0x202>
     884:	61 15       	cp	r22, r1
     886:	71 05       	cpc	r23, r1
     888:	09 f4       	brne	.+2      	; 0x88c <gc_execute_line+0x162>
     88a:	4a c0       	rjmp	.+148    	; 0x920 <gc_execute_line+0x1f6>
     88c:	b0 c0       	rjmp	.+352    	; 0x9ee <gc_execute_line+0x2c4>
     88e:	61 31       	cpi	r22, 0x11	; 17
     890:	71 05       	cpc	r23, r1
     892:	09 f4       	brne	.+2      	; 0x896 <gc_execute_line+0x16c>
     894:	51 c0       	rjmp	.+162    	; 0x938 <gc_execute_line+0x20e>
     896:	62 31       	cpi	r22, 0x12	; 18
     898:	71 05       	cpc	r23, r1
     89a:	2c f4       	brge	.+10     	; 0x8a6 <gc_execute_line+0x17c>
     89c:	64 30       	cpi	r22, 0x04	; 4
     89e:	71 05       	cpc	r23, r1
     8a0:	09 f0       	breq	.+2      	; 0x8a4 <gc_execute_line+0x17a>
     8a2:	a5 c0       	rjmp	.+330    	; 0x9ee <gc_execute_line+0x2c4>
     8a4:	3a c0       	rjmp	.+116    	; 0x91a <gc_execute_line+0x1f0>
     8a6:	62 31       	cpi	r22, 0x12	; 18
     8a8:	71 05       	cpc	r23, r1
     8aa:	09 f4       	brne	.+2      	; 0x8ae <gc_execute_line+0x184>
     8ac:	4c c0       	rjmp	.+152    	; 0x946 <gc_execute_line+0x21c>
     8ae:	63 31       	cpi	r22, 0x13	; 19
     8b0:	71 05       	cpc	r23, r1
     8b2:	09 f0       	breq	.+2      	; 0x8b6 <gc_execute_line+0x18c>
     8b4:	9c c0       	rjmp	.+312    	; 0x9ee <gc_execute_line+0x2c4>
     8b6:	4e c0       	rjmp	.+156    	; 0x954 <gc_execute_line+0x22a>
     8b8:	60 35       	cpi	r22, 0x50	; 80
     8ba:	71 05       	cpc	r23, r1
     8bc:	09 f4       	brne	.+2      	; 0x8c0 <gc_execute_line+0x196>
     8be:	5a c0       	rjmp	.+180    	; 0x974 <gc_execute_line+0x24a>
     8c0:	61 35       	cpi	r22, 0x51	; 81
     8c2:	71 05       	cpc	r23, r1
     8c4:	9c f4       	brge	.+38     	; 0x8ec <gc_execute_line+0x1c2>
     8c6:	6c 31       	cpi	r22, 0x1C	; 28
     8c8:	71 05       	cpc	r23, r1
     8ca:	21 f1       	breq	.+72     	; 0x914 <gc_execute_line+0x1ea>
     8cc:	6d 31       	cpi	r22, 0x1D	; 29
     8ce:	71 05       	cpc	r23, r1
     8d0:	2c f4       	brge	.+10     	; 0x8dc <gc_execute_line+0x1b2>
     8d2:	65 31       	cpi	r22, 0x15	; 21
     8d4:	71 05       	cpc	r23, r1
     8d6:	09 f0       	breq	.+2      	; 0x8da <gc_execute_line+0x1b0>
     8d8:	8a c0       	rjmp	.+276    	; 0x9ee <gc_execute_line+0x2c4>
     8da:	46 c0       	rjmp	.+140    	; 0x968 <gc_execute_line+0x23e>
     8dc:	6e 31       	cpi	r22, 0x1E	; 30
     8de:	71 05       	cpc	r23, r1
     8e0:	c9 f0       	breq	.+50     	; 0x914 <gc_execute_line+0x1ea>
     8e2:	65 33       	cpi	r22, 0x35	; 53
     8e4:	71 05       	cpc	r23, r1
     8e6:	09 f0       	breq	.+2      	; 0x8ea <gc_execute_line+0x1c0>
     8e8:	82 c0       	rjmp	.+260    	; 0x9ee <gc_execute_line+0x2c4>
     8ea:	41 c0       	rjmp	.+130    	; 0x96e <gc_execute_line+0x244>
     8ec:	6b 35       	cpi	r22, 0x5B	; 91
     8ee:	71 05       	cpc	r23, r1
     8f0:	09 f4       	brne	.+2      	; 0x8f4 <gc_execute_line+0x1ca>
     8f2:	46 c0       	rjmp	.+140    	; 0x980 <gc_execute_line+0x256>
     8f4:	6c 35       	cpi	r22, 0x5C	; 92
     8f6:	71 05       	cpc	r23, r1
     8f8:	2c f4       	brge	.+10     	; 0x904 <gc_execute_line+0x1da>
     8fa:	6a 35       	cpi	r22, 0x5A	; 90
     8fc:	71 05       	cpc	r23, r1
     8fe:	09 f0       	breq	.+2      	; 0x902 <gc_execute_line+0x1d8>
     900:	76 c0       	rjmp	.+236    	; 0x9ee <gc_execute_line+0x2c4>
     902:	3b c0       	rjmp	.+118    	; 0x97a <gc_execute_line+0x250>
     904:	6d 35       	cpi	r22, 0x5D	; 93
     906:	71 05       	cpc	r23, r1
     908:	f1 f1       	breq	.+124    	; 0x986 <gc_execute_line+0x25c>
     90a:	6e 35       	cpi	r22, 0x5E	; 94
     90c:	71 05       	cpc	r23, r1
     90e:	09 f0       	breq	.+2      	; 0x912 <gc_execute_line+0x1e8>
     910:	6e c0       	rjmp	.+220    	; 0x9ee <gc_execute_line+0x2c4>
     912:	3c c0       	rjmp	.+120    	; 0x98c <gc_execute_line+0x262>
     914:	b2 e0       	ldi	r27, 0x02	; 2
     916:	b9 ab       	std	Y+49, r27	; 0x31
     918:	73 c0       	rjmp	.+230    	; 0xa00 <gc_execute_line+0x2d6>
     91a:	e1 e0       	ldi	r30, 0x01	; 1
     91c:	e9 ab       	std	Y+49, r30	; 0x31
     91e:	70 c0       	rjmp	.+224    	; 0xa00 <gc_execute_line+0x2d6>
					case 0: gc.motion_mode = MOTION_MODE_RAPID_LINEAR; break;
     920:	10 92 57 20 	sts	0x2057, r1
     924:	6d c0       	rjmp	.+218    	; 0xa00 <gc_execute_line+0x2d6>
					case 1: gc.motion_mode = MOTION_MODE_LINEAR; break;
     926:	d0 92 57 20 	sts	0x2057, r13
     92a:	6a c0       	rjmp	.+212    	; 0xa00 <gc_execute_line+0x2d6>
					case 2: gc.motion_mode = MOTION_MODE_CW_ARC; break;
     92c:	c0 92 57 20 	sts	0x2057, r12
     930:	67 c0       	rjmp	.+206    	; 0xa00 <gc_execute_line+0x2d6>
					case 3: gc.motion_mode = MOTION_MODE_CCW_ARC; break;
     932:	90 92 57 20 	sts	0x2057, r9
     936:	64 c0       	rjmp	.+200    	; 0xa00 <gc_execute_line+0x2d6>

/* select_plane() - select axis plane */

void select_plane(uint8_t axis_0, uint8_t axis_1, uint8_t axis_2) 
{
	gc.plane_axis_0 = axis_0;
     938:	10 92 75 20 	sts	0x2075, r1
	gc.plane_axis_1 = axis_1;
     93c:	d0 92 76 20 	sts	0x2076, r13
	gc.plane_axis_2 = axis_2;
     940:	c0 92 77 20 	sts	0x2077, r12
     944:	5d c0       	rjmp	.+186    	; 0xa00 <gc_execute_line+0x2d6>

/* select_plane() - select axis plane */

void select_plane(uint8_t axis_0, uint8_t axis_1, uint8_t axis_2) 
{
	gc.plane_axis_0 = axis_0;
     946:	10 92 75 20 	sts	0x2075, r1
	gc.plane_axis_1 = axis_1;
     94a:	c0 92 76 20 	sts	0x2076, r12
	gc.plane_axis_2 = axis_2;
     94e:	d0 92 77 20 	sts	0x2077, r13
     952:	56 c0       	rjmp	.+172    	; 0xa00 <gc_execute_line+0x2d6>

/* select_plane() - select axis plane */

void select_plane(uint8_t axis_0, uint8_t axis_1, uint8_t axis_2) 
{
	gc.plane_axis_0 = axis_0;
     954:	d0 92 75 20 	sts	0x2075, r13
	gc.plane_axis_1 = axis_1;
     958:	c0 92 76 20 	sts	0x2076, r12
	gc.plane_axis_2 = axis_2;
     95c:	10 92 77 20 	sts	0x2077, r1
     960:	4f c0       	rjmp	.+158    	; 0xa00 <gc_execute_line+0x2d6>
					case 3: gc.motion_mode = MOTION_MODE_CCW_ARC; break;
					case 4: next_action = NEXT_ACTION_DWELL; break;
					case 17: select_plane(X_AXIS, Y_AXIS, Z_AXIS); break;
					case 18: select_plane(X_AXIS, Z_AXIS, Y_AXIS); break;
					case 19: select_plane(Y_AXIS, Z_AXIS, X_AXIS); break;
					case 20: gc.inches_mode = TRUE; break;
     962:	d0 92 59 20 	sts	0x2059, r13
     966:	4c c0       	rjmp	.+152    	; 0xa00 <gc_execute_line+0x2d6>
					case 21: gc.inches_mode = FALSE; break;
     968:	10 92 59 20 	sts	0x2059, r1
     96c:	49 c0       	rjmp	.+146    	; 0xa00 <gc_execute_line+0x2d6>
     96e:	f1 e0       	ldi	r31, 0x01	; 1
     970:	fa ab       	std	Y+50, r31	; 0x32
     972:	46 c0       	rjmp	.+140    	; 0xa00 <gc_execute_line+0x2d6>
					case 28: case 30: next_action = NEXT_ACTION_GO_HOME; break;
					case 53: absolute_override = TRUE; break;
					case 80: gc.motion_mode = MOTION_MODE_CANCEL; break;
     974:	80 92 57 20 	sts	0x2057, r8
     978:	43 c0       	rjmp	.+134    	; 0xa00 <gc_execute_line+0x2d6>
					case 90: gc.absolute_mode = TRUE; break;
     97a:	d0 92 5a 20 	sts	0x205A, r13
     97e:	40 c0       	rjmp	.+128    	; 0xa00 <gc_execute_line+0x2d6>
					case 91: gc.absolute_mode = FALSE; break;
     980:	10 92 5a 20 	sts	0x205A, r1
     984:	3d c0       	rjmp	.+122    	; 0xa00 <gc_execute_line+0x2d6>
					case 93: gc.inverse_feed_rate_mode = TRUE; break;
     986:	d0 92 58 20 	sts	0x2058, r13
     98a:	3a c0       	rjmp	.+116    	; 0xa00 <gc_execute_line+0x2d6>
					case 94: gc.inverse_feed_rate_mode = FALSE; break;
     98c:	10 92 58 20 	sts	0x2058, r1
     990:	37 c0       	rjmp	.+110    	; 0xa00 <gc_execute_line+0x2d6>
					default: FAIL(GCSTATUS_UNSUPPORTED_STATEMENT);
				}
				break;
      
			case 'M':
				switch(int_value) {
     992:	63 30       	cpi	r22, 0x03	; 3
     994:	71 05       	cpc	r23, r1
     996:	e1 f0       	breq	.+56     	; 0x9d0 <gc_execute_line+0x2a6>
     998:	64 30       	cpi	r22, 0x04	; 4
     99a:	71 05       	cpc	r23, r1
     99c:	34 f4       	brge	.+12     	; 0x9aa <gc_execute_line+0x280>
     99e:	77 fd       	sbrc	r23, 7
     9a0:	26 c0       	rjmp	.+76     	; 0x9ee <gc_execute_line+0x2c4>
     9a2:	62 30       	cpi	r22, 0x02	; 2
     9a4:	71 05       	cpc	r23, r1
     9a6:	74 f0       	brlt	.+28     	; 0x9c4 <gc_execute_line+0x29a>
     9a8:	10 c0       	rjmp	.+32     	; 0x9ca <gc_execute_line+0x2a0>
     9aa:	65 30       	cpi	r22, 0x05	; 5
     9ac:	71 05       	cpc	r23, r1
     9ae:	d1 f0       	breq	.+52     	; 0x9e4 <gc_execute_line+0x2ba>
     9b0:	65 30       	cpi	r22, 0x05	; 5
     9b2:	71 05       	cpc	r23, r1
     9b4:	94 f0       	brlt	.+36     	; 0x9da <gc_execute_line+0x2b0>
     9b6:	6e 31       	cpi	r22, 0x1E	; 30
     9b8:	71 05       	cpc	r23, r1
     9ba:	39 f0       	breq	.+14     	; 0x9ca <gc_execute_line+0x2a0>
     9bc:	6c 33       	cpi	r22, 0x3C	; 60
     9be:	71 05       	cpc	r23, r1
     9c0:	b1 f4       	brne	.+44     	; 0x9ee <gc_execute_line+0x2c4>
     9c2:	03 c0       	rjmp	.+6      	; 0x9ca <gc_execute_line+0x2a0>
					case 0: case 1: gc.program_flow = PROGRAM_FLOW_PAUSED; break;
     9c4:	d0 92 5b 20 	sts	0x205B, r13
     9c8:	1b c0       	rjmp	.+54     	; 0xa00 <gc_execute_line+0x2d6>
					case 2: case 30: case 60: gc.program_flow = PROGRAM_FLOW_COMPLETED; break;
     9ca:	c0 92 5b 20 	sts	0x205B, r12
     9ce:	18 c0       	rjmp	.+48     	; 0xa00 <gc_execute_line+0x2d6>
					case 3: gc.spindle_direction = 1; break;
     9d0:	40 92 5c 20 	sts	0x205C, r4
     9d4:	50 92 5d 20 	sts	0x205D, r5
     9d8:	13 c0       	rjmp	.+38     	; 0xa00 <gc_execute_line+0x2d6>
					case 4: gc.spindle_direction = -1; break;
     9da:	60 92 5c 20 	sts	0x205C, r6
     9de:	70 92 5d 20 	sts	0x205D, r7
     9e2:	0e c0       	rjmp	.+28     	; 0xa00 <gc_execute_line+0x2d6>
					case 5: gc.spindle_direction = 0; break;
     9e4:	10 92 5c 20 	sts	0x205C, r1
     9e8:	10 92 5d 20 	sts	0x205D, r1
     9ec:	09 c0       	rjmp	.+18     	; 0xa00 <gc_execute_line+0x2d6>
        			default: FAIL(GCSTATUS_UNSUPPORTED_STATEMENT);
     9ee:	90 92 56 20 	sts	0x2056, r9
     9f2:	06 c0       	rjmp	.+12     	; 0xa00 <gc_execute_line+0x2d6>
				}
				break;

			case 'T': gc.tool = trunc(value); break;
     9f4:	c8 01       	movw	r24, r16
     9f6:	b7 01       	movw	r22, r14
     9f8:	0e 94 bf 19 	call	0x337e	; 0x337e <__fixunssfsi>
     9fc:	60 93 72 20 	sts	0x2072, r22
		}
		if(gc.status_code) {
     a00:	80 91 56 20 	lds	r24, 0x2056
     a04:	88 23       	and	r24, r24
     a06:	a9 f0       	breq	.+42     	; 0xa32 <gc_execute_line+0x308>
     a08:	21 c0       	rjmp	.+66     	; 0xa4c <gc_execute_line+0x322>
     a0a:	1a aa       	std	Y+50, r1	; 0x32
     a0c:	19 aa       	std	Y+49, r1	; 0x31
		}
    	store_setting(p, value);
  	}
  
  // Pass 1: Commands
	while(next_statement(&letter, &value, textline, &counter)) {
     a0e:	1e 01       	movw	r2, r28
     a10:	08 94       	sec
     a12:	21 1c       	adc	r2, r1
     a14:	31 1c       	adc	r3, r1
      
			case 'M':
				switch(int_value) {
					case 0: case 1: gc.program_flow = PROGRAM_FLOW_PAUSED; break;
					case 2: case 30: case 60: gc.program_flow = PROGRAM_FLOW_COMPLETED; break;
					case 3: gc.spindle_direction = 1; break;
     a16:	31 e0       	ldi	r19, 0x01	; 1
     a18:	43 2e       	mov	r4, r19
     a1a:	51 2c       	mov	r5, r1
					case 4: gc.spindle_direction = -1; break;
					case 5: gc.spindle_direction = 0; break;
        			default: FAIL(GCSTATUS_UNSUPPORTED_STATEMENT);
     a1c:	23 e0       	ldi	r18, 0x03	; 3
     a1e:	92 2e       	mov	r9, r18
				break;
      
			case 'M':
				switch(int_value) {
					case 0: case 1: gc.program_flow = PROGRAM_FLOW_PAUSED; break;
					case 2: case 30: case 60: gc.program_flow = PROGRAM_FLOW_COMPLETED; break;
     a20:	92 e0       	ldi	r25, 0x02	; 2
     a22:	c9 2e       	mov	r12, r25
					case 3: gc.spindle_direction = 1; break;
					case 4: gc.spindle_direction = -1; break;
     a24:	66 24       	eor	r6, r6
     a26:	6a 94       	dec	r6
     a28:	76 2c       	mov	r7, r6
				}
				break;
      
			case 'M':
				switch(int_value) {
					case 0: case 1: gc.program_flow = PROGRAM_FLOW_PAUSED; break;
     a2a:	dd 24       	eor	r13, r13
     a2c:	d3 94       	inc	r13
					case 19: select_plane(Y_AXIS, Z_AXIS, X_AXIS); break;
					case 20: gc.inches_mode = TRUE; break;
					case 21: gc.inches_mode = FALSE; break;
					case 28: case 30: next_action = NEXT_ACTION_GO_HOME; break;
					case 53: absolute_override = TRUE; break;
					case 80: gc.motion_mode = MOTION_MODE_CANCEL; break;
     a2e:	84 e0       	ldi	r24, 0x04	; 4
     a30:	88 2e       	mov	r8, r24
		}
    	store_setting(p, value);
  	}
  
  // Pass 1: Commands
	while(next_statement(&letter, &value, textline, &counter)) {
     a32:	c1 01       	movw	r24, r2
     a34:	be 01       	movw	r22, r28
     a36:	6c 5f       	subi	r22, 0xFC	; 252
     a38:	7f 4f       	sbci	r23, 0xFF	; 255
     a3a:	a5 01       	movw	r20, r10
     a3c:	9e 01       	movw	r18, r28
     a3e:	2e 5f       	subi	r18, 0xFE	; 254
     a40:	3f 4f       	sbci	r19, 0xFF	; 255
     a42:	0e 94 e9 02 	call	0x5d2	; 0x5d2 <next_statement>
     a46:	89 2b       	or	r24, r25
     a48:	09 f0       	breq	.+2      	; 0xa4c <gc_execute_line+0x322>
     a4a:	f2 ce       	rjmp	.-540    	; 0x830 <gc_execute_line+0x106>
		}
	}
  
  // If there were any errors parsing this line, 
  // we will return right away with the bad news
	if (gc.status_code) { 
     a4c:	80 91 56 20 	lds	r24, 0x2056
     a50:	88 23       	and	r24, r24
     a52:	09 f0       	breq	.+2      	; 0xa56 <gc_execute_line+0x32c>
     a54:	83 c3       	rjmp	.+1798   	; 0x115c <gc_execute_line+0xa32>
		return(gc.status_code); 
	}

	counter = 0;
     a56:	1a 82       	std	Y+2, r1	; 0x02
     a58:	1b 82       	std	Y+3, r1	; 0x03
	clear_vector(offset);
     a5a:	8c e0       	ldi	r24, 0x0C	; 12
     a5c:	fe 01       	movw	r30, r28
     a5e:	78 96       	adiw	r30, 0x18	; 24
     a60:	df 01       	movw	r26, r30
     a62:	1d 92       	st	X+, r1
     a64:	8a 95       	dec	r24
     a66:	e9 f7       	brne	.-6      	; 0xa62 <gc_execute_line+0x338>
	memcpy(target, gc.position, sizeof(target)); // target = gc.position
     a68:	de 01       	movw	r26, r28
     a6a:	1c 96       	adiw	r26, 0x0c	; 12
     a6c:	e6 e6       	ldi	r30, 0x66	; 102
     a6e:	f0 e2       	ldi	r31, 0x20	; 32
     a70:	8c e0       	ldi	r24, 0x0C	; 12
     a72:	01 90       	ld	r0, Z+
     a74:	0d 92       	st	X+, r0
     a76:	81 50       	subi	r24, 0x01	; 1
     a78:	e1 f7       	brne	.-8      	; 0xa72 <gc_execute_line+0x348>
     a7a:	1b ae       	std	Y+59, r1	; 0x3b
     a7c:	1c ae       	std	Y+60, r1	; 0x3c
     a7e:	b0 e8       	ldi	r27, 0x80	; 128
     a80:	bd af       	std	Y+61, r27	; 0x3d
     a82:	ef eb       	ldi	r30, 0xBF	; 191
     a84:	ee af       	std	Y+62, r30	; 0x3e
     a86:	66 24       	eor	r6, r6
     a88:	77 24       	eor	r7, r7
     a8a:	60 e0       	ldi	r22, 0x00	; 0
     a8c:	70 e0       	ldi	r23, 0x00	; 0
     a8e:	80 e0       	ldi	r24, 0x00	; 0
     a90:	90 e0       	ldi	r25, 0x00	; 0
     a92:	6d a7       	std	Y+45, r22	; 0x2d
     a94:	7e a7       	std	Y+46, r23	; 0x2e
     a96:	8f a7       	std	Y+47, r24	; 0x2f
     a98:	98 ab       	std	Y+48, r25	; 0x30

  // Pass 2: Parameters
	while(next_statement(&letter, &value, textline, &counter)) {
     a9a:	04 e0       	ldi	r16, 0x04	; 4
     a9c:	20 2e       	mov	r2, r16
     a9e:	31 2c       	mov	r3, r1
     aa0:	2c 0e       	add	r2, r28
     aa2:	3d 1e       	adc	r3, r29
     aa4:	12 e0       	ldi	r17, 0x02	; 2
     aa6:	41 2e       	mov	r4, r17
     aa8:	51 2c       	mov	r5, r1
     aaa:	4c 0e       	add	r4, r28
     aac:	5d 1e       	adc	r5, r29
     aae:	4e 01       	movw	r8, r28
     ab0:	08 94       	sec
     ab2:	81 1c       	adc	r8, r1
     ab4:	91 1c       	adc	r9, r1
     ab6:	a1 c0       	rjmp	.+322    	; 0xbfa <gc_execute_line+0x4d0>
		int_value = trunc(value);
		unit_converted_value = to_millimeters(value);
     ab8:	cc 80       	ldd	r12, Y+4	; 0x04
     aba:	dd 80       	ldd	r13, Y+5	; 0x05
     abc:	ee 80       	ldd	r14, Y+6	; 0x06
     abe:	ff 80       	ldd	r15, Y+7	; 0x07
}


inline float to_millimeters(double value) 
{
	return(gc.inches_mode ? (value * INCHES_PER_MM) : value);
     ac0:	80 91 59 20 	lds	r24, 0x2059
     ac4:	88 23       	and	r24, r24
     ac6:	19 f4       	brne	.+6      	; 0xace <gc_execute_line+0x3a4>
     ac8:	a7 01       	movw	r20, r14
     aca:	96 01       	movw	r18, r12
     acc:	0a c0       	rjmp	.+20     	; 0xae2 <gc_execute_line+0x3b8>
     ace:	c7 01       	movw	r24, r14
     ad0:	b6 01       	movw	r22, r12
     ad2:	25 e8       	ldi	r18, 0x85	; 133
     ad4:	32 e4       	ldi	r19, 0x42	; 66
     ad6:	41 e2       	ldi	r20, 0x21	; 33
     ad8:	5d e3       	ldi	r21, 0x3D	; 61
     ada:	0e 94 40 1c 	call	0x3880	; 0x3880 <__mulsf3>
     ade:	9b 01       	movw	r18, r22
     ae0:	ac 01       	movw	r20, r24

  // Pass 2: Parameters
	while(next_statement(&letter, &value, textline, &counter)) {
		int_value = trunc(value);
		unit_converted_value = to_millimeters(value);
		switch(letter) {
     ae2:	09 81       	ldd	r16, Y+1	; 0x01
     ae4:	00 35       	cpi	r16, 0x50	; 80
     ae6:	09 f4       	brne	.+2      	; 0xaea <gc_execute_line+0x3c0>
     ae8:	4d c0       	rjmp	.+154    	; 0xb84 <gc_execute_line+0x45a>
     aea:	01 35       	cpi	r16, 0x51	; 81
     aec:	58 f4       	brcc	.+22     	; 0xb04 <gc_execute_line+0x3da>
     aee:	06 34       	cpi	r16, 0x46	; 70
     af0:	01 f1       	breq	.+64     	; 0xb32 <gc_execute_line+0x408>
     af2:	06 34       	cpi	r16, 0x46	; 70
     af4:	08 f4       	brcc	.+2      	; 0xaf8 <gc_execute_line+0x3ce>
     af6:	81 c0       	rjmp	.+258    	; 0xbfa <gc_execute_line+0x4d0>
     af8:	80 2f       	mov	r24, r16
     afa:	89 54       	subi	r24, 0x49	; 73
     afc:	83 30       	cpi	r24, 0x03	; 3
     afe:	08 f0       	brcs	.+2      	; 0xb02 <gc_execute_line+0x3d8>
     b00:	7c c0       	rjmp	.+248    	; 0xbfa <gc_execute_line+0x4d0>
     b02:	31 c0       	rjmp	.+98     	; 0xb66 <gc_execute_line+0x43c>
     b04:	03 35       	cpi	r16, 0x53	; 83
     b06:	09 f4       	brne	.+2      	; 0xb0a <gc_execute_line+0x3e0>
     b08:	42 c0       	rjmp	.+132    	; 0xb8e <gc_execute_line+0x464>
     b0a:	04 35       	cpi	r16, 0x54	; 84
     b0c:	20 f4       	brcc	.+8      	; 0xb16 <gc_execute_line+0x3ec>
     b0e:	02 35       	cpi	r16, 0x52	; 82
     b10:	09 f0       	breq	.+2      	; 0xb14 <gc_execute_line+0x3ea>
     b12:	73 c0       	rjmp	.+230    	; 0xbfa <gc_execute_line+0x4d0>
     b14:	06 c0       	rjmp	.+12     	; 0xb22 <gc_execute_line+0x3f8>
     b16:	80 2f       	mov	r24, r16
     b18:	88 55       	subi	r24, 0x58	; 88
     b1a:	83 30       	cpi	r24, 0x03	; 3
     b1c:	08 f0       	brcs	.+2      	; 0xb20 <gc_execute_line+0x3f6>
     b1e:	6d c0       	rjmp	.+218    	; 0xbfa <gc_execute_line+0x4d0>
     b20:	3f c0       	rjmp	.+126    	; 0xba0 <gc_execute_line+0x476>
     b22:	2d a7       	std	Y+45, r18	; 0x2d
     b24:	3e a7       	std	Y+46, r19	; 0x2e
     b26:	4f a7       	std	Y+47, r20	; 0x2f
     b28:	58 ab       	std	Y+48, r21	; 0x30
     b2a:	b1 e0       	ldi	r27, 0x01	; 1
     b2c:	6b 2e       	mov	r6, r27
     b2e:	71 2c       	mov	r7, r1
     b30:	64 c0       	rjmp	.+200    	; 0xbfa <gc_execute_line+0x4d0>
			case 'F': 
				if (gc.inverse_feed_rate_mode) {
     b32:	80 91 58 20 	lds	r24, 0x2058
     b36:	88 23       	and	r24, r24
     b38:	29 f0       	breq	.+10     	; 0xb44 <gc_execute_line+0x41a>
     b3a:	2b af       	std	Y+59, r18	; 0x3b
     b3c:	3c af       	std	Y+60, r19	; 0x3c
     b3e:	4d af       	std	Y+61, r20	; 0x3d
     b40:	5e af       	std	Y+62, r21	; 0x3e
     b42:	5b c0       	rjmp	.+182    	; 0xbfa <gc_execute_line+0x4d0>
					inverse_feed_rate = unit_converted_value; // seconds per motion for this motion only
				} else {
					gc.feed_rate = unit_converted_value/60; // millimeters pr second
     b44:	ca 01       	movw	r24, r20
     b46:	b9 01       	movw	r22, r18
     b48:	20 e0       	ldi	r18, 0x00	; 0
     b4a:	30 e0       	ldi	r19, 0x00	; 0
     b4c:	40 e7       	ldi	r20, 0x70	; 112
     b4e:	52 e4       	ldi	r21, 0x42	; 66
     b50:	0e 94 52 19 	call	0x32a4	; 0x32a4 <__divsf3>
     b54:	60 93 5e 20 	sts	0x205E, r22
     b58:	70 93 5f 20 	sts	0x205F, r23
     b5c:	80 93 60 20 	sts	0x2060, r24
     b60:	90 93 61 20 	sts	0x2061, r25
     b64:	4a c0       	rjmp	.+148    	; 0xbfa <gc_execute_line+0x4d0>
				}
				break;
			case 'I': case 'J': case 'K': offset[letter-'I'] = unit_converted_value; break;
     b66:	e0 2f       	mov	r30, r16
     b68:	f0 e0       	ldi	r31, 0x00	; 0
     b6a:	e9 54       	subi	r30, 0x49	; 73
     b6c:	f0 40       	sbci	r31, 0x00	; 0
     b6e:	ee 0f       	add	r30, r30
     b70:	ff 1f       	adc	r31, r31
     b72:	ee 0f       	add	r30, r30
     b74:	ff 1f       	adc	r31, r31
     b76:	e8 0d       	add	r30, r8
     b78:	f9 1d       	adc	r31, r9
     b7a:	27 8b       	std	Z+23, r18	; 0x17
     b7c:	30 8f       	std	Z+24, r19	; 0x18
     b7e:	41 8f       	std	Z+25, r20	; 0x19
     b80:	52 8f       	std	Z+26, r21	; 0x1a
     b82:	3b c0       	rjmp	.+118    	; 0xbfa <gc_execute_line+0x4d0>
			case 'P': p = value; break;
     b84:	c8 86       	std	Y+8, r12	; 0x08
     b86:	d9 86       	std	Y+9, r13	; 0x09
     b88:	ea 86       	std	Y+10, r14	; 0x0a
     b8a:	fb 86       	std	Y+11, r15	; 0x0b
     b8c:	36 c0       	rjmp	.+108    	; 0xbfa <gc_execute_line+0x4d0>
			case 'R': r = unit_converted_value; radius_mode = TRUE; break;
			case 'S': gc.spindle_speed = value; break;
     b8e:	c7 01       	movw	r24, r14
     b90:	b6 01       	movw	r22, r12
     b92:	0e 94 ba 19 	call	0x3374	; 0x3374 <__fixsfsi>
     b96:	60 93 73 20 	sts	0x2073, r22
     b9a:	70 93 74 20 	sts	0x2074, r23
     b9e:	2d c0       	rjmp	.+90     	; 0xbfa <gc_execute_line+0x4d0>
			case 'X': case 'Y': case 'Z':
				if (gc.absolute_mode || absolute_override) {
     ba0:	80 91 5a 20 	lds	r24, 0x205A
     ba4:	88 23       	and	r24, r24
     ba6:	19 f4       	brne	.+6      	; 0xbae <gc_execute_line+0x484>
     ba8:	7a a9       	ldd	r23, Y+50	; 0x32
     baa:	77 23       	and	r23, r23
     bac:	79 f0       	breq	.+30     	; 0xbcc <gc_execute_line+0x4a2>
					target[letter - 'X'] = unit_converted_value;
     bae:	e0 2f       	mov	r30, r16
     bb0:	f0 e0       	ldi	r31, 0x00	; 0
     bb2:	e8 55       	subi	r30, 0x58	; 88
     bb4:	f0 40       	sbci	r31, 0x00	; 0
     bb6:	ee 0f       	add	r30, r30
     bb8:	ff 1f       	adc	r31, r31
     bba:	ee 0f       	add	r30, r30
     bbc:	ff 1f       	adc	r31, r31
     bbe:	e8 0d       	add	r30, r8
     bc0:	f9 1d       	adc	r31, r9
     bc2:	23 87       	std	Z+11, r18	; 0x0b
     bc4:	34 87       	std	Z+12, r19	; 0x0c
     bc6:	45 87       	std	Z+13, r20	; 0x0d
     bc8:	56 87       	std	Z+14, r21	; 0x0e
     bca:	17 c0       	rjmp	.+46     	; 0xbfa <gc_execute_line+0x4d0>
				} else {
					target[letter - 'X'] += unit_converted_value;
     bcc:	10 e0       	ldi	r17, 0x00	; 0
     bce:	08 55       	subi	r16, 0x58	; 88
     bd0:	10 40       	sbci	r17, 0x00	; 0
     bd2:	00 0f       	add	r16, r16
     bd4:	11 1f       	adc	r17, r17
     bd6:	00 0f       	add	r16, r16
     bd8:	11 1f       	adc	r17, r17
     bda:	08 0d       	add	r16, r8
     bdc:	19 1d       	adc	r17, r9
     bde:	d8 01       	movw	r26, r16
     be0:	1b 96       	adiw	r26, 0x0b	; 11
     be2:	6d 91       	ld	r22, X+
     be4:	7d 91       	ld	r23, X+
     be6:	8d 91       	ld	r24, X+
     be8:	9c 91       	ld	r25, X
     bea:	1e 97       	sbiw	r26, 0x0e	; 14
     bec:	0e 94 ac 18 	call	0x3158	; 0x3158 <__addsf3>
     bf0:	f8 01       	movw	r30, r16
     bf2:	63 87       	std	Z+11, r22	; 0x0b
     bf4:	74 87       	std	Z+12, r23	; 0x0c
     bf6:	85 87       	std	Z+13, r24	; 0x0d
     bf8:	96 87       	std	Z+14, r25	; 0x0e
	counter = 0;
	clear_vector(offset);
	memcpy(target, gc.position, sizeof(target)); // target = gc.position

  // Pass 2: Parameters
	while(next_statement(&letter, &value, textline, &counter)) {
     bfa:	c4 01       	movw	r24, r8
     bfc:	b1 01       	movw	r22, r2
     bfe:	a5 01       	movw	r20, r10
     c00:	92 01       	movw	r18, r4
     c02:	0e 94 e9 02 	call	0x5d2	; 0x5d2 <next_statement>
     c06:	89 2b       	or	r24, r25
     c08:	09 f0       	breq	.+2      	; 0xc0c <gc_execute_line+0x4e2>
     c0a:	56 cf       	rjmp	.-340    	; 0xab8 <gc_execute_line+0x38e>
		}	
	}
  
  // If there were any errors parsing this line, 
  // we will return right away with the bad news
	 if (gc.status_code) {
     c0c:	80 91 56 20 	lds	r24, 0x2056
     c10:	88 23       	and	r24, r24
     c12:	09 f0       	breq	.+2      	; 0xc16 <gc_execute_line+0x4ec>
     c14:	a3 c2       	rjmp	.+1350   	; 0x115c <gc_execute_line+0xa32>
		return(gc.status_code); 
	}
    
  // Update spindle state
	if (gc.spindle_direction) {
     c16:	80 91 5c 20 	lds	r24, 0x205C
     c1a:	90 91 5d 20 	lds	r25, 0x205D
     c1e:	00 97       	sbiw	r24, 0x00	; 0
     c20:	59 f0       	breq	.+22     	; 0xc38 <gc_execute_line+0x50e>
    	spindle_run(gc.spindle_direction, gc.spindle_speed);
     c22:	40 91 73 20 	lds	r20, 0x2073
     c26:	50 91 74 20 	lds	r21, 0x2074
     c2a:	66 27       	eor	r22, r22
     c2c:	57 fd       	sbrc	r21, 7
     c2e:	60 95       	com	r22
     c30:	76 2f       	mov	r23, r22
     c32:	0e 94 c4 0f 	call	0x1f88	; 0x1f88 <spindle_run>
     c36:	02 c0       	rjmp	.+4      	; 0xc3c <gc_execute_line+0x512>
	} else {
		spindle_stop();\
     c38:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <spindle_stop>
	}
  
  // Perform any physical actions
	switch (next_action) {
     c3c:	f9 a9       	ldd	r31, Y+49	; 0x31
     c3e:	f1 30       	cpi	r31, 0x01	; 1
     c40:	41 f0       	breq	.+16     	; 0xc52 <gc_execute_line+0x528>
     c42:	f1 30       	cpi	r31, 0x01	; 1
     c44:	a8 f0       	brcs	.+42     	; 0xc70 <gc_execute_line+0x546>
     c46:	f2 30       	cpi	r31, 0x02	; 2
     c48:	09 f0       	breq	.+2      	; 0xc4c <gc_execute_line+0x522>
     c4a:	7b c2       	rjmp	.+1270   	; 0x1142 <gc_execute_line+0xa18>
    	case NEXT_ACTION_GO_HOME: mc_go_home(); break;
     c4c:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <mc_go_home>
     c50:	78 c2       	rjmp	.+1264   	; 0x1142 <gc_execute_line+0xa18>
		case NEXT_ACTION_DWELL: mc_dwell(trunc(p*1000)); break;
     c52:	68 85       	ldd	r22, Y+8	; 0x08
     c54:	79 85       	ldd	r23, Y+9	; 0x09
     c56:	8a 85       	ldd	r24, Y+10	; 0x0a
     c58:	9b 85       	ldd	r25, Y+11	; 0x0b
     c5a:	20 e0       	ldi	r18, 0x00	; 0
     c5c:	30 e0       	ldi	r19, 0x00	; 0
     c5e:	4a e7       	ldi	r20, 0x7A	; 122
     c60:	54 e4       	ldi	r21, 0x44	; 68
     c62:	0e 94 40 1c 	call	0x3880	; 0x3880 <__mulsf3>
     c66:	0e 94 bf 19 	call	0x337e	; 0x337e <__fixunssfsi>
     c6a:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <mc_dwell>
     c6e:	69 c2       	rjmp	.+1234   	; 0x1142 <gc_execute_line+0xa18>
		case NEXT_ACTION_DEFAULT: 
 		switch (gc.motion_mode) {
     c70:	b0 90 57 20 	lds	r11, 0x2057
     c74:	21 e0       	ldi	r18, 0x01	; 1
     c76:	2b 15       	cp	r18, r11
     c78:	28 f4       	brcc	.+10     	; 0xc84 <gc_execute_line+0x55a>
     c7a:	33 e0       	ldi	r19, 0x03	; 3
     c7c:	3b 15       	cp	r19, r11
     c7e:	08 f4       	brcc	.+2      	; 0xc82 <gc_execute_line+0x558>
     c80:	60 c2       	rjmp	.+1216   	; 0x1142 <gc_execute_line+0xa18>
     c82:	1e c0       	rjmp	.+60     	; 0xcc0 <gc_execute_line+0x596>
			case MOTION_MODE_CANCEL: break;
			case MOTION_MODE_RAPID_LINEAR:
			case MOTION_MODE_LINEAR:
				mc_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], 
     c84:	6c 85       	ldd	r22, Y+12	; 0x0c
     c86:	7d 85       	ldd	r23, Y+13	; 0x0d
     c88:	8e 85       	ldd	r24, Y+14	; 0x0e
     c8a:	9f 85       	ldd	r25, Y+15	; 0x0f
     c8c:	28 89       	ldd	r18, Y+16	; 0x10
     c8e:	39 89       	ldd	r19, Y+17	; 0x11
     c90:	4a 89       	ldd	r20, Y+18	; 0x12
     c92:	5b 89       	ldd	r21, Y+19	; 0x13
     c94:	ec 88       	ldd	r14, Y+20	; 0x14
     c96:	fd 88       	ldd	r15, Y+21	; 0x15
     c98:	0e 89       	ldd	r16, Y+22	; 0x16
     c9a:	1f 89       	ldd	r17, Y+23	; 0x17
     c9c:	80 90 58 20 	lds	r8, 0x2058
     ca0:	88 20       	and	r8, r8
     ca2:	09 f0       	breq	.+2      	; 0xca6 <gc_execute_line+0x57c>
     ca4:	45 c2       	rjmp	.+1162   	; 0x1130 <gc_execute_line+0xa06>
     ca6:	a0 91 5e 20 	lds	r26, 0x205E
     caa:	ab af       	std	Y+59, r26	; 0x3b
     cac:	b0 91 5f 20 	lds	r27, 0x205F
     cb0:	bc af       	std	Y+60, r27	; 0x3c
     cb2:	e0 91 60 20 	lds	r30, 0x2060
     cb6:	ed af       	std	Y+61, r30	; 0x3d
     cb8:	f0 91 61 20 	lds	r31, 0x2061
     cbc:	fe af       	std	Y+62, r31	; 0x3e
     cbe:	38 c2       	rjmp	.+1136   	; 0x1130 <gc_execute_line+0xa06>
						(gc.inverse_feed_rate_mode) ? 
						inverse_feed_rate : gc.feed_rate, gc.inverse_feed_rate_mode);
			break;
			case MOTION_MODE_CW_ARC: case MOTION_MODE_CCW_ARC:
				if (radius_mode) {
     cc0:	67 28       	or	r6, r7
     cc2:	09 f4       	brne	.+2      	; 0xcc6 <gc_execute_line+0x59c>
     cc4:	e2 c0       	rjmp	.+452    	; 0xe8a <gc_execute_line+0x760>
          	j = (y + (x * h_x2_div_d))/2
          
        */
        
        // Calculate the change in position along each selected axis
        double x = target[gc.plane_axis_0]-gc.position[gc.plane_axis_0];
     cc6:	e0 91 75 20 	lds	r30, 0x2075
     cca:	f0 e0       	ldi	r31, 0x00	; 0
     ccc:	ee 0f       	add	r30, r30
     cce:	ff 1f       	adc	r31, r31
     cd0:	ee 0f       	add	r30, r30
     cd2:	ff 1f       	adc	r31, r31
     cd4:	8e 01       	movw	r16, r28
     cd6:	0f 5f       	subi	r16, 0xFF	; 255
     cd8:	1f 4f       	sbci	r17, 0xFF	; 255
     cda:	d8 01       	movw	r26, r16
     cdc:	ae 0f       	add	r26, r30
     cde:	bf 1f       	adc	r27, r31
     ce0:	ea 59       	subi	r30, 0x9A	; 154
     ce2:	ff 4d       	sbci	r31, 0xDF	; 223
     ce4:	1b 96       	adiw	r26, 0x0b	; 11
     ce6:	6d 91       	ld	r22, X+
     ce8:	7d 91       	ld	r23, X+
     cea:	8d 91       	ld	r24, X+
     cec:	9c 91       	ld	r25, X
     cee:	1e 97       	sbiw	r26, 0x0e	; 14
     cf0:	20 81       	ld	r18, Z
     cf2:	31 81       	ldd	r19, Z+1	; 0x01
     cf4:	42 81       	ldd	r20, Z+2	; 0x02
     cf6:	53 81       	ldd	r21, Z+3	; 0x03
     cf8:	0e 94 ab 18 	call	0x3156	; 0x3156 <__subsf3>
     cfc:	1b 01       	movw	r2, r22
     cfe:	2c 01       	movw	r4, r24
        double y = target[gc.plane_axis_1]-gc.position[gc.plane_axis_1];
     d00:	e0 91 76 20 	lds	r30, 0x2076
     d04:	f0 e0       	ldi	r31, 0x00	; 0
     d06:	ee 0f       	add	r30, r30
     d08:	ff 1f       	adc	r31, r31
     d0a:	ee 0f       	add	r30, r30
     d0c:	ff 1f       	adc	r31, r31
     d0e:	0e 0f       	add	r16, r30
     d10:	1f 1f       	adc	r17, r31
     d12:	ea 59       	subi	r30, 0x9A	; 154
     d14:	ff 4d       	sbci	r31, 0xDF	; 223
     d16:	d8 01       	movw	r26, r16
     d18:	1b 96       	adiw	r26, 0x0b	; 11
     d1a:	6d 91       	ld	r22, X+
     d1c:	7d 91       	ld	r23, X+
     d1e:	8d 91       	ld	r24, X+
     d20:	9c 91       	ld	r25, X
     d22:	1e 97       	sbiw	r26, 0x0e	; 14
     d24:	20 81       	ld	r18, Z
     d26:	31 81       	ldd	r19, Z+1	; 0x01
     d28:	42 81       	ldd	r20, Z+2	; 0x02
     d2a:	53 81       	ldd	r21, Z+3	; 0x03
     d2c:	0e 94 ab 18 	call	0x3156	; 0x3156 <__subsf3>
     d30:	3b 01       	movw	r6, r22
     d32:	4c 01       	movw	r8, r24
        
        clear_vector(&offset);
     d34:	18 8e       	std	Y+24, r1	; 0x18
     d36:	19 8e       	std	Y+25, r1	; 0x19
        double h_x2_div_d = -sqrt(4 * r*r - x*x - y*y)/hypot(x,y); // == -(h * 2 / d)
     d38:	6d a5       	ldd	r22, Y+45	; 0x2d
     d3a:	7e a5       	ldd	r23, Y+46	; 0x2e
     d3c:	8f a5       	ldd	r24, Y+47	; 0x2f
     d3e:	98 a9       	ldd	r25, Y+48	; 0x30
     d40:	20 e0       	ldi	r18, 0x00	; 0
     d42:	30 e0       	ldi	r19, 0x00	; 0
     d44:	40 e8       	ldi	r20, 0x80	; 128
     d46:	50 e4       	ldi	r21, 0x40	; 64
     d48:	0e 94 40 1c 	call	0x3880	; 0x3880 <__mulsf3>
     d4c:	2d a5       	ldd	r18, Y+45	; 0x2d
     d4e:	3e a5       	ldd	r19, Y+46	; 0x2e
     d50:	4f a5       	ldd	r20, Y+47	; 0x2f
     d52:	58 a9       	ldd	r21, Y+48	; 0x30
     d54:	0e 94 40 1c 	call	0x3880	; 0x3880 <__mulsf3>
     d58:	7b 01       	movw	r14, r22
     d5a:	8c 01       	movw	r16, r24
     d5c:	c2 01       	movw	r24, r4
     d5e:	b1 01       	movw	r22, r2
     d60:	a2 01       	movw	r20, r4
     d62:	91 01       	movw	r18, r2
     d64:	0e 94 40 1c 	call	0x3880	; 0x3880 <__mulsf3>
     d68:	9b 01       	movw	r18, r22
     d6a:	ac 01       	movw	r20, r24
     d6c:	c8 01       	movw	r24, r16
     d6e:	b7 01       	movw	r22, r14
     d70:	0e 94 ab 18 	call	0x3156	; 0x3156 <__subsf3>
     d74:	7b 01       	movw	r14, r22
     d76:	8c 01       	movw	r16, r24
     d78:	c4 01       	movw	r24, r8
     d7a:	b3 01       	movw	r22, r6
     d7c:	a4 01       	movw	r20, r8
     d7e:	93 01       	movw	r18, r6
     d80:	0e 94 40 1c 	call	0x3880	; 0x3880 <__mulsf3>
     d84:	9b 01       	movw	r18, r22
     d86:	ac 01       	movw	r20, r24
     d88:	c8 01       	movw	r24, r16
     d8a:	b7 01       	movw	r22, r14
     d8c:	0e 94 ab 18 	call	0x3156	; 0x3156 <__subsf3>
     d90:	0e 94 cd 1c 	call	0x399a	; 0x399a <sqrt>
     d94:	7b 01       	movw	r14, r22
     d96:	8c 01       	movw	r16, r24
     d98:	c2 01       	movw	r24, r4
     d9a:	b1 01       	movw	r22, r2
     d9c:	a4 01       	movw	r20, r8
     d9e:	93 01       	movw	r18, r6
     da0:	0e 94 48 1b 	call	0x3690	; 0x3690 <hypot>
     da4:	9b 01       	movw	r18, r22
     da6:	ac 01       	movw	r20, r24
     da8:	17 fb       	bst	r17, 7
     daa:	10 95       	com	r17
     dac:	17 f9       	bld	r17, 7
     dae:	10 95       	com	r17
     db0:	c8 01       	movw	r24, r16
     db2:	b7 01       	movw	r22, r14
     db4:	0e 94 52 19 	call	0x32a4	; 0x32a4 <__divsf3>
     db8:	6b 01       	movw	r12, r22
     dba:	7c 01       	movw	r14, r24

        // If r is smaller than d, the arc is now traversing the complex plane beyond
		// the reach of any real CNC, and thus - for practical reasons - we will 
		// terminate promptly:
        if(isnan(h_x2_div_d)) { 
     dbc:	a7 01       	movw	r20, r14
     dbe:	96 01       	movw	r18, r12
     dc0:	0e 94 15 1d 	call	0x3a2a	; 0x3a2a <__unordsf2>
     dc4:	88 23       	and	r24, r24
     dc6:	21 f0       	breq	.+8      	; 0xdd0 <gc_execute_line+0x6a6>
			FAIL(GCSTATUS_FLOATING_POINT_ERROR); 
     dc8:	85 e0       	ldi	r24, 0x05	; 5
     dca:	80 93 56 20 	sts	0x2056, r24
     dce:	c6 c1       	rjmp	.+908    	; 0x115c <gc_execute_line+0xa32>
			return(gc.status_code); 
		}

        // Invert the sign of h_x2_div_d if circle is counter clockwise 
		// (see sketch below)
        if (gc.motion_mode == MOTION_MODE_CCW_ARC) {
     dd0:	b3 e0       	ldi	r27, 0x03	; 3
     dd2:	bb 16       	cp	r11, r27
     dd4:	21 f4       	brne	.+8      	; 0xdde <gc_execute_line+0x6b4>
			h_x2_div_d = -h_x2_div_d;
     dd6:	f7 fa       	bst	r15, 7
     dd8:	f0 94       	com	r15
     dda:	f7 f8       	bld	r15, 7
     ddc:	f0 94       	com	r15
        // Negative R is g-code-alese for "I want a circle with more than 180 degrees
		// of travel" (go figure!), even though it is advised against ever generating
		// such circles in a single line of g-code. By inverting the sign of 
		// h_x2_div_d the center of the circles is placed on the opposite side of 
		// the line of travel and thus we get the unadvisably long arcs as prescribed.
        if (r < 0) { 
     dde:	6d a5       	ldd	r22, Y+45	; 0x2d
     de0:	7e a5       	ldd	r23, Y+46	; 0x2e
     de2:	8f a5       	ldd	r24, Y+47	; 0x2f
     de4:	98 a9       	ldd	r25, Y+48	; 0x30
     de6:	20 e0       	ldi	r18, 0x00	; 0
     de8:	30 e0       	ldi	r19, 0x00	; 0
     dea:	40 e0       	ldi	r20, 0x00	; 0
     dec:	50 e0       	ldi	r21, 0x00	; 0
     dee:	0e 94 4b 19 	call	0x3296	; 0x3296 <__cmpsf2>
     df2:	88 23       	and	r24, r24
     df4:	24 f4       	brge	.+8      	; 0xdfe <gc_execute_line+0x6d4>
			h_x2_div_d = -h_x2_div_d; 
     df6:	f7 fa       	bst	r15, 7
     df8:	f0 94       	com	r15
     dfa:	f7 f8       	bld	r15, 7
     dfc:	f0 94       	com	r15
		}        
        
		// Complete the operation by calculating the actual center of the arc
        offset[gc.plane_axis_0] = (x-(y*h_x2_div_d))/2;
     dfe:	00 91 75 20 	lds	r16, 0x2075
     e02:	a0 2e       	mov	r10, r16
     e04:	bb 24       	eor	r11, r11
     e06:	aa 0c       	add	r10, r10
     e08:	bb 1c       	adc	r11, r11
     e0a:	aa 0c       	add	r10, r10
     e0c:	bb 1c       	adc	r11, r11
     e0e:	8e 01       	movw	r16, r28
     e10:	0f 5f       	subi	r16, 0xFF	; 255
     e12:	1f 4f       	sbci	r17, 0xFF	; 255
     e14:	a0 0e       	add	r10, r16
     e16:	b1 1e       	adc	r11, r17
     e18:	c4 01       	movw	r24, r8
     e1a:	b3 01       	movw	r22, r6
     e1c:	a7 01       	movw	r20, r14
     e1e:	96 01       	movw	r18, r12
     e20:	0e 94 40 1c 	call	0x3880	; 0x3880 <__mulsf3>
     e24:	9b 01       	movw	r18, r22
     e26:	ac 01       	movw	r20, r24
     e28:	c2 01       	movw	r24, r4
     e2a:	b1 01       	movw	r22, r2
     e2c:	0e 94 ab 18 	call	0x3156	; 0x3156 <__subsf3>
     e30:	20 e0       	ldi	r18, 0x00	; 0
     e32:	30 e0       	ldi	r19, 0x00	; 0
     e34:	40 e0       	ldi	r20, 0x00	; 0
     e36:	5f e3       	ldi	r21, 0x3F	; 63
     e38:	0e 94 40 1c 	call	0x3880	; 0x3880 <__mulsf3>
     e3c:	f5 01       	movw	r30, r10
     e3e:	67 8b       	std	Z+23, r22	; 0x17
     e40:	70 8f       	std	Z+24, r23	; 0x18
     e42:	81 8f       	std	Z+25, r24	; 0x19
     e44:	92 8f       	std	Z+26, r25	; 0x1a
        offset[gc.plane_axis_1] = (y+(x*h_x2_div_d))/2;
     e46:	80 91 76 20 	lds	r24, 0x2076
     e4a:	90 e0       	ldi	r25, 0x00	; 0
     e4c:	88 0f       	add	r24, r24
     e4e:	99 1f       	adc	r25, r25
     e50:	88 0f       	add	r24, r24
     e52:	99 1f       	adc	r25, r25
     e54:	08 0f       	add	r16, r24
     e56:	19 1f       	adc	r17, r25
     e58:	c2 01       	movw	r24, r4
     e5a:	b1 01       	movw	r22, r2
     e5c:	a7 01       	movw	r20, r14
     e5e:	96 01       	movw	r18, r12
     e60:	0e 94 40 1c 	call	0x3880	; 0x3880 <__mulsf3>
     e64:	9b 01       	movw	r18, r22
     e66:	ac 01       	movw	r20, r24
     e68:	c4 01       	movw	r24, r8
     e6a:	b3 01       	movw	r22, r6
     e6c:	0e 94 ac 18 	call	0x3158	; 0x3158 <__addsf3>
     e70:	20 e0       	ldi	r18, 0x00	; 0
     e72:	30 e0       	ldi	r19, 0x00	; 0
     e74:	40 e0       	ldi	r20, 0x00	; 0
     e76:	5f e3       	ldi	r21, 0x3F	; 63
     e78:	0e 94 40 1c 	call	0x3880	; 0x3880 <__mulsf3>
     e7c:	d8 01       	movw	r26, r16
     e7e:	57 96       	adiw	r26, 0x17	; 23
     e80:	6d 93       	st	X+, r22
     e82:	7d 93       	st	X+, r23
     e84:	8d 93       	st	X+, r24
     e86:	9c 93       	st	X, r25
     e88:	5a 97       	sbiw	r26, 0x1a	; 26
                    C   <- theta_start (e.g. -145 degrees: theta_start == -PI*(3/4))

      */
            
      // calculate the theta (angle) of the current point
      double theta_start = theta(-offset[gc.plane_axis_0], -offset[gc.plane_axis_1]);
     e8a:	e0 91 75 20 	lds	r30, 0x2075
     e8e:	f0 e0       	ldi	r31, 0x00	; 0
     e90:	ee 0f       	add	r30, r30
     e92:	ff 1f       	adc	r31, r31
     e94:	ee 0f       	add	r30, r30
     e96:	ff 1f       	adc	r31, r31
     e98:	8e 01       	movw	r16, r28
     e9a:	0f 5f       	subi	r16, 0xFF	; 255
     e9c:	1f 4f       	sbci	r17, 0xFF	; 255
     e9e:	e0 0f       	add	r30, r16
     ea0:	f1 1f       	adc	r31, r17
     ea2:	67 89       	ldd	r22, Z+23	; 0x17
     ea4:	70 8d       	ldd	r23, Z+24	; 0x18
     ea6:	81 8d       	ldd	r24, Z+25	; 0x19
     ea8:	92 8d       	ldd	r25, Z+26	; 0x1a
     eaa:	90 58       	subi	r25, 0x80	; 128
     eac:	e0 91 76 20 	lds	r30, 0x2076
     eb0:	f0 e0       	ldi	r31, 0x00	; 0
     eb2:	ee 0f       	add	r30, r30
     eb4:	ff 1f       	adc	r31, r31
     eb6:	ee 0f       	add	r30, r30
     eb8:	ff 1f       	adc	r31, r31
     eba:	e0 0f       	add	r30, r16
     ebc:	f1 1f       	adc	r31, r17
     ebe:	27 89       	ldd	r18, Z+23	; 0x17
     ec0:	30 8d       	ldd	r19, Z+24	; 0x18
     ec2:	41 8d       	ldd	r20, Z+25	; 0x19
     ec4:	52 8d       	ldd	r21, Z+26	; 0x1a
     ec6:	50 58       	subi	r21, 0x80	; 128
     ec8:	0e 94 56 03 	call	0x6ac	; 0x6ac <theta>
     ecc:	69 a7       	std	Y+41, r22	; 0x29
     ece:	7a a7       	std	Y+42, r23	; 0x2a
     ed0:	8b a7       	std	Y+43, r24	; 0x2b
     ed2:	9c a7       	std	Y+44, r25	; 0x2c
		
      // calculate the theta (angle) of the target point
      double theta_end = theta(target[gc.plane_axis_0] - offset[gc.plane_axis_0] - gc.position[gc.plane_axis_0], 
         target[gc.plane_axis_1] - offset[gc.plane_axis_1] - gc.position[gc.plane_axis_1]);
     ed4:	20 91 75 20 	lds	r18, 0x2075
     ed8:	e2 2e       	mov	r14, r18
     eda:	ff 24       	eor	r15, r15
     edc:	20 91 76 20 	lds	r18, 0x2076
     ee0:	a2 2e       	mov	r10, r18
     ee2:	bb 24       	eor	r11, r11
     ee4:	ee 0c       	add	r14, r14
     ee6:	ff 1c       	adc	r15, r15
     ee8:	ee 0c       	add	r14, r14
     eea:	ff 1c       	adc	r15, r15
     eec:	f8 01       	movw	r30, r16
     eee:	ee 0d       	add	r30, r14
     ef0:	ff 1d       	adc	r31, r15
     ef2:	63 85       	ldd	r22, Z+11	; 0x0b
     ef4:	74 85       	ldd	r23, Z+12	; 0x0c
     ef6:	85 85       	ldd	r24, Z+13	; 0x0d
     ef8:	96 85       	ldd	r25, Z+14	; 0x0e
     efa:	27 89       	ldd	r18, Z+23	; 0x17
     efc:	30 8d       	ldd	r19, Z+24	; 0x18
     efe:	41 8d       	ldd	r20, Z+25	; 0x19
     f00:	52 8d       	ldd	r21, Z+26	; 0x1a
     f02:	0e 94 ab 18 	call	0x3156	; 0x3156 <__subsf3>
     f06:	e6 e6       	ldi	r30, 0x66	; 102
     f08:	f0 e2       	ldi	r31, 0x20	; 32
     f0a:	ee 0e       	add	r14, r30
     f0c:	ff 1e       	adc	r15, r31
     f0e:	d7 01       	movw	r26, r14
     f10:	2d 91       	ld	r18, X+
     f12:	3d 91       	ld	r19, X+
     f14:	4d 91       	ld	r20, X+
     f16:	5c 91       	ld	r21, X
     f18:	0e 94 ab 18 	call	0x3156	; 0x3156 <__subsf3>
     f1c:	6b 01       	movw	r12, r22
     f1e:	7c 01       	movw	r14, r24
     f20:	aa 0c       	add	r10, r10
     f22:	bb 1c       	adc	r11, r11
     f24:	aa 0c       	add	r10, r10
     f26:	bb 1c       	adc	r11, r11
     f28:	0a 0d       	add	r16, r10
     f2a:	1b 1d       	adc	r17, r11
     f2c:	f8 01       	movw	r30, r16
     f2e:	63 85       	ldd	r22, Z+11	; 0x0b
     f30:	74 85       	ldd	r23, Z+12	; 0x0c
     f32:	85 85       	ldd	r24, Z+13	; 0x0d
     f34:	96 85       	ldd	r25, Z+14	; 0x0e
     f36:	27 89       	ldd	r18, Z+23	; 0x17
     f38:	30 8d       	ldd	r19, Z+24	; 0x18
     f3a:	41 8d       	ldd	r20, Z+25	; 0x19
     f3c:	52 8d       	ldd	r21, Z+26	; 0x1a
     f3e:	0e 94 ab 18 	call	0x3156	; 0x3156 <__subsf3>
     f42:	26 e6       	ldi	r18, 0x66	; 102
     f44:	30 e2       	ldi	r19, 0x20	; 32
     f46:	a2 0e       	add	r10, r18
     f48:	b3 1e       	adc	r11, r19
     f4a:	d5 01       	movw	r26, r10
     f4c:	2d 91       	ld	r18, X+
     f4e:	3d 91       	ld	r19, X+
     f50:	4d 91       	ld	r20, X+
     f52:	5c 91       	ld	r21, X
     f54:	0e 94 ab 18 	call	0x3156	; 0x3156 <__subsf3>
     f58:	9b 01       	movw	r18, r22
     f5a:	ac 01       	movw	r20, r24
     f5c:	c7 01       	movw	r24, r14
     f5e:	b6 01       	movw	r22, r12
     f60:	0e 94 56 03 	call	0x6ac	; 0x6ac <theta>
     f64:	7b 01       	movw	r14, r22
     f66:	8c 01       	movw	r16, r24

      // double theta_end = theta(5,0);
      // ensure that the difference is positive so that we have clockwise travel
      if (theta_end < theta_start) {
     f68:	29 a5       	ldd	r18, Y+41	; 0x29
     f6a:	3a a5       	ldd	r19, Y+42	; 0x2a
     f6c:	4b a5       	ldd	r20, Y+43	; 0x2b
     f6e:	5c a5       	ldd	r21, Y+44	; 0x2c
     f70:	0e 94 4b 19 	call	0x3296	; 0x3296 <__cmpsf2>
     f74:	88 23       	and	r24, r24
     f76:	54 f4       	brge	.+20     	; 0xf8c <gc_execute_line+0x862>
	  	theta_end += 2*M_PI;
     f78:	c8 01       	movw	r24, r16
     f7a:	b7 01       	movw	r22, r14
     f7c:	2b ed       	ldi	r18, 0xDB	; 219
     f7e:	3f e0       	ldi	r19, 0x0F	; 15
     f80:	49 ec       	ldi	r20, 0xC9	; 201
     f82:	50 e4       	ldi	r21, 0x40	; 64
     f84:	0e 94 ac 18 	call	0x3158	; 0x3158 <__addsf3>
     f88:	7b 01       	movw	r14, r22
     f8a:	8c 01       	movw	r16, r24
	  }
      double angular_travel = theta_end-theta_start;
     f8c:	c8 01       	movw	r24, r16
     f8e:	b7 01       	movw	r22, r14
     f90:	29 a5       	ldd	r18, Y+41	; 0x29
     f92:	3a a5       	ldd	r19, Y+42	; 0x2a
     f94:	4b a5       	ldd	r20, Y+43	; 0x2b
     f96:	5c a5       	ldd	r21, Y+44	; 0x2c
     f98:	0e 94 ab 18 	call	0x3156	; 0x3156 <__subsf3>
     f9c:	1b 01       	movw	r2, r22
     f9e:	2c 01       	movw	r4, r24

      // Invert angular motion if the g-code wanted a counterclockwise arc
      if (gc.motion_mode == MOTION_MODE_CCW_ARC) {
     fa0:	80 91 57 20 	lds	r24, 0x2057
     fa4:	83 30       	cpi	r24, 0x03	; 3
     fa6:	51 f4       	brne	.+20     	; 0xfbc <gc_execute_line+0x892>
        angular_travel = angular_travel-2*M_PI;
     fa8:	c2 01       	movw	r24, r4
     faa:	b1 01       	movw	r22, r2
     fac:	2b ed       	ldi	r18, 0xDB	; 219
     fae:	3f e0       	ldi	r19, 0x0F	; 15
     fb0:	49 ec       	ldi	r20, 0xC9	; 201
     fb2:	50 e4       	ldi	r21, 0x40	; 64
     fb4:	0e 94 ab 18 	call	0x3156	; 0x3156 <__subsf3>
     fb8:	1b 01       	movw	r2, r22
     fba:	2c 01       	movw	r4, r24
      }

      // Find the radius
      double radius = hypot(offset[gc.plane_axis_0], offset[gc.plane_axis_1]);
     fbc:	80 91 75 20 	lds	r24, 0x2075
     fc0:	e8 2f       	mov	r30, r24
     fc2:	f0 e0       	ldi	r31, 0x00	; 0
     fc4:	ef a3       	std	Y+39, r30	; 0x27
     fc6:	f8 a7       	std	Y+40, r31	; 0x28
     fc8:	ee 0f       	add	r30, r30
     fca:	ff 1f       	adc	r31, r31
     fcc:	ee 0f       	add	r30, r30
     fce:	ff 1f       	adc	r31, r31
     fd0:	de 01       	movw	r26, r28
     fd2:	11 96       	adiw	r26, 0x01	; 1
     fd4:	ea 0f       	add	r30, r26
     fd6:	fb 1f       	adc	r31, r27
     fd8:	e7 88       	ldd	r14, Z+23	; 0x17
     fda:	f0 8c       	ldd	r15, Z+24	; 0x18
     fdc:	01 8d       	ldd	r16, Z+25	; 0x19
     fde:	12 8d       	ldd	r17, Z+26	; 0x1a
     fe0:	80 91 76 20 	lds	r24, 0x2076
     fe4:	28 2f       	mov	r18, r24
     fe6:	30 e0       	ldi	r19, 0x00	; 0
     fe8:	2d a3       	std	Y+37, r18	; 0x25
     fea:	3e a3       	std	Y+38, r19	; 0x26
     fec:	f9 01       	movw	r30, r18
     fee:	ee 0f       	add	r30, r30
     ff0:	ff 1f       	adc	r31, r31
     ff2:	ee 0f       	add	r30, r30
     ff4:	ff 1f       	adc	r31, r31
     ff6:	ea 0f       	add	r30, r26
     ff8:	fb 1f       	adc	r31, r27
     ffa:	27 89       	ldd	r18, Z+23	; 0x17
     ffc:	30 8d       	ldd	r19, Z+24	; 0x18
     ffe:	41 8d       	ldd	r20, Z+25	; 0x19
    1000:	52 8d       	ldd	r21, Z+26	; 0x1a

      // Calculate the motion along the depth axis of the helix
      double depth = target[gc.plane_axis_2]-gc.position[gc.plane_axis_2];
    1002:	80 91 77 20 	lds	r24, 0x2077
    1006:	68 2e       	mov	r6, r24
    1008:	77 24       	eor	r7, r7
    100a:	c3 01       	movw	r24, r6
    100c:	88 0f       	add	r24, r24
    100e:	99 1f       	adc	r25, r25
    1010:	88 0f       	add	r24, r24
    1012:	99 1f       	adc	r25, r25
    1014:	a8 0f       	add	r26, r24
    1016:	b9 1f       	adc	r27, r25
    1018:	1b 96       	adiw	r26, 0x0b	; 11
    101a:	6d 91       	ld	r22, X+
    101c:	7d 91       	ld	r23, X+
    101e:	8d 91       	ld	r24, X+
    1020:	9c 91       	ld	r25, X
    1022:	1e 97       	sbiw	r26, 0x0e	; 14
    1024:	6b ab       	std	Y+51, r22	; 0x33
    1026:	7c ab       	std	Y+52, r23	; 0x34
    1028:	8d ab       	std	Y+53, r24	; 0x35
    102a:	9e ab       	std	Y+54, r25	; 0x36
    102c:	f3 01       	movw	r30, r6
    102e:	ee 0f       	add	r30, r30
    1030:	ff 1f       	adc	r31, r31
    1032:	ee 0f       	add	r30, r30
    1034:	ff 1f       	adc	r31, r31
    1036:	ea 59       	subi	r30, 0x9A	; 154
    1038:	ff 4d       	sbci	r31, 0xDF	; 223
    103a:	a0 80       	ld	r10, Z
    103c:	b1 80       	ldd	r11, Z+1	; 0x01
    103e:	c2 80       	ldd	r12, Z+2	; 0x02
    1040:	d3 80       	ldd	r13, Z+3	; 0x03

      // Trace the arc
      mc_arc(theta_start, angular_travel, radius, depth, 
    1042:	70 91 58 20 	lds	r23, 0x2058
    1046:	7c a3       	std	Y+36, r23	; 0x24
    1048:	77 23       	and	r23, r23
    104a:	49 f0       	breq	.+18     	; 0x105e <gc_execute_line+0x934>
    104c:	8b ad       	ldd	r24, Y+59	; 0x3b
    104e:	8f ab       	std	Y+55, r24	; 0x37
    1050:	9c ad       	ldd	r25, Y+60	; 0x3c
    1052:	98 af       	std	Y+56, r25	; 0x38
    1054:	ad ad       	ldd	r26, Y+61	; 0x3d
    1056:	a9 af       	std	Y+57, r26	; 0x39
    1058:	be ad       	ldd	r27, Y+62	; 0x3e
    105a:	ba af       	std	Y+58, r27	; 0x3a
    105c:	0c c0       	rjmp	.+24     	; 0x1076 <gc_execute_line+0x94c>
    105e:	e0 91 5e 20 	lds	r30, 0x205E
    1062:	ef ab       	std	Y+55, r30	; 0x37
    1064:	f0 91 5f 20 	lds	r31, 0x205F
    1068:	f8 af       	std	Y+56, r31	; 0x38
    106a:	60 91 60 20 	lds	r22, 0x2060
    106e:	69 af       	std	Y+57, r22	; 0x39
    1070:	70 91 61 20 	lds	r23, 0x2061
    1074:	7a af       	std	Y+58, r23	; 0x3a
      if (gc.motion_mode == MOTION_MODE_CCW_ARC) {
        angular_travel = angular_travel-2*M_PI;
      }

      // Find the radius
      double radius = hypot(offset[gc.plane_axis_0], offset[gc.plane_axis_1]);
    1076:	c8 01       	movw	r24, r16
    1078:	b7 01       	movw	r22, r14
    107a:	0e 94 48 1b 	call	0x3690	; 0x3690 <hypot>
    107e:	7b 01       	movw	r14, r22
    1080:	8c 01       	movw	r16, r24

      // Calculate the motion along the depth axis of the helix
      double depth = target[gc.plane_axis_2]-gc.position[gc.plane_axis_2];

      // Trace the arc
      mc_arc(theta_start, angular_travel, radius, depth, 
    1082:	8d b7       	in	r24, 0x3d	; 61
    1084:	9e b7       	in	r25, 0x3e	; 62
    1086:	0a 97       	sbiw	r24, 0x0a	; 10
    1088:	8d bf       	out	0x3d, r24	; 61
    108a:	9e bf       	out	0x3e, r25	; 62
    108c:	8d b6       	in	r8, 0x3d	; 61
    108e:	9e b6       	in	r9, 0x3e	; 62
    1090:	08 94       	sec
    1092:	81 1c       	adc	r8, r1
    1094:	91 1c       	adc	r9, r1
    1096:	6b a9       	ldd	r22, Y+51	; 0x33
    1098:	7c a9       	ldd	r23, Y+52	; 0x34
    109a:	8d a9       	ldd	r24, Y+53	; 0x35
    109c:	9e a9       	ldd	r25, Y+54	; 0x36
    109e:	a6 01       	movw	r20, r12
    10a0:	95 01       	movw	r18, r10
    10a2:	0e 94 ab 18 	call	0x3156	; 0x3156 <__subsf3>
    10a6:	5b 01       	movw	r10, r22
    10a8:	6c 01       	movw	r12, r24
    10aa:	ed a1       	ldd	r30, Y+37	; 0x25
    10ac:	fe a1       	ldd	r31, Y+38	; 0x26
    10ae:	d4 01       	movw	r26, r8
    10b0:	ed 93       	st	X+, r30
    10b2:	fc 93       	st	X, r31
    10b4:	11 97       	sbiw	r26, 0x01	; 1
    10b6:	12 96       	adiw	r26, 0x02	; 2
    10b8:	6d 92       	st	X+, r6
    10ba:	7c 92       	st	X, r7
    10bc:	13 97       	sbiw	r26, 0x03	; 3
    10be:	2f a9       	ldd	r18, Y+55	; 0x37
    10c0:	38 ad       	ldd	r19, Y+56	; 0x38
    10c2:	49 ad       	ldd	r20, Y+57	; 0x39
    10c4:	5a ad       	ldd	r21, Y+58	; 0x3a
    10c6:	c9 01       	movw	r24, r18
    10c8:	da 01       	movw	r26, r20
    10ca:	f4 01       	movw	r30, r8
    10cc:	84 83       	std	Z+4, r24	; 0x04
    10ce:	95 83       	std	Z+5, r25	; 0x05
    10d0:	a6 83       	std	Z+6, r26	; 0x06
    10d2:	b7 83       	std	Z+7, r27	; 0x07
    10d4:	2c a1       	ldd	r18, Y+36	; 0x24
    10d6:	20 87       	std	Z+8, r18	; 0x08
    10d8:	11 86       	std	Z+9, r1	; 0x09
    10da:	69 a5       	ldd	r22, Y+41	; 0x29
    10dc:	7a a5       	ldd	r23, Y+42	; 0x2a
    10de:	8b a5       	ldd	r24, Y+43	; 0x2b
    10e0:	9c a5       	ldd	r25, Y+44	; 0x2c
    10e2:	a2 01       	movw	r20, r4
    10e4:	91 01       	movw	r18, r2
    10e6:	8f a0       	ldd	r8, Y+39	; 0x27
    10e8:	98 a4       	ldd	r9, Y+40	; 0x28
    10ea:	0e 94 37 0d 	call	0x1a6e	; 0x1a6e <mc_arc>
	  			gc.plane_axis_1, 
				gc.plane_axis_2, 
        (gc.inverse_feed_rate_mode) ? inverse_feed_rate : gc.feed_rate, gc.inverse_feed_rate_mode);

      // Finish off with a line to make sure we arrive exactly where we think we are
      mc_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], 
    10ee:	6c 85       	ldd	r22, Y+12	; 0x0c
    10f0:	7d 85       	ldd	r23, Y+13	; 0x0d
    10f2:	8e 85       	ldd	r24, Y+14	; 0x0e
    10f4:	9f 85       	ldd	r25, Y+15	; 0x0f
    10f6:	28 89       	ldd	r18, Y+16	; 0x10
    10f8:	39 89       	ldd	r19, Y+17	; 0x11
    10fa:	4a 89       	ldd	r20, Y+18	; 0x12
    10fc:	5b 89       	ldd	r21, Y+19	; 0x13
    10fe:	ec 88       	ldd	r14, Y+20	; 0x14
    1100:	fd 88       	ldd	r15, Y+21	; 0x15
    1102:	0e 89       	ldd	r16, Y+22	; 0x16
    1104:	1f 89       	ldd	r17, Y+23	; 0x17
    1106:	80 90 58 20 	lds	r8, 0x2058
    110a:	ad b7       	in	r26, 0x3d	; 61
    110c:	be b7       	in	r27, 0x3e	; 62
    110e:	1a 96       	adiw	r26, 0x0a	; 10
    1110:	ad bf       	out	0x3d, r26	; 61
    1112:	be bf       	out	0x3e, r27	; 62
    1114:	88 20       	and	r8, r8
    1116:	61 f4       	brne	.+24     	; 0x1130 <gc_execute_line+0xa06>
    1118:	b0 91 5e 20 	lds	r27, 0x205E
    111c:	bb af       	std	Y+59, r27	; 0x3b
    111e:	e0 91 5f 20 	lds	r30, 0x205F
    1122:	ec af       	std	Y+60, r30	; 0x3c
    1124:	f0 91 60 20 	lds	r31, 0x2060
    1128:	fd af       	std	Y+61, r31	; 0x3d
    112a:	a0 91 61 20 	lds	r26, 0x2061
    112e:	ae af       	std	Y+62, r26	; 0x3e
    1130:	eb ad       	ldd	r30, Y+59	; 0x3b
    1132:	fc ad       	ldd	r31, Y+60	; 0x3c
    1134:	ad ad       	ldd	r26, Y+61	; 0x3d
    1136:	be ad       	ldd	r27, Y+62	; 0x3e
    1138:	5f 01       	movw	r10, r30
    113a:	6d 01       	movw	r12, r26
    113c:	99 24       	eor	r9, r9
    113e:	0e 94 0e 0c 	call	0x181c	; 0x181c <mc_line>
  }
  /* As far as the parser is concerned, the position is now == target. In reality 
  	 the motion control system might still be processing the action and the real 
	 tool position in any intermediate location.
  */
  memcpy(gc.position, target, sizeof(double)*3);
    1142:	a6 e6       	ldi	r26, 0x66	; 102
    1144:	b0 e2       	ldi	r27, 0x20	; 32
    1146:	fe 01       	movw	r30, r28
    1148:	3c 96       	adiw	r30, 0x0c	; 12
    114a:	8c e0       	ldi	r24, 0x0C	; 12
    114c:	01 90       	ld	r0, Z+
    114e:	0d 92       	st	X+, r0
    1150:	81 50       	subi	r24, 0x01	; 1
    1152:	e1 f7       	brne	.-8      	; 0x114c <gc_execute_line+0xa22>
  return(gc.status_code);
    1154:	80 91 56 20 	lds	r24, 0x2056
    1158:	01 c0       	rjmp	.+2      	; 0x115c <gc_execute_line+0xa32>
    115a:	83 e0       	ldi	r24, 0x03	; 3
}
    115c:	ee 96       	adiw	r28, 0x3e	; 62
    115e:	cd bf       	out	0x3d, r28	; 61
    1160:	de bf       	out	0x3e, r29	; 62
    1162:	cf 91       	pop	r28
    1164:	df 91       	pop	r29
    1166:	1f 91       	pop	r17
    1168:	0f 91       	pop	r16
    116a:	ff 90       	pop	r15
    116c:	ef 90       	pop	r14
    116e:	df 90       	pop	r13
    1170:	cf 90       	pop	r12
    1172:	bf 90       	pop	r11
    1174:	af 90       	pop	r10
    1176:	9f 90       	pop	r9
    1178:	8f 90       	pop	r8
    117a:	7f 90       	pop	r7
    117c:	6f 90       	pop	r6
    117e:	5f 90       	pop	r5
    1180:	4f 90       	pop	r4
    1182:	3f 90       	pop	r3
    1184:	2f 90       	pop	r2
    1186:	08 95       	ret

00001188 <reset_settings>:
#include "wiring_serial.h"
#include <avr/pgmspace.h>

void reset_settings() 
{
	settings.steps_per_mm[0] = X_STEPS_PER_MM;
    1188:	86 ef       	ldi	r24, 0xF6	; 246
    118a:	9a e7       	ldi	r25, 0x7A	; 122
    118c:	ad e1       	ldi	r26, 0x1D	; 29
    118e:	b4 e4       	ldi	r27, 0x44	; 68
    1190:	80 93 3b 20 	sts	0x203B, r24
    1194:	90 93 3c 20 	sts	0x203C, r25
    1198:	a0 93 3d 20 	sts	0x203D, r26
    119c:	b0 93 3e 20 	sts	0x203E, r27
	settings.steps_per_mm[1] = Y_STEPS_PER_MM;
    11a0:	80 93 3f 20 	sts	0x203F, r24
    11a4:	90 93 40 20 	sts	0x2040, r25
    11a8:	a0 93 41 20 	sts	0x2041, r26
    11ac:	b0 93 42 20 	sts	0x2042, r27
	settings.steps_per_mm[2] = Z_STEPS_PER_MM;
    11b0:	80 93 43 20 	sts	0x2043, r24
    11b4:	90 93 44 20 	sts	0x2044, r25
    11b8:	a0 93 45 20 	sts	0x2045, r26
    11bc:	b0 93 46 20 	sts	0x2046, r27
	settings.pulse_microseconds = STEP_PULSE_MICROSECONDS;
    11c0:	82 e0       	ldi	r24, 0x02	; 2
    11c2:	80 93 48 20 	sts	0x2048, r24
	settings.default_feed_rate = DEFAULT_FEEDRATE;
    11c6:	80 e0       	ldi	r24, 0x00	; 0
    11c8:	90 e0       	ldi	r25, 0x00	; 0
    11ca:	a6 e9       	ldi	r26, 0x96	; 150
    11cc:	b3 e4       	ldi	r27, 0x43	; 67
    11ce:	80 93 49 20 	sts	0x2049, r24
    11d2:	90 93 4a 20 	sts	0x204A, r25
    11d6:	a0 93 4b 20 	sts	0x204B, r26
    11da:	b0 93 4c 20 	sts	0x204C, r27
	settings.default_seek_rate = RAPID_FEEDRATE;
    11de:	80 e0       	ldi	r24, 0x00	; 0
    11e0:	90 e0       	ldi	r25, 0x00	; 0
    11e2:	a0 ef       	ldi	r26, 0xF0	; 240
    11e4:	b3 e4       	ldi	r27, 0x43	; 67
    11e6:	80 93 4d 20 	sts	0x204D, r24
    11ea:	90 93 4e 20 	sts	0x204E, r25
    11ee:	a0 93 4f 20 	sts	0x204F, r26
    11f2:	b0 93 50 20 	sts	0x2050, r27
	settings.mm_per_arc_segment = MM_PER_ARC_SEGMENT;
    11f6:	8d ec       	ldi	r24, 0xCD	; 205
    11f8:	9c ec       	ldi	r25, 0xCC	; 204
    11fa:	ac ec       	ldi	r26, 0xCC	; 204
    11fc:	bd e3       	ldi	r27, 0x3D	; 61
    11fe:	80 93 52 20 	sts	0x2052, r24
    1202:	90 93 53 20 	sts	0x2053, r25
    1206:	a0 93 54 20 	sts	0x2054, r26
    120a:	b0 93 55 20 	sts	0x2055, r27
	settings.invert_mask = STEPPING_INVERT_MASK;
    120e:	10 92 51 20 	sts	0x2051, r1
}
    1212:	08 95       	ret

00001214 <write_settings>:
  	return(TRUE);
}

void write_settings() 
{
	eeprom_put_char(0, SETTINGS_VERSION);
    1214:	80 e0       	ldi	r24, 0x00	; 0
    1216:	90 e0       	ldi	r25, 0x00	; 0
    1218:	64 e6       	ldi	r22, 0x64	; 100
    121a:	0e 94 eb 0a 	call	0x15d6	; 0x15d6 <eeprom_put_char>
	memcpy_to_eeprom_with_checksum(1, (char*)&settings, sizeof(struct Settings));
    121e:	81 e0       	ldi	r24, 0x01	; 1
    1220:	90 e0       	ldi	r25, 0x00	; 0
    1222:	6b e3       	ldi	r22, 0x3B	; 59
    1224:	70 e2       	ldi	r23, 0x20	; 32
    1226:	4b e1       	ldi	r20, 0x1B	; 27
    1228:	50 e0       	ldi	r21, 0x00	; 0
    122a:	0e 94 f6 0a 	call	0x15ec	; 0x15ec <memcpy_to_eeprom_with_checksum>
}
    122e:	08 95       	ret

00001230 <store_setting>:

/* store_setting() - a helper method to set settings from command line */

void store_setting(int parameter, double value) 
{
    1230:	fc 01       	movw	r30, r24
	switch(parameter) {
    1232:	84 30       	cpi	r24, 0x04	; 4
    1234:	91 05       	cpc	r25, r1
    1236:	39 f1       	breq	.+78     	; 0x1286 <store_setting+0x56>
    1238:	85 30       	cpi	r24, 0x05	; 5
    123a:	91 05       	cpc	r25, r1
    123c:	34 f4       	brge	.+12     	; 0x124a <store_setting+0x1a>
    123e:	97 fd       	sbrc	r25, 7
    1240:	46 c0       	rjmp	.+140    	; 0x12ce <store_setting+0x9e>
    1242:	83 30       	cpi	r24, 0x03	; 3
    1244:	91 05       	cpc	r25, r1
    1246:	5c f0       	brlt	.+22     	; 0x125e <store_setting+0x2e>
    1248:	15 c0       	rjmp	.+42     	; 0x1274 <store_setting+0x44>
    124a:	86 30       	cpi	r24, 0x06	; 6
    124c:	91 05       	cpc	r25, r1
    124e:	69 f1       	breq	.+90     	; 0x12aa <store_setting+0x7a>
    1250:	86 30       	cpi	r24, 0x06	; 6
    1252:	91 05       	cpc	r25, r1
    1254:	0c f1       	brlt	.+66     	; 0x1298 <store_setting+0x68>
    1256:	87 30       	cpi	r24, 0x07	; 7
    1258:	91 05       	cpc	r25, r1
    125a:	c9 f5       	brne	.+114    	; 0x12ce <store_setting+0x9e>
    125c:	2f c0       	rjmp	.+94     	; 0x12bc <store_setting+0x8c>
    	case 0: case 1: case 2: settings.steps_per_mm[parameter] = value; break;
    125e:	ee 0f       	add	r30, r30
    1260:	ff 1f       	adc	r31, r31
    1262:	ee 0f       	add	r30, r30
    1264:	ff 1f       	adc	r31, r31
    1266:	e5 5c       	subi	r30, 0xC5	; 197
    1268:	ff 4d       	sbci	r31, 0xDF	; 223
    126a:	40 83       	st	Z, r20
    126c:	51 83       	std	Z+1, r21	; 0x01
    126e:	62 83       	std	Z+2, r22	; 0x02
    1270:	73 83       	std	Z+3, r23	; 0x03
    1272:	30 c0       	rjmp	.+96     	; 0x12d4 <store_setting+0xa4>
    	case 3: settings.pulse_microseconds = round(value); break;
    1274:	cb 01       	movw	r24, r22
    1276:	ba 01       	movw	r22, r20
    1278:	0e 94 a3 1c 	call	0x3946	; 0x3946 <round>
    127c:	0e 94 bf 19 	call	0x337e	; 0x337e <__fixunssfsi>
    1280:	60 93 48 20 	sts	0x2048, r22
    1284:	27 c0       	rjmp	.+78     	; 0x12d4 <store_setting+0xa4>
    	case 4: settings.default_feed_rate = value; break;
    1286:	40 93 49 20 	sts	0x2049, r20
    128a:	50 93 4a 20 	sts	0x204A, r21
    128e:	60 93 4b 20 	sts	0x204B, r22
    1292:	70 93 4c 20 	sts	0x204C, r23
    1296:	1e c0       	rjmp	.+60     	; 0x12d4 <store_setting+0xa4>
    	case 5: settings.default_seek_rate = value; break;
    1298:	40 93 4d 20 	sts	0x204D, r20
    129c:	50 93 4e 20 	sts	0x204E, r21
    12a0:	60 93 4f 20 	sts	0x204F, r22
    12a4:	70 93 50 20 	sts	0x2050, r23
    12a8:	15 c0       	rjmp	.+42     	; 0x12d4 <store_setting+0xa4>
    	case 6: settings.mm_per_arc_segment = value; break;
    12aa:	40 93 52 20 	sts	0x2052, r20
    12ae:	50 93 53 20 	sts	0x2053, r21
    12b2:	60 93 54 20 	sts	0x2054, r22
    12b6:	70 93 55 20 	sts	0x2055, r23
    12ba:	0c c0       	rjmp	.+24     	; 0x12d4 <store_setting+0xa4>
    	case 7: settings.invert_mask = trunc(value); break;
    12bc:	cb 01       	movw	r24, r22
    12be:	ba 01       	movw	r22, r20
    12c0:	0e 94 0e 1d 	call	0x3a1c	; 0x3a1c <trunc>
    12c4:	0e 94 bf 19 	call	0x337e	; 0x337e <__fixunssfsi>
    12c8:	60 93 51 20 	sts	0x2051, r22
    12cc:	03 c0       	rjmp	.+6      	; 0x12d4 <store_setting+0xa4>
    	default: printPgmString(PSTR("Unknown parameter\r\n"));
    12ce:	87 e6       	ldi	r24, 0x67	; 103
    12d0:	92 e0       	ldi	r25, 0x02	; 2
    12d2:	04 c0       	rjmp	.+8      	; 0x12dc <store_setting+0xac>
    	return;
  	}
  	write_settings();
    12d4:	0e 94 0a 09 	call	0x1214	; 0x1214 <write_settings>
	printPgmString(PSTR("Stored new setting\r\n"));
    12d8:	82 e5       	ldi	r24, 0x52	; 82
    12da:	92 e0       	ldi	r25, 0x02	; 2
    12dc:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
    12e0:	08 95       	ret

000012e2 <read_settings>:
	printPgmString(PSTR(")\r\n\r\n'$x=value' to set parameter or just '$' to dump current settings\r\n"));
}

int read_settings() 
{
	uint8_t version = eeprom_get_char(0);	// Check version-byte of eeprom
    12e2:	80 e0       	ldi	r24, 0x00	; 0
    12e4:	90 e0       	ldi	r25, 0x00	; 0
    12e6:	0e 94 48 0a 	call	0x1490	; 0x1490 <eeprom_get_char>

	if (version != SETTINGS_VERSION) {		// Read settings-record and check checksum
    12ea:	84 36       	cpi	r24, 0x64	; 100
    12ec:	19 f0       	breq	.+6      	; 0x12f4 <read_settings+0x12>
    12ee:	20 e0       	ldi	r18, 0x00	; 0
    12f0:	30 e0       	ldi	r19, 0x00	; 0
    12f2:	0d c0       	rjmp	.+26     	; 0x130e <read_settings+0x2c>
		return(FALSE); 
	} 
  	if (!(memcpy_from_eeprom_with_checksum((char*)&settings, 1, sizeof(struct Settings)))) {
    12f4:	8b e3       	ldi	r24, 0x3B	; 59
    12f6:	90 e2       	ldi	r25, 0x20	; 32
    12f8:	61 e0       	ldi	r22, 0x01	; 1
    12fa:	70 e0       	ldi	r23, 0x00	; 0
    12fc:	4b e1       	ldi	r20, 0x1B	; 27
    12fe:	50 e0       	ldi	r21, 0x00	; 0
    1300:	0e 94 52 0a 	call	0x14a4	; 0x14a4 <memcpy_from_eeprom_with_checksum>
    1304:	00 97       	sbiw	r24, 0x00	; 0
    1306:	11 f0       	breq	.+4      	; 0x130c <read_settings+0x2a>
    1308:	81 e0       	ldi	r24, 0x01	; 1
    130a:	90 e0       	ldi	r25, 0x00	; 0
    130c:	9c 01       	movw	r18, r24
    	return(FALSE);
  	}
  	return(TRUE);
}
    130e:	c9 01       	movw	r24, r18
    1310:	08 95       	ret

00001312 <dump_settings>:
	settings.invert_mask = STEPPING_INVERT_MASK;
}

void dump_settings() 
{
	printPgmString(PSTR("$0 = ")); printFloat(settings.steps_per_mm[0]);
    1312:	86 ea       	ldi	r24, 0xA6	; 166
    1314:	93 e0       	ldi	r25, 0x03	; 3
    1316:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
    131a:	60 91 3b 20 	lds	r22, 0x203B
    131e:	70 91 3c 20 	lds	r23, 0x203C
    1322:	80 91 3d 20 	lds	r24, 0x203D
    1326:	90 91 3e 20 	lds	r25, 0x203E
    132a:	0e 94 f5 16 	call	0x2dea	; 0x2dea <printFloat>
	printPgmString(PSTR(" (steps/mm x)\r\n$1 = ")); printFloat(settings.steps_per_mm[1]);
    132e:	81 e9       	ldi	r24, 0x91	; 145
    1330:	93 e0       	ldi	r25, 0x03	; 3
    1332:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
    1336:	60 91 3f 20 	lds	r22, 0x203F
    133a:	70 91 40 20 	lds	r23, 0x2040
    133e:	80 91 41 20 	lds	r24, 0x2041
    1342:	90 91 42 20 	lds	r25, 0x2042
    1346:	0e 94 f5 16 	call	0x2dea	; 0x2dea <printFloat>
	printPgmString(PSTR(" (steps/mm y)\r\n$2 = ")); printFloat(settings.steps_per_mm[2]);
    134a:	8c e7       	ldi	r24, 0x7C	; 124
    134c:	93 e0       	ldi	r25, 0x03	; 3
    134e:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
    1352:	60 91 43 20 	lds	r22, 0x2043
    1356:	70 91 44 20 	lds	r23, 0x2044
    135a:	80 91 45 20 	lds	r24, 0x2045
    135e:	90 91 46 20 	lds	r25, 0x2046
    1362:	0e 94 f5 16 	call	0x2dea	; 0x2dea <printFloat>
	printPgmString(PSTR(" (steps/mm z)\r\n$3 = ")); printInteger(settings.pulse_microseconds);
    1366:	87 e6       	ldi	r24, 0x67	; 103
    1368:	93 e0       	ldi	r25, 0x03	; 3
    136a:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
    136e:	60 91 48 20 	lds	r22, 0x2048
    1372:	70 e0       	ldi	r23, 0x00	; 0
    1374:	80 e0       	ldi	r24, 0x00	; 0
    1376:	90 e0       	ldi	r25, 0x00	; 0
    1378:	0e 94 d3 16 	call	0x2da6	; 0x2da6 <printInteger>
	printPgmString(PSTR(" (microseconds step pulse)\r\n$4 = ")); printFloat(settings.default_feed_rate);
    137c:	85 e4       	ldi	r24, 0x45	; 69
    137e:	93 e0       	ldi	r25, 0x03	; 3
    1380:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
    1384:	60 91 49 20 	lds	r22, 0x2049
    1388:	70 91 4a 20 	lds	r23, 0x204A
    138c:	80 91 4b 20 	lds	r24, 0x204B
    1390:	90 91 4c 20 	lds	r25, 0x204C
    1394:	0e 94 f5 16 	call	0x2dea	; 0x2dea <printFloat>
	printPgmString(PSTR(" (mm/sec default feed rate)\r\n$5 = ")); printFloat(settings.default_seek_rate);
    1398:	82 e2       	ldi	r24, 0x22	; 34
    139a:	93 e0       	ldi	r25, 0x03	; 3
    139c:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
    13a0:	60 91 4d 20 	lds	r22, 0x204D
    13a4:	70 91 4e 20 	lds	r23, 0x204E
    13a8:	80 91 4f 20 	lds	r24, 0x204F
    13ac:	90 91 50 20 	lds	r25, 0x2050
    13b0:	0e 94 f5 16 	call	0x2dea	; 0x2dea <printFloat>
	printPgmString(PSTR(" (mm/sec default seek rate)\r\n$6 = ")); printFloat(settings.mm_per_arc_segment);
    13b4:	8f ef       	ldi	r24, 0xFF	; 255
    13b6:	92 e0       	ldi	r25, 0x02	; 2
    13b8:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
    13bc:	60 91 52 20 	lds	r22, 0x2052
    13c0:	70 91 53 20 	lds	r23, 0x2053
    13c4:	80 91 54 20 	lds	r24, 0x2054
    13c8:	90 91 55 20 	lds	r25, 0x2055
    13cc:	0e 94 f5 16 	call	0x2dea	; 0x2dea <printFloat>
	printPgmString(PSTR(" (mm/arc segment)\r\n$7 = ")); printInteger(settings.invert_mask); 
    13d0:	86 ee       	ldi	r24, 0xE6	; 230
    13d2:	92 e0       	ldi	r25, 0x02	; 2
    13d4:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
    13d8:	60 91 51 20 	lds	r22, 0x2051
    13dc:	70 e0       	ldi	r23, 0x00	; 0
    13de:	80 e0       	ldi	r24, 0x00	; 0
    13e0:	90 e0       	ldi	r25, 0x00	; 0
    13e2:	0e 94 d3 16 	call	0x2da6	; 0x2da6 <printInteger>
	printPgmString(PSTR(" (step port invert mask. binary = ")); printIntegerInBase(settings.invert_mask, 2);  
    13e6:	83 ec       	ldi	r24, 0xC3	; 195
    13e8:	92 e0       	ldi	r25, 0x02	; 2
    13ea:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
    13ee:	60 91 51 20 	lds	r22, 0x2051
    13f2:	70 e0       	ldi	r23, 0x00	; 0
    13f4:	80 e0       	ldi	r24, 0x00	; 0
    13f6:	90 e0       	ldi	r25, 0x00	; 0
    13f8:	22 e0       	ldi	r18, 0x02	; 2
    13fa:	30 e0       	ldi	r19, 0x00	; 0
    13fc:	40 e0       	ldi	r20, 0x00	; 0
    13fe:	50 e0       	ldi	r21, 0x00	; 0
    1400:	0e 94 4c 16 	call	0x2c98	; 0x2c98 <printIntegerInBase>
	printPgmString(PSTR(")\r\n\r\n'$x=value' to set parameter or just '$' to dump current settings\r\n"));
    1404:	8b e7       	ldi	r24, 0x7B	; 123
    1406:	92 e0       	ldi	r25, 0x02	; 2
    1408:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
}
    140c:	08 95       	ret

0000140e <config_init>:
	printPgmString(PSTR("Stored new setting\r\n"));
}

void config_init() 
{
	if(read_settings()) {
    140e:	0e 94 71 09 	call	0x12e2	; 0x12e2 <read_settings>
    1412:	89 2b       	or	r24, r25
    1414:	29 f0       	breq	.+10     	; 0x1420 <config_init+0x12>
    	printPgmString(PSTR("'$' to dump current settings\r\n"));
    1416:	83 e3       	ldi	r24, 0x33	; 51
    1418:	92 e0       	ldi	r25, 0x02	; 2
    141a:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
    141e:	08 95       	ret
	} else {
    	printPgmString(("EEPROM blank. Rewrote default settings:\r\n"));
    1420:	80 e0       	ldi	r24, 0x00	; 0
    1422:	90 e2       	ldi	r25, 0x20	; 32
    1424:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
    	reset_settings();
    1428:	0e 94 c4 08 	call	0x1188	; 0x1188 <reset_settings>
    	write_settings();
    142c:	0e 94 0a 09 	call	0x1214	; 0x1214 <write_settings>
    	dump_settings();
    1430:	0e 94 89 09 	call	0x1312	; 0x1312 <dump_settings>
    1434:	08 95       	ret

00001436 <EEPROM_ReadByte>:
 *  \param  byteAddr  EEPROM Byte address, between 0 and EEPROM_PAGESIZE.
 *
 *  \return  Byte value read from EEPROM.
 */
uint8_t EEPROM_ReadByte( uint8_t pageAddr, uint8_t byteAddr )
{
    1436:	98 2f       	mov	r25, r24
 */
void EEPROM_WaitForNVM( void )
{
	do {
		/* Block execution while waiting for the NVM to be ready. */
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    1438:	e0 ec       	ldi	r30, 0xC0	; 192
    143a:	f1 e0       	ldi	r31, 0x01	; 1
    143c:	80 91 cf 01 	lds	r24, 0x01CF
    1440:	87 fd       	sbrc	r24, 7
    1442:	fa cf       	rjmp	.-12     	; 0x1438 <EEPROM_ReadByte+0x2>
	/* Wait until NVM is not busy. */
	EEPROM_WaitForNVM();

	/* Calculate address */
	uint16_t address = (uint16_t)(pageAddr*EEPROM_PAGESIZE)
	                            |(byteAddr & (EEPROM_PAGESIZE-1));
    1444:	26 2f       	mov	r18, r22
    1446:	30 e0       	ldi	r19, 0x00	; 0
    1448:	2f 71       	andi	r18, 0x1F	; 31
    144a:	30 70       	andi	r19, 0x00	; 0
    144c:	89 2f       	mov	r24, r25
    144e:	90 e0       	ldi	r25, 0x00	; 0
    1450:	45 e0       	ldi	r20, 0x05	; 5
    1452:	88 0f       	add	r24, r24
    1454:	99 1f       	adc	r25, r25
    1456:	4a 95       	dec	r20
    1458:	e1 f7       	brne	.-8      	; 0x1452 <EEPROM_ReadByte+0x1c>
    145a:	28 2b       	or	r18, r24
    145c:	39 2b       	or	r19, r25

	/* Set address to read from. */
	NVM.ADDR0 = address & 0xFF;
    145e:	20 93 c0 01 	sts	0x01C0, r18
	NVM.ADDR1 = (address >> 8) & 0x1F;
    1462:	83 2f       	mov	r24, r19
    1464:	8f 71       	andi	r24, 0x1F	; 31
    1466:	81 83       	std	Z+1, r24	; 0x01
	NVM.ADDR2 = 0x00;
    1468:	12 82       	std	Z+2, r1	; 0x02

	/* Issue EEPROM Read command. */
	NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    146a:	86 e0       	ldi	r24, 0x06	; 6
    146c:	82 87       	std	Z+10, r24	; 0x0a
	NVM_EXEC();
    146e:	ef 93       	push	r30
    1470:	ff 93       	push	r31
    1472:	0f 93       	push	r16
    1474:	2f 93       	push	r18
    1476:	eb ec       	ldi	r30, 0xCB	; 203
    1478:	f1 e0       	ldi	r31, 0x01	; 1
    147a:	08 ed       	ldi	r16, 0xD8	; 216
    147c:	21 e0       	ldi	r18, 0x01	; 1
    147e:	04 bf       	out	0x34, r16	; 52
    1480:	20 83       	st	Z, r18
    1482:	2f 91       	pop	r18
    1484:	0f 91       	pop	r16
    1486:	ff 91       	pop	r31
    1488:	ef 91       	pop	r30

	return NVM.DATA0;
    148a:	80 91 c4 01 	lds	r24, 0x01C4
}
    148e:	08 95       	ret

00001490 <eeprom_get_char>:

char eeprom_get_char( unsigned int addr )
{
	uint8_t pageAddr = (uint8_t)(addr / EEPROM_PAGESIZE);
	uint8_t byteAddr = (uint8_t)(addr % EEPROM_PAGESIZE);
	return (EEPROM_ReadByte( pageAddr, byteAddr ));
    1490:	68 2f       	mov	r22, r24
    1492:	6f 71       	andi	r22, 0x1F	; 31
    1494:	55 e0       	ldi	r21, 0x05	; 5
    1496:	96 95       	lsr	r25
    1498:	87 95       	ror	r24
    149a:	5a 95       	dec	r21
    149c:	e1 f7       	brne	.-8      	; 0x1496 <eeprom_get_char+0x6>
    149e:	0e 94 1b 0a 	call	0x1436	; 0x1436 <EEPROM_ReadByte>
}
    14a2:	08 95       	ret

000014a4 <memcpy_from_eeprom_with_checksum>:
    eeprom_put_char(destination++, *(source++)); 
  }
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
    14a4:	8f 92       	push	r8
    14a6:	9f 92       	push	r9
    14a8:	af 92       	push	r10
    14aa:	bf 92       	push	r11
    14ac:	cf 92       	push	r12
    14ae:	df 92       	push	r13
    14b0:	ff 92       	push	r15
    14b2:	0f 93       	push	r16
    14b4:	1f 93       	push	r17
    14b6:	cf 93       	push	r28
    14b8:	df 93       	push	r29
    14ba:	4c 01       	movw	r8, r24
    14bc:	5b 01       	movw	r10, r22
    14be:	6a 01       	movw	r12, r20
    14c0:	8b 01       	movw	r16, r22
    14c2:	ea 01       	movw	r28, r20
    14c4:	ff 24       	eor	r15, r15
    14c6:	18 c0       	rjmp	.+48     	; 0x14f8 <memcpy_from_eeprom_with_checksum+0x54>
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    data = eeprom_get_char(source++);
    14c8:	c8 01       	movw	r24, r16
    14ca:	0e 94 48 0a 	call	0x1490	; 0x1490 <eeprom_get_char>
    checksum = (checksum << 1) || (checksum >> 7);
    14ce:	ff 20       	and	r15, r15
    14d0:	19 f0       	breq	.+6      	; 0x14d8 <memcpy_from_eeprom_with_checksum+0x34>
    14d2:	21 e0       	ldi	r18, 0x01	; 1
    14d4:	30 e0       	ldi	r19, 0x00	; 0
    14d6:	08 c0       	rjmp	.+16     	; 0x14e8 <memcpy_from_eeprom_with_checksum+0x44>
    14d8:	2f 2d       	mov	r18, r15
    14da:	33 27       	eor	r19, r19
    14dc:	27 fd       	sbrc	r18, 7
    14de:	30 95       	com	r19
    14e0:	22 27       	eor	r18, r18
    14e2:	33 0f       	add	r19, r19
    14e4:	22 1f       	adc	r18, r18
    14e6:	33 27       	eor	r19, r19
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    data = eeprom_get_char(source++);
    14e8:	0f 5f       	subi	r16, 0xFF	; 255
    14ea:	1f 4f       	sbci	r17, 0xFF	; 255
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += data;    
    14ec:	f8 2e       	mov	r15, r24
    14ee:	f2 0e       	add	r15, r18
    *(destination++) = data; 
    14f0:	f4 01       	movw	r30, r8
    14f2:	81 93       	st	Z+, r24
    14f4:	4f 01       	movw	r8, r30
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    14f6:	21 97       	sbiw	r28, 0x01	; 1
    14f8:	20 97       	sbiw	r28, 0x00	; 0
    14fa:	31 f7       	brne	.-52     	; 0x14c8 <memcpy_from_eeprom_with_checksum+0x24>
    data = eeprom_get_char(source++);
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += data;    
    *(destination++) = data; 
  }
  return(checksum == eeprom_get_char(source));
    14fc:	c6 01       	movw	r24, r12
    14fe:	8a 0d       	add	r24, r10
    1500:	9b 1d       	adc	r25, r11
    1502:	0e 94 48 0a 	call	0x1490	; 0x1490 <eeprom_get_char>
    1506:	20 e0       	ldi	r18, 0x00	; 0
    1508:	30 e0       	ldi	r19, 0x00	; 0
    150a:	f8 16       	cp	r15, r24
    150c:	11 f4       	brne	.+4      	; 0x1512 <memcpy_from_eeprom_with_checksum+0x6e>
    150e:	21 e0       	ldi	r18, 0x01	; 1
    1510:	30 e0       	ldi	r19, 0x00	; 0
}
    1512:	c9 01       	movw	r24, r18
    1514:	df 91       	pop	r29
    1516:	cf 91       	pop	r28
    1518:	1f 91       	pop	r17
    151a:	0f 91       	pop	r16
    151c:	ff 90       	pop	r15
    151e:	df 90       	pop	r13
    1520:	cf 90       	pop	r12
    1522:	bf 90       	pop	r11
    1524:	af 90       	pop	r10
    1526:	9f 90       	pop	r9
    1528:	8f 90       	pop	r8
    152a:	08 95       	ret

0000152c <EEPROM_WaitForNVM>:
 */
void EEPROM_WaitForNVM( void )
{
	do {
		/* Block execution while waiting for the NVM to be ready. */
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    152c:	80 91 cf 01 	lds	r24, 0x01CF
    1530:	87 fd       	sbrc	r24, 7
    1532:	fc cf       	rjmp	.-8      	; 0x152c <EEPROM_WaitForNVM>
}
    1534:	08 95       	ret

00001536 <EEPROM_FlushBuffer>:
 */
void EEPROM_WaitForNVM( void )
{
	do {
		/* Block execution while waiting for the NVM to be ready. */
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    1536:	80 91 cf 01 	lds	r24, 0x01CF
    153a:	87 fd       	sbrc	r24, 7
    153c:	fc cf       	rjmp	.-8      	; 0x1536 <EEPROM_FlushBuffer>
{
	/* Wait until NVM is not busy. */
	EEPROM_WaitForNVM();

	/* Flush EEPROM page buffer if necessary. */
	if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    153e:	80 91 cf 01 	lds	r24, 0x01CF
    1542:	81 ff       	sbrs	r24, 1
    1544:	12 c0       	rjmp	.+36     	; 0x156a <EEPROM_FlushBuffer+0x34>
		NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    1546:	86 e3       	ldi	r24, 0x36	; 54
    1548:	e0 ec       	ldi	r30, 0xC0	; 192
    154a:	f1 e0       	ldi	r31, 0x01	; 1
    154c:	82 87       	std	Z+10, r24	; 0x0a
		NVM_EXEC();
    154e:	ef 93       	push	r30
    1550:	ff 93       	push	r31
    1552:	0f 93       	push	r16
    1554:	2f 93       	push	r18
    1556:	eb ec       	ldi	r30, 0xCB	; 203
    1558:	f1 e0       	ldi	r31, 0x01	; 1
    155a:	08 ed       	ldi	r16, 0xD8	; 216
    155c:	21 e0       	ldi	r18, 0x01	; 1
    155e:	04 bf       	out	0x34, r16	; 52
    1560:	20 83       	st	Z, r18
    1562:	2f 91       	pop	r18
    1564:	0f 91       	pop	r16
    1566:	ff 91       	pop	r31
    1568:	ef 91       	pop	r30
    156a:	08 95       	ret

0000156c <EEPROM_WriteByte>:
 *  \param  pageAddr  EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGESIZE
 *  \param  byteAddr  EEPROM Byte address, between 0 and EEPROM_PAGESIZE.
 *  \param  value     Byte value to write to EEPROM.
 */
void EEPROM_WriteByte( uint8_t pageAddr, uint8_t byteAddr, uint8_t value )
{
    156c:	df 92       	push	r13
    156e:	ef 92       	push	r14
    1570:	ff 92       	push	r15
    1572:	0f 93       	push	r16
    1574:	1f 93       	push	r17
    1576:	e8 2e       	mov	r14, r24
    1578:	06 2f       	mov	r16, r22
    157a:	d4 2e       	mov	r13, r20
	/*  Flush buffer to make sure no unintetional data is written and load
	 *  the "Page Load" command into the command register.
	 */
	EEPROM_FlushBuffer();
    157c:	0e 94 9b 0a 	call	0x1536	; 0x1536 <EEPROM_FlushBuffer>
	NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    1580:	e0 ec       	ldi	r30, 0xC0	; 192
    1582:	f1 e0       	ldi	r31, 0x01	; 1
    1584:	83 e3       	ldi	r24, 0x33	; 51
    1586:	82 87       	std	Z+10, r24	; 0x0a

	/* Calculate address */
	uint16_t address = (uint16_t)(pageAddr*EEPROM_PAGESIZE)|(byteAddr & (EEPROM_PAGESIZE-1));
    1588:	10 e0       	ldi	r17, 0x00	; 0
    158a:	0f 71       	andi	r16, 0x1F	; 31
    158c:	10 70       	andi	r17, 0x00	; 0
    158e:	ff 24       	eor	r15, r15
    1590:	75 e0       	ldi	r23, 0x05	; 5
    1592:	ee 0c       	add	r14, r14
    1594:	ff 1c       	adc	r15, r15
    1596:	7a 95       	dec	r23
    1598:	e1 f7       	brne	.-8      	; 0x1592 <EEPROM_WriteByte+0x26>
    159a:	0e 29       	or	r16, r14
    159c:	1f 29       	or	r17, r15

	/* Set address to write to. */
	NVM.ADDR0 = address & 0xFF;
    159e:	00 83       	st	Z, r16
	NVM.ADDR1 = (address >> 8) & 0x1F;
    15a0:	81 2f       	mov	r24, r17
    15a2:	8f 71       	andi	r24, 0x1F	; 31
    15a4:	81 83       	std	Z+1, r24	; 0x01
	NVM.ADDR2 = 0x00;
    15a6:	12 82       	std	Z+2, r1	; 0x02

	/* Load data to write, which triggers the loading of EEPROM page buffer. */
	NVM.DATA0 = value;
    15a8:	d4 82       	std	Z+4, r13	; 0x04

	/*  Issue EEPROM Atomic Write (Erase&Write) command. Load command, write
	 *  the protection signature and execute command.
	 */
	NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    15aa:	85 e3       	ldi	r24, 0x35	; 53
    15ac:	82 87       	std	Z+10, r24	; 0x0a
	NVM_EXEC();
    15ae:	ef 93       	push	r30
    15b0:	ff 93       	push	r31
    15b2:	0f 93       	push	r16
    15b4:	2f 93       	push	r18
    15b6:	eb ec       	ldi	r30, 0xCB	; 203
    15b8:	f1 e0       	ldi	r31, 0x01	; 1
    15ba:	08 ed       	ldi	r16, 0xD8	; 216
    15bc:	21 e0       	ldi	r18, 0x01	; 1
    15be:	04 bf       	out	0x34, r16	; 52
    15c0:	20 83       	st	Z, r18
    15c2:	2f 91       	pop	r18
    15c4:	0f 91       	pop	r16
    15c6:	ff 91       	pop	r31
    15c8:	ef 91       	pop	r30
}
    15ca:	1f 91       	pop	r17
    15cc:	0f 91       	pop	r16
    15ce:	ff 90       	pop	r15
    15d0:	ef 90       	pop	r14
    15d2:	df 90       	pop	r13
    15d4:	08 95       	ret

000015d6 <eeprom_put_char>:
	uint8_t byteAddr = (uint8_t)(addr % EEPROM_PAGESIZE);
	return (EEPROM_ReadByte( pageAddr, byteAddr ));
}

void eeprom_put_char( unsigned int addr, char value )
{
    15d6:	46 2f       	mov	r20, r22
	uint8_t pageAddr = (uint8_t)(addr / EEPROM_PAGESIZE);
	uint8_t byteAddr = (uint8_t)(addr % EEPROM_PAGESIZE);

	EEPROM_WriteByte(pageAddr, byteAddr, value );
    15d8:	68 2f       	mov	r22, r24
    15da:	6f 71       	andi	r22, 0x1F	; 31
    15dc:	e5 e0       	ldi	r30, 0x05	; 5
    15de:	96 95       	lsr	r25
    15e0:	87 95       	ror	r24
    15e2:	ea 95       	dec	r30
    15e4:	e1 f7       	brne	.-8      	; 0x15de <eeprom_put_char+0x8>
    15e6:	0e 94 b6 0a 	call	0x156c	; 0x156c <EEPROM_WriteByte>
}
    15ea:	08 95       	ret

000015ec <memcpy_to_eeprom_with_checksum>:

void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
    15ec:	8f 92       	push	r8
    15ee:	9f 92       	push	r9
    15f0:	af 92       	push	r10
    15f2:	bf 92       	push	r11
    15f4:	cf 92       	push	r12
    15f6:	df 92       	push	r13
    15f8:	ef 92       	push	r14
    15fa:	ff 92       	push	r15
    15fc:	0f 93       	push	r16
    15fe:	df 93       	push	r29
    1600:	cf 93       	push	r28
    1602:	0f 92       	push	r0
    1604:	0f 92       	push	r0
    1606:	cd b7       	in	r28, 0x3d	; 61
    1608:	de b7       	in	r29, 0x3e	; 62
    160a:	5c 01       	movw	r10, r24
    160c:	6b 01       	movw	r12, r22
    160e:	7a 01       	movw	r14, r20
    1610:	4a 01       	movw	r8, r20
    1612:	00 e0       	ldi	r16, 0x00	; 0
    1614:	1e c0       	rjmp	.+60     	; 0x1652 <memcpy_to_eeprom_with_checksum+0x66>
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    checksum = (checksum << 1) || (checksum >> 7);
    1616:	00 23       	and	r16, r16
    1618:	19 f0       	breq	.+6      	; 0x1620 <memcpy_to_eeprom_with_checksum+0x34>
    161a:	21 e0       	ldi	r18, 0x01	; 1
    161c:	30 e0       	ldi	r19, 0x00	; 0
    161e:	08 c0       	rjmp	.+16     	; 0x1630 <memcpy_to_eeprom_with_checksum+0x44>
    1620:	20 2f       	mov	r18, r16
    1622:	33 27       	eor	r19, r19
    1624:	27 fd       	sbrc	r18, 7
    1626:	30 95       	com	r19
    1628:	22 27       	eor	r18, r18
    162a:	33 0f       	add	r19, r19
    162c:	22 1f       	adc	r18, r18
    162e:	33 27       	eor	r19, r19
    checksum += *source;
    1630:	f6 01       	movw	r30, r12
    1632:	61 91       	ld	r22, Z+
    1634:	6f 01       	movw	r12, r30
    1636:	06 2f       	mov	r16, r22
    1638:	02 0f       	add	r16, r18
    eeprom_put_char(destination++, *(source++)); 
    163a:	9c 01       	movw	r18, r24
    163c:	2f 5f       	subi	r18, 0xFF	; 255
    163e:	3f 4f       	sbci	r19, 0xFF	; 255
    1640:	29 83       	std	Y+1, r18	; 0x01
    1642:	3a 83       	std	Y+2, r19	; 0x02
    1644:	0e 94 eb 0a 	call	0x15d6	; 0x15d6 <eeprom_put_char>
	EEPROM_WriteByte(pageAddr, byteAddr, value );
}

void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    1648:	08 94       	sec
    164a:	81 08       	sbc	r8, r1
    164c:	91 08       	sbc	r9, r1
    164e:	89 81       	ldd	r24, Y+1	; 0x01
    1650:	9a 81       	ldd	r25, Y+2	; 0x02
    1652:	81 14       	cp	r8, r1
    1654:	91 04       	cpc	r9, r1
    1656:	f9 f6       	brne	.-66     	; 0x1616 <memcpy_to_eeprom_with_checksum+0x2a>
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += *source;
    eeprom_put_char(destination++, *(source++)); 
  }
  eeprom_put_char(destination, checksum);
    1658:	c7 01       	movw	r24, r14
    165a:	8a 0d       	add	r24, r10
    165c:	9b 1d       	adc	r25, r11
    165e:	60 2f       	mov	r22, r16
    1660:	0e 94 eb 0a 	call	0x15d6	; 0x15d6 <eeprom_put_char>
}
    1664:	0f 90       	pop	r0
    1666:	0f 90       	pop	r0
    1668:	cf 91       	pop	r28
    166a:	df 91       	pop	r29
    166c:	0f 91       	pop	r16
    166e:	ff 90       	pop	r15
    1670:	ef 90       	pop	r14
    1672:	df 90       	pop	r13
    1674:	cf 90       	pop	r12
    1676:	bf 90       	pop	r11
    1678:	af 90       	pop	r10
    167a:	9f 90       	pop	r9
    167c:	8f 90       	pop	r8
    167e:	08 95       	ret

00001680 <EEPROM_LoadByte>:
 *
 *  \param  byteAddr  EEPROM Byte address, between 0 and EEPROM_PAGESIZE.
 *  \param  value     Byte value to write to buffer.
 */
void EEPROM_LoadByte( uint8_t byteAddr, uint8_t value )
{
    1680:	98 2f       	mov	r25, r24
 */
void EEPROM_WaitForNVM( void )
{
	do {
		/* Block execution while waiting for the NVM to be ready. */
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    1682:	e0 ec       	ldi	r30, 0xC0	; 192
    1684:	f1 e0       	ldi	r31, 0x01	; 1
    1686:	80 91 cf 01 	lds	r24, 0x01CF
    168a:	87 fd       	sbrc	r24, 7
    168c:	fa cf       	rjmp	.-12     	; 0x1682 <EEPROM_LoadByte+0x2>
 */
void EEPROM_LoadByte( uint8_t byteAddr, uint8_t value )
{
	/* Wait until NVM is not busy and prepare NVM command.*/
	EEPROM_WaitForNVM();
	NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    168e:	83 e3       	ldi	r24, 0x33	; 51
    1690:	82 87       	std	Z+10, r24	; 0x0a

	/* Set address. */
	NVM.ADDR0 = byteAddr & 0xFF;
    1692:	90 93 c0 01 	sts	0x01C0, r25
	NVM.ADDR1 = 0x00;
    1696:	11 82       	std	Z+1, r1	; 0x01
	NVM.ADDR2 = 0x00;
    1698:	12 82       	std	Z+2, r1	; 0x02

	/* Set data, which triggers loading of EEPROM page buffer. */
	NVM.DATA0 = value;
    169a:	64 83       	std	Z+4, r22	; 0x04
}
    169c:	08 95       	ret

0000169e <EEPROM_LoadPage>:
 *        EEPROM write page operation.
 *
 *  \param  values   Pointer to SRAM buffer containing an entire page.
 */
void EEPROM_LoadPage( const uint8_t * values )
{
    169e:	dc 01       	movw	r26, r24
 */
void EEPROM_WaitForNVM( void )
{
	do {
		/* Block execution while waiting for the NVM to be ready. */
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    16a0:	e0 ec       	ldi	r30, 0xC0	; 192
    16a2:	f1 e0       	ldi	r31, 0x01	; 1
    16a4:	80 91 cf 01 	lds	r24, 0x01CF
    16a8:	87 fd       	sbrc	r24, 7
    16aa:	fa cf       	rjmp	.-12     	; 0x16a0 <EEPROM_LoadPage+0x2>
 */
void EEPROM_LoadPage( const uint8_t * values )
{
	/* Wait until NVM is not busy. */
	EEPROM_WaitForNVM();
	NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    16ac:	83 e3       	ldi	r24, 0x33	; 51
    16ae:	82 87       	std	Z+10, r24	; 0x0a

	/*  Set address to zero, as only the lower bits matters. ADDR0 is
	 *  maintained inside the loop below.
	 */
	NVM.ADDR1 = 0x00;
    16b0:	11 82       	std	Z+1, r1	; 0x01
	NVM.ADDR2 = 0x00;
    16b2:	12 82       	std	Z+2, r1	; 0x02
    16b4:	90 e0       	ldi	r25, 0x00	; 0

	/* Load multible bytes into page buffer. */
	for (uint8_t i = 0; i < EEPROM_PAGESIZE; ++i) {
		NVM.ADDR0 = i;
    16b6:	90 93 c0 01 	sts	0x01C0, r25
		NVM.DATA0 = *values;
    16ba:	8d 91       	ld	r24, X+
    16bc:	84 83       	std	Z+4, r24	; 0x04
	 */
	NVM.ADDR1 = 0x00;
	NVM.ADDR2 = 0x00;

	/* Load multible bytes into page buffer. */
	for (uint8_t i = 0; i < EEPROM_PAGESIZE; ++i) {
    16be:	9f 5f       	subi	r25, 0xFF	; 255
    16c0:	90 32       	cpi	r25, 0x20	; 32
    16c2:	c9 f7       	brne	.-14     	; 0x16b6 <EEPROM_LoadPage+0x18>
		NVM.ADDR0 = i;
		NVM.DATA0 = *values;
		++values;
	}
}
    16c4:	08 95       	ret

000016c6 <EEPROM_AtomicWritePage>:
 *  locations that have not been loaded will be left untouched in EEPROM.
 *
 *  \param  pageAddr  EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGESIZE
 */
void EEPROM_AtomicWritePage( uint8_t pageAddr )
{
    16c6:	98 2f       	mov	r25, r24
 */
void EEPROM_WaitForNVM( void )
{
	do {
		/* Block execution while waiting for the NVM to be ready. */
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    16c8:	e0 ec       	ldi	r30, 0xC0	; 192
    16ca:	f1 e0       	ldi	r31, 0x01	; 1
    16cc:	80 91 cf 01 	lds	r24, 0x01CF
    16d0:	87 fd       	sbrc	r24, 7
    16d2:	fa cf       	rjmp	.-12     	; 0x16c8 <EEPROM_AtomicWritePage+0x2>
{
	/* Wait until NVM is not busy. */
	EEPROM_WaitForNVM();

	/* Calculate page address */
	uint16_t address = (uint16_t)(pageAddr*EEPROM_PAGESIZE);
    16d4:	89 2f       	mov	r24, r25
    16d6:	90 e0       	ldi	r25, 0x00	; 0
    16d8:	a5 e0       	ldi	r26, 0x05	; 5
    16da:	88 0f       	add	r24, r24
    16dc:	99 1f       	adc	r25, r25
    16de:	aa 95       	dec	r26
    16e0:	e1 f7       	brne	.-8      	; 0x16da <EEPROM_AtomicWritePage+0x14>

	/* Set address. */
	NVM.ADDR0 = address & 0xFF;
    16e2:	80 93 c0 01 	sts	0x01C0, r24
	NVM.ADDR1 = (address >> 8) & 0x1F;
    16e6:	89 2f       	mov	r24, r25
    16e8:	8f 71       	andi	r24, 0x1F	; 31
    16ea:	81 83       	std	Z+1, r24	; 0x01
	NVM.ADDR2 = 0x00;
    16ec:	12 82       	std	Z+2, r1	; 0x02

	/* Issue EEPROM Atomic Write (Erase&Write) command. */
	NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    16ee:	85 e3       	ldi	r24, 0x35	; 53
    16f0:	82 87       	std	Z+10, r24	; 0x0a
	NVM_EXEC();
    16f2:	ef 93       	push	r30
    16f4:	ff 93       	push	r31
    16f6:	0f 93       	push	r16
    16f8:	2f 93       	push	r18
    16fa:	eb ec       	ldi	r30, 0xCB	; 203
    16fc:	f1 e0       	ldi	r31, 0x01	; 1
    16fe:	08 ed       	ldi	r16, 0xD8	; 216
    1700:	21 e0       	ldi	r18, 0x01	; 1
    1702:	04 bf       	out	0x34, r16	; 52
    1704:	20 83       	st	Z, r18
    1706:	2f 91       	pop	r18
    1708:	0f 91       	pop	r16
    170a:	ff 91       	pop	r31
    170c:	ef 91       	pop	r30
}
    170e:	08 95       	ret

00001710 <EEPROM_ErasePage>:
 *  This function erases one EEPROM page, so that every location reads 0xFF.
 *
 *  \param  pageAddr  EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGESIZE
 */
void EEPROM_ErasePage( uint8_t pageAddr )
{
    1710:	98 2f       	mov	r25, r24
 */
void EEPROM_WaitForNVM( void )
{
	do {
		/* Block execution while waiting for the NVM to be ready. */
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    1712:	e0 ec       	ldi	r30, 0xC0	; 192
    1714:	f1 e0       	ldi	r31, 0x01	; 1
    1716:	80 91 cf 01 	lds	r24, 0x01CF
    171a:	87 fd       	sbrc	r24, 7
    171c:	fa cf       	rjmp	.-12     	; 0x1712 <EEPROM_ErasePage+0x2>
{
	/* Wait until NVM is not busy. */
	EEPROM_WaitForNVM();

	/* Calculate page address */
	uint16_t address = (uint16_t)(pageAddr*EEPROM_PAGESIZE);
    171e:	89 2f       	mov	r24, r25
    1720:	90 e0       	ldi	r25, 0x00	; 0
    1722:	b5 e0       	ldi	r27, 0x05	; 5
    1724:	88 0f       	add	r24, r24
    1726:	99 1f       	adc	r25, r25
    1728:	ba 95       	dec	r27
    172a:	e1 f7       	brne	.-8      	; 0x1724 <EEPROM_ErasePage+0x14>

	/* Set address. */
	NVM.ADDR0 = address & 0xFF;
    172c:	80 93 c0 01 	sts	0x01C0, r24
	NVM.ADDR1 = (address >> 8) & 0x1F;
    1730:	89 2f       	mov	r24, r25
    1732:	8f 71       	andi	r24, 0x1F	; 31
    1734:	81 83       	std	Z+1, r24	; 0x01
	NVM.ADDR2 = 0x00;
    1736:	12 82       	std	Z+2, r1	; 0x02

	/* Issue EEPROM Erase command. */
	NVM.CMD = NVM_CMD_ERASE_EEPROM_PAGE_gc;
    1738:	82 e3       	ldi	r24, 0x32	; 50
    173a:	82 87       	std	Z+10, r24	; 0x0a
	NVM_EXEC();
    173c:	ef 93       	push	r30
    173e:	ff 93       	push	r31
    1740:	0f 93       	push	r16
    1742:	2f 93       	push	r18
    1744:	eb ec       	ldi	r30, 0xCB	; 203
    1746:	f1 e0       	ldi	r31, 0x01	; 1
    1748:	08 ed       	ldi	r16, 0xD8	; 216
    174a:	21 e0       	ldi	r18, 0x01	; 1
    174c:	04 bf       	out	0x34, r16	; 52
    174e:	20 83       	st	Z, r18
    1750:	2f 91       	pop	r18
    1752:	0f 91       	pop	r16
    1754:	ff 91       	pop	r31
    1756:	ef 91       	pop	r30
}
    1758:	08 95       	ret

0000175a <EEPROM_SplitWritePage>:
 *  before writing.
 *
 *  \param  pageAddr  EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGESIZE
 */
void EEPROM_SplitWritePage( uint8_t pageAddr )
{
    175a:	98 2f       	mov	r25, r24
 */
void EEPROM_WaitForNVM( void )
{
	do {
		/* Block execution while waiting for the NVM to be ready. */
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    175c:	e0 ec       	ldi	r30, 0xC0	; 192
    175e:	f1 e0       	ldi	r31, 0x01	; 1
    1760:	80 91 cf 01 	lds	r24, 0x01CF
    1764:	87 fd       	sbrc	r24, 7
    1766:	fa cf       	rjmp	.-12     	; 0x175c <EEPROM_SplitWritePage+0x2>
{
	/* Wait until NVM is not busy. */
	EEPROM_WaitForNVM();

	/* Calculate page address */
	uint16_t address = (uint16_t)(pageAddr*EEPROM_PAGESIZE);
    1768:	89 2f       	mov	r24, r25
    176a:	90 e0       	ldi	r25, 0x00	; 0
    176c:	25 e0       	ldi	r18, 0x05	; 5
    176e:	88 0f       	add	r24, r24
    1770:	99 1f       	adc	r25, r25
    1772:	2a 95       	dec	r18
    1774:	e1 f7       	brne	.-8      	; 0x176e <EEPROM_SplitWritePage+0x14>

	/* Set address. */
	NVM.ADDR0 = address & 0xFF;
    1776:	80 93 c0 01 	sts	0x01C0, r24
	NVM.ADDR1 = (address >> 8) & 0x1F;
    177a:	89 2f       	mov	r24, r25
    177c:	8f 71       	andi	r24, 0x1F	; 31
    177e:	81 83       	std	Z+1, r24	; 0x01
	NVM.ADDR2 = 0x00;
    1780:	12 82       	std	Z+2, r1	; 0x02

	/* Issue EEPROM Split Write command. */
	NVM.CMD = NVM_CMD_WRITE_EEPROM_PAGE_gc;
    1782:	84 e3       	ldi	r24, 0x34	; 52
    1784:	82 87       	std	Z+10, r24	; 0x0a
	NVM_EXEC();
    1786:	ef 93       	push	r30
    1788:	ff 93       	push	r31
    178a:	0f 93       	push	r16
    178c:	2f 93       	push	r18
    178e:	eb ec       	ldi	r30, 0xCB	; 203
    1790:	f1 e0       	ldi	r31, 0x01	; 1
    1792:	08 ed       	ldi	r16, 0xD8	; 216
    1794:	21 e0       	ldi	r18, 0x01	; 1
    1796:	04 bf       	out	0x34, r16	; 52
    1798:	20 83       	st	Z, r18
    179a:	2f 91       	pop	r18
    179c:	0f 91       	pop	r16
    179e:	ff 91       	pop	r31
    17a0:	ef 91       	pop	r30
}
    17a2:	08 95       	ret

000017a4 <EEPROM_EraseAll>:
 */
void EEPROM_WaitForNVM( void )
{
	do {
		/* Block execution while waiting for the NVM to be ready. */
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    17a4:	80 91 cf 01 	lds	r24, 0x01CF
    17a8:	87 fd       	sbrc	r24, 7
    17aa:	fc cf       	rjmp	.-8      	; 0x17a4 <EEPROM_EraseAll>
{
	/* Wait until NVM is not busy. */
	EEPROM_WaitForNVM();

	/* Issue EEPROM Erase All command. */
	NVM.CMD = NVM_CMD_ERASE_EEPROM_gc;
    17ac:	80 e3       	ldi	r24, 0x30	; 48
    17ae:	e0 ec       	ldi	r30, 0xC0	; 192
    17b0:	f1 e0       	ldi	r31, 0x01	; 1
    17b2:	82 87       	std	Z+10, r24	; 0x0a
	NVM_EXEC();
    17b4:	ef 93       	push	r30
    17b6:	ff 93       	push	r31
    17b8:	0f 93       	push	r16
    17ba:	2f 93       	push	r18
    17bc:	eb ec       	ldi	r30, 0xCB	; 203
    17be:	f1 e0       	ldi	r31, 0x01	; 1
    17c0:	08 ed       	ldi	r16, 0xD8	; 216
    17c2:	21 e0       	ldi	r18, 0x01	; 1
    17c4:	04 bf       	out	0x34, r16	; 52
    17c6:	20 83       	st	Z, r18
    17c8:	2f 91       	pop	r18
    17ca:	0f 91       	pop	r16
    17cc:	ff 91       	pop	r31
    17ce:	ef 91       	pop	r30
}
    17d0:	08 95       	ret

000017d2 <en_init>:

#include "encoder.h"

void en_init(void) {

}
    17d2:	08 95       	ret

000017d4 <config32MHzClock>:


/* Configure 32 MHz clock (xmega) */
void config32MHzClock(void) 
{
	CCP = CCP_IOREG_gc; 					// Security Signature to modify clk 
    17d4:	88 ed       	ldi	r24, 0xD8	; 216
    17d6:	84 bf       	out	0x34, r24	; 52

	// initialize clock source to be 32MHz internal oscillator (no PLL)
	OSC.CTRL = OSC_RC32MEN_bm; 				// enable internal 32MHz oscillator
    17d8:	82 e0       	ldi	r24, 0x02	; 2
    17da:	80 93 50 00 	sts	0x0050, r24
	while(!(OSC.STATUS & OSC_RC32MRDY_bm)); // wait for oscillator ready
    17de:	80 91 51 00 	lds	r24, 0x0051
    17e2:	81 ff       	sbrs	r24, 1
    17e4:	fc cf       	rjmp	.-8      	; 0x17de <config32MHzClock+0xa>
	CCP = CCP_IOREG_gc; 					// Security Signature to modify clk
    17e6:	88 ed       	ldi	r24, 0xD8	; 216
    17e8:	84 bf       	out	0x34, r24	; 52
	CLK.CTRL = 0x01; 						// select sysclock 32MHz osc
    17ea:	81 e0       	ldi	r24, 0x01	; 1
    17ec:	80 93 40 00 	sts	0x0040, r24
};
    17f0:	08 95       	ret

000017f2 <xmega_init>:

#include <avr/io.h>
#include "xmega_support.h"

void xmega_init(void) {
	config32MHzClock();						// set system clock to 32 MHz
    17f2:	0e 94 ea 0b 	call	0x17d4	; 0x17d4 <config32MHzClock>
}
    17f6:	08 95       	ret

000017f8 <mc_go_home>:
  	}
}

void mc_go_home()
{
	st_go_home();
    17f8:	0e 94 ca 12 	call	0x2594	; 0x2594 <st_go_home>
	clear_vector(position); // By definition this is location [0, 0, 0]
    17fc:	8c e0       	ldi	r24, 0x0C	; 12
    17fe:	e8 e7       	ldi	r30, 0x78	; 120
    1800:	f0 e2       	ldi	r31, 0x20	; 32
    1802:	df 01       	movw	r26, r30
    1804:	1d 92       	st	X+, r1
    1806:	8a 95       	dec	r24
    1808:	e9 f7       	brne	.-6      	; 0x1804 <mc_go_home+0xc>
}
    180a:	08 95       	ret

0000180c <mc_init>:

/* mc_init() */

void mc_init()
{
	clear_vector(position);
    180c:	8c e0       	ldi	r24, 0x0C	; 12
    180e:	e8 e7       	ldi	r30, 0x78	; 120
    1810:	f0 e2       	ldi	r31, 0x20	; 32
    1812:	df 01       	movw	r26, r30
    1814:	1d 92       	st	X+, r1
    1816:	8a 95       	dec	r24
    1818:	e9 f7       	brne	.-6      	; 0x1814 <mc_init+0x8>
}
    181a:	08 95       	ret

0000181c <mc_line>:
	Feed rate given in millimeters/second unless invert_feed_rate is true. 
	Then the feed_rate means that the motion should be completed in 1/feed_rate minutes.
 */

void mc_line(double x, double y, double z, float feed_rate, int invert_feed_rate)
{
    181c:	2f 92       	push	r2
    181e:	3f 92       	push	r3
    1820:	4f 92       	push	r4
    1822:	5f 92       	push	r5
    1824:	6f 92       	push	r6
    1826:	7f 92       	push	r7
    1828:	8f 92       	push	r8
    182a:	9f 92       	push	r9
    182c:	af 92       	push	r10
    182e:	bf 92       	push	r11
    1830:	cf 92       	push	r12
    1832:	df 92       	push	r13
    1834:	ef 92       	push	r14
    1836:	ff 92       	push	r15
    1838:	0f 93       	push	r16
    183a:	1f 93       	push	r17
    183c:	df 93       	push	r29
    183e:	cf 93       	push	r28
    1840:	cd b7       	in	r28, 0x3d	; 61
    1842:	de b7       	in	r29, 0x3e	; 62
    1844:	a8 97       	sbiw	r28, 0x28	; 40
    1846:	cd bf       	out	0x3d, r28	; 61
    1848:	de bf       	out	0x3e, r29	; 62
    184a:	29 a3       	std	Y+33, r18	; 0x21
    184c:	3a a3       	std	Y+34, r19	; 0x22
    184e:	4b a3       	std	Y+35, r20	; 0x23
    1850:	5c a3       	std	Y+36, r21	; 0x24
    1852:	ad a2       	std	Y+37, r10	; 0x25
    1854:	be a2       	std	Y+38, r11	; 0x26
    1856:	cf a2       	std	Y+39, r12	; 0x27
    1858:	d8 a6       	std	Y+40, r13	; 0x28
	uint8_t axis; 					// loop variable
	int32_t target[3];				// target position in absolute steps
	int32_t steps[3];				// target line in relative steps
	double millimeters_of_travel;	// 
		
	target[X_AXIS] = lround(x*settings.steps_per_mm[0]);
    185a:	20 91 3b 20 	lds	r18, 0x203B
    185e:	30 91 3c 20 	lds	r19, 0x203C
    1862:	40 91 3d 20 	lds	r20, 0x203D
    1866:	50 91 3e 20 	lds	r21, 0x203E
    186a:	2d 8f       	std	Y+29, r18	; 0x1d
    186c:	3e 8f       	std	Y+30, r19	; 0x1e
    186e:	4f 8f       	std	Y+31, r20	; 0x1f
    1870:	58 a3       	std	Y+32, r21	; 0x20
    1872:	0e 94 40 1c 	call	0x3880	; 0x3880 <__mulsf3>
    1876:	0e 94 dd 1b 	call	0x37ba	; 0x37ba <lround>
    187a:	2b 01       	movw	r4, r22
    187c:	3c 01       	movw	r6, r24
    187e:	49 82       	std	Y+1, r4	; 0x01
    1880:	5a 82       	std	Y+2, r5	; 0x02
    1882:	6b 82       	std	Y+3, r6	; 0x03
    1884:	7c 82       	std	Y+4, r7	; 0x04
	target[Y_AXIS] = lround(y*settings.steps_per_mm[1]);
    1886:	80 91 3f 20 	lds	r24, 0x203F
    188a:	90 91 40 20 	lds	r25, 0x2040
    188e:	a0 91 41 20 	lds	r26, 0x2041
    1892:	b0 91 42 20 	lds	r27, 0x2042
    1896:	89 8f       	std	Y+25, r24	; 0x19
    1898:	9a 8f       	std	Y+26, r25	; 0x1a
    189a:	ab 8f       	std	Y+27, r26	; 0x1b
    189c:	bc 8f       	std	Y+28, r27	; 0x1c
    189e:	69 a1       	ldd	r22, Y+33	; 0x21
    18a0:	7a a1       	ldd	r23, Y+34	; 0x22
    18a2:	8b a1       	ldd	r24, Y+35	; 0x23
    18a4:	9c a1       	ldd	r25, Y+36	; 0x24
    18a6:	29 8d       	ldd	r18, Y+25	; 0x19
    18a8:	3a 8d       	ldd	r19, Y+26	; 0x1a
    18aa:	4b 8d       	ldd	r20, Y+27	; 0x1b
    18ac:	5c 8d       	ldd	r21, Y+28	; 0x1c
    18ae:	0e 94 40 1c 	call	0x3880	; 0x3880 <__mulsf3>
    18b2:	0e 94 dd 1b 	call	0x37ba	; 0x37ba <lround>
    18b6:	5b 01       	movw	r10, r22
    18b8:	6c 01       	movw	r12, r24
    18ba:	ad 82       	std	Y+5, r10	; 0x05
    18bc:	be 82       	std	Y+6, r11	; 0x06
    18be:	cf 82       	std	Y+7, r12	; 0x07
    18c0:	d8 86       	std	Y+8, r13	; 0x08
	target[Z_AXIS] = lround(z*settings.steps_per_mm[2]); 
    18c2:	20 91 43 20 	lds	r18, 0x2043
    18c6:	30 91 44 20 	lds	r19, 0x2044
    18ca:	40 91 45 20 	lds	r20, 0x2045
    18ce:	50 91 46 20 	lds	r21, 0x2046
    18d2:	2d 8b       	std	Y+21, r18	; 0x15
    18d4:	3e 8b       	std	Y+22, r19	; 0x16
    18d6:	4f 8b       	std	Y+23, r20	; 0x17
    18d8:	58 8f       	std	Y+24, r21	; 0x18
    18da:	c8 01       	movw	r24, r16
    18dc:	b7 01       	movw	r22, r14
    18de:	0e 94 40 1c 	call	0x3880	; 0x3880 <__mulsf3>
    18e2:	0e 94 dd 1b 	call	0x37ba	; 0x37ba <lround>
    18e6:	9b 01       	movw	r18, r22
    18e8:	ac 01       	movw	r20, r24
    18ea:	29 87       	std	Y+9, r18	; 0x09
    18ec:	3a 87       	std	Y+10, r19	; 0x0a
    18ee:	4b 87       	std	Y+11, r20	; 0x0b
    18f0:	5c 87       	std	Y+12, r21	; 0x0c

	for(axis = X_AXIS; axis <= Z_AXIS; axis++) {
		steps[axis] = target[axis]-position[axis];
    18f2:	80 91 78 20 	lds	r24, 0x2078
    18f6:	90 91 79 20 	lds	r25, 0x2079
    18fa:	a0 91 7a 20 	lds	r26, 0x207A
    18fe:	b0 91 7b 20 	lds	r27, 0x207B
    1902:	83 01       	movw	r16, r6
    1904:	72 01       	movw	r14, r4
    1906:	e8 1a       	sub	r14, r24
    1908:	f9 0a       	sbc	r15, r25
    190a:	0a 0b       	sbc	r16, r26
    190c:	1b 0b       	sbc	r17, r27
    190e:	ed 86       	std	Y+13, r14	; 0x0d
    1910:	fe 86       	std	Y+14, r15	; 0x0e
    1912:	0f 87       	std	Y+15, r16	; 0x0f
    1914:	18 8b       	std	Y+16, r17	; 0x10
    1916:	80 91 7c 20 	lds	r24, 0x207C
    191a:	90 91 7d 20 	lds	r25, 0x207D
    191e:	a0 91 7e 20 	lds	r26, 0x207E
    1922:	b0 91 7f 20 	lds	r27, 0x207F
    1926:	15 01       	movw	r2, r10
    1928:	26 01       	movw	r4, r12
    192a:	28 1a       	sub	r2, r24
    192c:	39 0a       	sbc	r3, r25
    192e:	4a 0a       	sbc	r4, r26
    1930:	5b 0a       	sbc	r5, r27
    1932:	80 91 80 20 	lds	r24, 0x2080
    1936:	90 91 81 20 	lds	r25, 0x2081
    193a:	a0 91 82 20 	lds	r26, 0x2082
    193e:	b0 91 83 20 	lds	r27, 0x2083
    1942:	79 01       	movw	r14, r18
    1944:	8a 01       	movw	r16, r20
    1946:	e8 1a       	sub	r14, r24
    1948:	f9 0a       	sbc	r15, r25
    194a:	0a 0b       	sbc	r16, r26
    194c:	1b 0b       	sbc	r17, r27
    194e:	e9 8a       	std	Y+17, r14	; 0x11
    1950:	fa 8a       	std	Y+18, r15	; 0x12
    1952:	0b 8b       	std	Y+19, r16	; 0x13
    1954:	1c 8b       	std	Y+20, r17	; 0x14
	}
  
	if (invert_feed_rate) {
    1956:	89 28       	or	r8, r9
    1958:	a9 f0       	breq	.+42     	; 0x1984 <mc_line+0x168>
    	st_buffer_line(steps[X_AXIS], steps[Y_AXIS], steps[Z_AXIS], lround(ONE_MINUTE_OF_MICROSECONDS/feed_rate));
    195a:	60 ec       	ldi	r22, 0xC0	; 192
    195c:	71 ee       	ldi	r23, 0xE1	; 225
    195e:	84 e6       	ldi	r24, 0x64	; 100
    1960:	9c e4       	ldi	r25, 0x4C	; 76
    1962:	2d a1       	ldd	r18, Y+37	; 0x25
    1964:	3e a1       	ldd	r19, Y+38	; 0x26
    1966:	4f a1       	ldd	r20, Y+39	; 0x27
    1968:	58 a5       	ldd	r21, Y+40	; 0x28
    196a:	0e 94 52 19 	call	0x32a4	; 0x32a4 <__divsf3>
    196e:	0e 94 dd 1b 	call	0x37ba	; 0x37ba <lround>
    1972:	5b 01       	movw	r10, r22
    1974:	6c 01       	movw	r12, r24
    1976:	6d 85       	ldd	r22, Y+13	; 0x0d
    1978:	7e 85       	ldd	r23, Y+14	; 0x0e
    197a:	8f 85       	ldd	r24, Y+15	; 0x0f
    197c:	98 89       	ldd	r25, Y+16	; 0x10
    197e:	a2 01       	movw	r20, r4
    1980:	91 01       	movw	r18, r2
    1982:	54 c0       	rjmp	.+168    	; 0x1a2c <mc_line+0x210>
	} else {  // Ask old Phytagoras to estimate how many mm our next move is going to take us
 		millimeters_of_travel = sqrt(square(steps[X_AXIS]/settings.steps_per_mm[0]) + 
    1984:	6d 85       	ldd	r22, Y+13	; 0x0d
    1986:	7e 85       	ldd	r23, Y+14	; 0x0e
    1988:	8f 85       	ldd	r24, Y+15	; 0x0f
    198a:	98 89       	ldd	r25, Y+16	; 0x10
    198c:	0e 94 ed 19 	call	0x33da	; 0x33da <__floatsisf>
    1990:	2d 8d       	ldd	r18, Y+29	; 0x1d
    1992:	3e 8d       	ldd	r19, Y+30	; 0x1e
    1994:	4f 8d       	ldd	r20, Y+31	; 0x1f
    1996:	58 a1       	ldd	r21, Y+32	; 0x20
    1998:	0e 94 52 19 	call	0x32a4	; 0x32a4 <__divsf3>
    199c:	0e 94 0b 1d 	call	0x3a16	; 0x3a16 <square>
    19a0:	3b 01       	movw	r6, r22
    19a2:	4c 01       	movw	r8, r24
    19a4:	c2 01       	movw	r24, r4
    19a6:	b1 01       	movw	r22, r2
    19a8:	0e 94 ed 19 	call	0x33da	; 0x33da <__floatsisf>
    19ac:	29 8d       	ldd	r18, Y+25	; 0x19
    19ae:	3a 8d       	ldd	r19, Y+26	; 0x1a
    19b0:	4b 8d       	ldd	r20, Y+27	; 0x1b
    19b2:	5c 8d       	ldd	r21, Y+28	; 0x1c
    19b4:	0e 94 52 19 	call	0x32a4	; 0x32a4 <__divsf3>
    19b8:	0e 94 0b 1d 	call	0x3a16	; 0x3a16 <square>
    19bc:	5b 01       	movw	r10, r22
    19be:	6c 01       	movw	r12, r24
    19c0:	69 89       	ldd	r22, Y+17	; 0x11
    19c2:	7a 89       	ldd	r23, Y+18	; 0x12
    19c4:	8b 89       	ldd	r24, Y+19	; 0x13
    19c6:	9c 89       	ldd	r25, Y+20	; 0x14
    19c8:	0e 94 ed 19 	call	0x33da	; 0x33da <__floatsisf>
    19cc:	2d 89       	ldd	r18, Y+21	; 0x15
    19ce:	3e 89       	ldd	r19, Y+22	; 0x16
    19d0:	4f 89       	ldd	r20, Y+23	; 0x17
    19d2:	58 8d       	ldd	r21, Y+24	; 0x18
    19d4:	0e 94 52 19 	call	0x32a4	; 0x32a4 <__divsf3>
    19d8:	0e 94 0b 1d 	call	0x3a16	; 0x3a16 <square>
    19dc:	7b 01       	movw	r14, r22
    19de:	8c 01       	movw	r16, r24
    19e0:	c4 01       	movw	r24, r8
    19e2:	b3 01       	movw	r22, r6
    19e4:	a6 01       	movw	r20, r12
    19e6:	95 01       	movw	r18, r10
    19e8:	0e 94 ac 18 	call	0x3158	; 0x3158 <__addsf3>
    19ec:	a8 01       	movw	r20, r16
    19ee:	97 01       	movw	r18, r14
    19f0:	0e 94 ac 18 	call	0x3158	; 0x3158 <__addsf3>
    19f4:	0e 94 cd 1c 	call	0x399a	; 0x399a <sqrt>
									 square(steps[Y_AXIS]/settings.steps_per_mm[1]) + 
									 square(steps[Z_AXIS]/settings.steps_per_mm[2]));
		st_buffer_line(steps[X_AXIS], steps[Y_AXIS], steps[Z_AXIS], lround((millimeters_of_travel/feed_rate)*1000000));
    19f8:	2d a1       	ldd	r18, Y+37	; 0x25
    19fa:	3e a1       	ldd	r19, Y+38	; 0x26
    19fc:	4f a1       	ldd	r20, Y+39	; 0x27
    19fe:	58 a5       	ldd	r21, Y+40	; 0x28
    1a00:	0e 94 52 19 	call	0x32a4	; 0x32a4 <__divsf3>
    1a04:	20 e0       	ldi	r18, 0x00	; 0
    1a06:	34 e2       	ldi	r19, 0x24	; 36
    1a08:	44 e7       	ldi	r20, 0x74	; 116
    1a0a:	59 e4       	ldi	r21, 0x49	; 73
    1a0c:	0e 94 40 1c 	call	0x3880	; 0x3880 <__mulsf3>
    1a10:	0e 94 dd 1b 	call	0x37ba	; 0x37ba <lround>
    1a14:	5b 01       	movw	r10, r22
    1a16:	6c 01       	movw	r12, r24
    1a18:	6d 85       	ldd	r22, Y+13	; 0x0d
    1a1a:	7e 85       	ldd	r23, Y+14	; 0x0e
    1a1c:	8f 85       	ldd	r24, Y+15	; 0x0f
    1a1e:	98 89       	ldd	r25, Y+16	; 0x10
    1a20:	a2 01       	movw	r20, r4
    1a22:	91 01       	movw	r18, r2
    1a24:	e9 88       	ldd	r14, Y+17	; 0x11
    1a26:	fa 88       	ldd	r15, Y+18	; 0x12
    1a28:	0b 89       	ldd	r16, Y+19	; 0x13
    1a2a:	1c 89       	ldd	r17, Y+20	; 0x14
    1a2c:	0e 94 9f 13 	call	0x273e	; 0x273e <st_buffer_line>
	}
	memcpy(position, target, sizeof(target)); 	// position[] = target[] 
    1a30:	a8 e7       	ldi	r26, 0x78	; 120
    1a32:	b0 e2       	ldi	r27, 0x20	; 32
    1a34:	fe 01       	movw	r30, r28
    1a36:	31 96       	adiw	r30, 0x01	; 1
    1a38:	8c e0       	ldi	r24, 0x0C	; 12
    1a3a:	01 90       	ld	r0, Z+
    1a3c:	0d 92       	st	X+, r0
    1a3e:	81 50       	subi	r24, 0x01	; 1
    1a40:	e1 f7       	brne	.-8      	; 0x1a3a <mc_line+0x21e>
}
    1a42:	a8 96       	adiw	r28, 0x28	; 40
    1a44:	cd bf       	out	0x3d, r28	; 61
    1a46:	de bf       	out	0x3e, r29	; 62
    1a48:	cf 91       	pop	r28
    1a4a:	df 91       	pop	r29
    1a4c:	1f 91       	pop	r17
    1a4e:	0f 91       	pop	r16
    1a50:	ff 90       	pop	r15
    1a52:	ef 90       	pop	r14
    1a54:	df 90       	pop	r13
    1a56:	cf 90       	pop	r12
    1a58:	bf 90       	pop	r11
    1a5a:	af 90       	pop	r10
    1a5c:	9f 90       	pop	r9
    1a5e:	8f 90       	pop	r8
    1a60:	7f 90       	pop	r7
    1a62:	6f 90       	pop	r6
    1a64:	5f 90       	pop	r5
    1a66:	4f 90       	pop	r4
    1a68:	3f 90       	pop	r3
    1a6a:	2f 90       	pop	r2
    1a6c:	08 95       	ret

00001a6e <mc_arc>:
	The length of each segment is configured in config.h by setting MM_PER_ARC_SEGMENT.  
*/

void mc_arc(double theta, double angular_travel, double radius, double linear_travel, int axis_1, int axis_2, 
  int axis_linear, double feed_rate, int invert_feed_rate)
{
    1a6e:	2f 92       	push	r2
    1a70:	3f 92       	push	r3
    1a72:	4f 92       	push	r4
    1a74:	5f 92       	push	r5
    1a76:	6f 92       	push	r6
    1a78:	7f 92       	push	r7
    1a7a:	8f 92       	push	r8
    1a7c:	9f 92       	push	r9
    1a7e:	af 92       	push	r10
    1a80:	bf 92       	push	r11
    1a82:	cf 92       	push	r12
    1a84:	df 92       	push	r13
    1a86:	ef 92       	push	r14
    1a88:	ff 92       	push	r15
    1a8a:	0f 93       	push	r16
    1a8c:	1f 93       	push	r17
    1a8e:	df 93       	push	r29
    1a90:	cf 93       	push	r28
    1a92:	cd b7       	in	r28, 0x3d	; 61
    1a94:	de b7       	in	r29, 0x3e	; 62
    1a96:	ac 97       	sbiw	r28, 0x2c	; 44
    1a98:	cd bf       	out	0x3d, r28	; 61
    1a9a:	de bf       	out	0x3e, r29	; 62
    1a9c:	1b 01       	movw	r2, r22
    1a9e:	2c 01       	movw	r4, r24
    1aa0:	29 a3       	std	Y+33, r18	; 0x21
    1aa2:	3a a3       	std	Y+34, r19	; 0x22
    1aa4:	4b a3       	std	Y+35, r20	; 0x23
    1aa6:	5c a3       	std	Y+36, r21	; 0x24
    1aa8:	ed a2       	std	Y+37, r14	; 0x25
    1aaa:	fe a2       	std	Y+38, r15	; 0x26
    1aac:	0f a3       	std	Y+39, r16	; 0x27
    1aae:	18 a7       	std	Y+40, r17	; 0x28
	double center_x;				// center of this circle
	double center_y;				// center of this circle
	double target[3];
	int i;

	millimeters_of_travel = hypot(angular_travel*radius, labs(linear_travel));
    1ab0:	ca 01       	movw	r24, r20
    1ab2:	b9 01       	movw	r22, r18
    1ab4:	a8 01       	movw	r20, r16
    1ab6:	97 01       	movw	r18, r14
    1ab8:	0e 94 40 1c 	call	0x3880	; 0x3880 <__mulsf3>
    1abc:	7b 01       	movw	r14, r22
    1abe:	8c 01       	movw	r16, r24
    1ac0:	c6 01       	movw	r24, r12
    1ac2:	b5 01       	movw	r22, r10
    1ac4:	0e 94 ba 19 	call	0x3374	; 0x3374 <__fixsfsi>
    1ac8:	97 ff       	sbrs	r25, 7
    1aca:	07 c0       	rjmp	.+14     	; 0x1ada <mc_arc+0x6c>
    1acc:	90 95       	com	r25
    1ace:	80 95       	com	r24
    1ad0:	70 95       	com	r23
    1ad2:	61 95       	neg	r22
    1ad4:	7f 4f       	sbci	r23, 0xFF	; 255
    1ad6:	8f 4f       	sbci	r24, 0xFF	; 255
    1ad8:	9f 4f       	sbci	r25, 0xFF	; 255
    1ada:	0e 94 ed 19 	call	0x33da	; 0x33da <__floatsisf>
    1ade:	9b 01       	movw	r18, r22
    1ae0:	ac 01       	movw	r20, r24
    1ae2:	c8 01       	movw	r24, r16
    1ae4:	b7 01       	movw	r22, r14
    1ae6:	0e 94 48 1b 	call	0x3690	; 0x3690 <hypot>
    1aea:	7b 01       	movw	r14, r22
    1aec:	8c 01       	movw	r16, r24
	
	if (millimeters_of_travel == 0.0) { 
    1aee:	20 e0       	ldi	r18, 0x00	; 0
    1af0:	30 e0       	ldi	r19, 0x00	; 0
    1af2:	40 e0       	ldi	r20, 0x00	; 0
    1af4:	50 e0       	ldi	r21, 0x00	; 0
    1af6:	0e 94 4b 19 	call	0x3296	; 0x3296 <__cmpsf2>
    1afa:	88 23       	and	r24, r24
    1afc:	09 f4       	brne	.+2      	; 0x1b00 <mc_arc+0x92>
    1afe:	4e c1       	rjmp	.+668    	; 0x1d9c <mc_arc+0x32e>
		return; 
	}
	uint16_t segments = ceil(millimeters_of_travel/settings.mm_per_arc_segment);
    1b00:	c8 01       	movw	r24, r16
    1b02:	b7 01       	movw	r22, r14
    1b04:	20 91 52 20 	lds	r18, 0x2052
    1b08:	30 91 53 20 	lds	r19, 0x2053
    1b0c:	40 91 54 20 	lds	r20, 0x2054
    1b10:	50 91 55 20 	lds	r21, 0x2055
    1b14:	0e 94 52 19 	call	0x32a4	; 0x32a4 <__divsf3>
    1b18:	0e 94 38 19 	call	0x3270	; 0x3270 <ceil>
    1b1c:	0e 94 bf 19 	call	0x337e	; 0x337e <__fixunssfsi>
    1b20:	6d 87       	std	Y+13, r22	; 0x0d
    1b22:	7e 87       	std	Y+14, r23	; 0x0e
  
  	/*  Multiply inverse feed_rate to compensate for the fact that this movement 
		is approximated by a number of discrete segments. 
		The inverse feed_rate should be correct for the sum of all segments.*/

	if (invert_feed_rate) { 
    1b24:	2c 96       	adiw	r28, 0x0c	; 12
    1b26:	2e ad       	ldd	r18, Y+62	; 0x3e
    1b28:	3f ad       	ldd	r19, Y+63	; 0x3f
    1b2a:	2c 97       	sbiw	r28, 0x0c	; 12
    1b2c:	23 2b       	or	r18, r19
    1b2e:	a1 f0       	breq	.+40     	; 0x1b58 <mc_arc+0xea>
		feed_rate *= segments; 
    1b30:	80 e0       	ldi	r24, 0x00	; 0
    1b32:	90 e0       	ldi	r25, 0x00	; 0
    1b34:	0e 94 eb 19 	call	0x33d6	; 0x33d6 <__floatunsisf>
    1b38:	9b 01       	movw	r18, r22
    1b3a:	ac 01       	movw	r20, r24
    1b3c:	2a 96       	adiw	r28, 0x0a	; 10
    1b3e:	6c ad       	ldd	r22, Y+60	; 0x3c
    1b40:	7d ad       	ldd	r23, Y+61	; 0x3d
    1b42:	8e ad       	ldd	r24, Y+62	; 0x3e
    1b44:	9f ad       	ldd	r25, Y+63	; 0x3f
    1b46:	2a 97       	sbiw	r28, 0x0a	; 10
    1b48:	0e 94 40 1c 	call	0x3880	; 0x3880 <__mulsf3>
    1b4c:	2a 96       	adiw	r28, 0x0a	; 10
    1b4e:	6c af       	std	Y+60, r22	; 0x3c
    1b50:	7d af       	std	Y+61, r23	; 0x3d
    1b52:	8e af       	std	Y+62, r24	; 0x3e
    1b54:	9f af       	std	Y+63, r25	; 0x3f
    1b56:	2a 97       	sbiw	r28, 0x0a	; 10
	}
  
	theta_per_segment = angular_travel/segments;
    1b58:	ed 85       	ldd	r30, Y+13	; 0x0d
    1b5a:	fe 85       	ldd	r31, Y+14	; 0x0e
    1b5c:	bf 01       	movw	r22, r30
    1b5e:	80 e0       	ldi	r24, 0x00	; 0
    1b60:	90 e0       	ldi	r25, 0x00	; 0
    1b62:	0e 94 eb 19 	call	0x33d6	; 0x33d6 <__floatunsisf>
    1b66:	7b 01       	movw	r14, r22
    1b68:	8c 01       	movw	r16, r24
    1b6a:	69 a1       	ldd	r22, Y+33	; 0x21
    1b6c:	7a a1       	ldd	r23, Y+34	; 0x22
    1b6e:	8b a1       	ldd	r24, Y+35	; 0x23
    1b70:	9c a1       	ldd	r25, Y+36	; 0x24
    1b72:	a8 01       	movw	r20, r16
    1b74:	97 01       	movw	r18, r14
    1b76:	0e 94 52 19 	call	0x32a4	; 0x32a4 <__divsf3>
    1b7a:	6d 8f       	std	Y+29, r22	; 0x1d
    1b7c:	7e 8f       	std	Y+30, r23	; 0x1e
    1b7e:	8f 8f       	std	Y+31, r24	; 0x1f
    1b80:	98 a3       	std	Y+32, r25	; 0x20
	linear_per_segment = linear_travel/segments;
    1b82:	c6 01       	movw	r24, r12
    1b84:	b5 01       	movw	r22, r10
    1b86:	a8 01       	movw	r20, r16
    1b88:	97 01       	movw	r18, r14
    1b8a:	0e 94 52 19 	call	0x32a4	; 0x32a4 <__divsf3>
    1b8e:	69 8f       	std	Y+25, r22	; 0x19
    1b90:	7a 8f       	std	Y+26, r23	; 0x1a
    1b92:	8b 8f       	std	Y+27, r24	; 0x1b
    1b94:	9c 8f       	std	Y+28, r25	; 0x1c
	
	center_x = (position[axis_1]/settings.steps_per_mm[axis_1])-sin(theta)*radius;
    1b96:	c2 01       	movw	r24, r4
    1b98:	b1 01       	movw	r22, r2
    1b9a:	0e 94 c3 1c 	call	0x3986	; 0x3986 <sin>
    1b9e:	5b 01       	movw	r10, r22
    1ba0:	6c 01       	movw	r12, r24
    1ba2:	88 0c       	add	r8, r8
    1ba4:	99 1c       	adc	r9, r9
    1ba6:	88 0c       	add	r8, r8
    1ba8:	99 1c       	adc	r9, r9
    1baa:	f4 01       	movw	r30, r8
    1bac:	e8 58       	subi	r30, 0x88	; 136
    1bae:	ff 4d       	sbci	r31, 0xDF	; 223
    1bb0:	60 81       	ld	r22, Z
    1bb2:	71 81       	ldd	r23, Z+1	; 0x01
    1bb4:	82 81       	ldd	r24, Z+2	; 0x02
    1bb6:	93 81       	ldd	r25, Z+3	; 0x03
    1bb8:	0e 94 ed 19 	call	0x33da	; 0x33da <__floatsisf>
    1bbc:	f4 01       	movw	r30, r8
    1bbe:	e5 5c       	subi	r30, 0xC5	; 197
    1bc0:	ff 4d       	sbci	r31, 0xDF	; 223
    1bc2:	20 81       	ld	r18, Z
    1bc4:	31 81       	ldd	r19, Z+1	; 0x01
    1bc6:	42 81       	ldd	r20, Z+2	; 0x02
    1bc8:	53 81       	ldd	r21, Z+3	; 0x03
    1bca:	0e 94 52 19 	call	0x32a4	; 0x32a4 <__divsf3>
    1bce:	7b 01       	movw	r14, r22
    1bd0:	8c 01       	movw	r16, r24
    1bd2:	c6 01       	movw	r24, r12
    1bd4:	b5 01       	movw	r22, r10
    1bd6:	2d a1       	ldd	r18, Y+37	; 0x25
    1bd8:	3e a1       	ldd	r19, Y+38	; 0x26
    1bda:	4f a1       	ldd	r20, Y+39	; 0x27
    1bdc:	58 a5       	ldd	r21, Y+40	; 0x28
    1bde:	0e 94 40 1c 	call	0x3880	; 0x3880 <__mulsf3>
    1be2:	9b 01       	movw	r18, r22
    1be4:	ac 01       	movw	r20, r24
    1be6:	c8 01       	movw	r24, r16
    1be8:	b7 01       	movw	r22, r14
    1bea:	0e 94 ab 18 	call	0x3156	; 0x3156 <__subsf3>
    1bee:	6d 8b       	std	Y+21, r22	; 0x15
    1bf0:	7e 8b       	std	Y+22, r23	; 0x16
    1bf2:	8f 8b       	std	Y+23, r24	; 0x17
    1bf4:	98 8f       	std	Y+24, r25	; 0x18
	center_y = (position[axis_2]/settings.steps_per_mm[axis_2])-cos(theta)*radius;
    1bf6:	c2 01       	movw	r24, r4
    1bf8:	b1 01       	movw	r22, r2
    1bfa:	0e 94 4f 19 	call	0x329e	; 0x329e <cos>
    1bfe:	5b 01       	movw	r10, r22
    1c00:	6c 01       	movw	r12, r24
    1c02:	24 96       	adiw	r28, 0x04	; 4
    1c04:	ee ad       	ldd	r30, Y+62	; 0x3e
    1c06:	ff ad       	ldd	r31, Y+63	; 0x3f
    1c08:	24 97       	sbiw	r28, 0x04	; 4
    1c0a:	3f 01       	movw	r6, r30
    1c0c:	66 0c       	add	r6, r6
    1c0e:	77 1c       	adc	r7, r7
    1c10:	66 0c       	add	r6, r6
    1c12:	77 1c       	adc	r7, r7
    1c14:	f3 01       	movw	r30, r6
    1c16:	e8 58       	subi	r30, 0x88	; 136
    1c18:	ff 4d       	sbci	r31, 0xDF	; 223
    1c1a:	60 81       	ld	r22, Z
    1c1c:	71 81       	ldd	r23, Z+1	; 0x01
    1c1e:	82 81       	ldd	r24, Z+2	; 0x02
    1c20:	93 81       	ldd	r25, Z+3	; 0x03
    1c22:	0e 94 ed 19 	call	0x33da	; 0x33da <__floatsisf>
    1c26:	f3 01       	movw	r30, r6
    1c28:	e5 5c       	subi	r30, 0xC5	; 197
    1c2a:	ff 4d       	sbci	r31, 0xDF	; 223
    1c2c:	20 81       	ld	r18, Z
    1c2e:	31 81       	ldd	r19, Z+1	; 0x01
    1c30:	42 81       	ldd	r20, Z+2	; 0x02
    1c32:	53 81       	ldd	r21, Z+3	; 0x03
    1c34:	0e 94 52 19 	call	0x32a4	; 0x32a4 <__divsf3>
    1c38:	7b 01       	movw	r14, r22
    1c3a:	8c 01       	movw	r16, r24
    1c3c:	c6 01       	movw	r24, r12
    1c3e:	b5 01       	movw	r22, r10
    1c40:	2d a1       	ldd	r18, Y+37	; 0x25
    1c42:	3e a1       	ldd	r19, Y+38	; 0x26
    1c44:	4f a1       	ldd	r20, Y+39	; 0x27
    1c46:	58 a5       	ldd	r21, Y+40	; 0x28
    1c48:	0e 94 40 1c 	call	0x3880	; 0x3880 <__mulsf3>
    1c4c:	9b 01       	movw	r18, r22
    1c4e:	ac 01       	movw	r20, r24
    1c50:	c8 01       	movw	r24, r16
    1c52:	b7 01       	movw	r22, r14
    1c54:	0e 94 ab 18 	call	0x3156	; 0x3156 <__subsf3>
    1c58:	69 8b       	std	Y+17, r22	; 0x11
    1c5a:	7a 8b       	std	Y+18, r23	; 0x12
    1c5c:	8b 8b       	std	Y+19, r24	; 0x13
    1c5e:	9c 8b       	std	Y+20, r25	; 0x14

  	/* 	A vector to track the end point of each segment
		Initialize the linear axis */
	
	target[axis_linear] = position[axis_linear]/Z_STEPS_PER_MM;
    1c60:	26 96       	adiw	r28, 0x06	; 6
    1c62:	ee ad       	ldd	r30, Y+62	; 0x3e
    1c64:	ff ad       	ldd	r31, Y+63	; 0x3f
    1c66:	26 97       	sbiw	r28, 0x06	; 6
    1c68:	ee 0f       	add	r30, r30
    1c6a:	ff 1f       	adc	r31, r31
    1c6c:	ee 0f       	add	r30, r30
    1c6e:	ff 1f       	adc	r31, r31
    1c70:	8e 01       	movw	r16, r28
    1c72:	0f 5f       	subi	r16, 0xFF	; 255
    1c74:	1f 4f       	sbci	r17, 0xFF	; 255
    1c76:	78 01       	movw	r14, r16
    1c78:	ee 0e       	add	r14, r30
    1c7a:	ff 1e       	adc	r15, r31
    1c7c:	e8 58       	subi	r30, 0x88	; 136
    1c7e:	ff 4d       	sbci	r31, 0xDF	; 223
    1c80:	60 81       	ld	r22, Z
    1c82:	71 81       	ldd	r23, Z+1	; 0x01
    1c84:	82 81       	ldd	r24, Z+2	; 0x02
    1c86:	93 81       	ldd	r25, Z+3	; 0x03
    1c88:	0e 94 ed 19 	call	0x33da	; 0x33da <__floatsisf>
    1c8c:	26 ef       	ldi	r18, 0xF6	; 246
    1c8e:	3a e7       	ldi	r19, 0x7A	; 122
    1c90:	4d e1       	ldi	r20, 0x1D	; 29
    1c92:	54 e4       	ldi	r21, 0x44	; 68
    1c94:	0e 94 52 19 	call	0x32a4	; 0x32a4 <__divsf3>
    1c98:	d7 01       	movw	r26, r14
    1c9a:	6d 93       	st	X+, r22
    1c9c:	7d 93       	st	X+, r23
    1c9e:	8d 93       	st	X+, r24
    1ca0:	9c 93       	st	X, r25
    1ca2:	13 97       	sbiw	r26, 0x03	; 3
    1ca4:	1f 86       	std	Y+15, r1	; 0x0f
    1ca6:	18 8a       	std	Y+16, r1	; 0x10
  	for (i=0; i<=segments; i++) {
		target[axis_linear] += linear_per_segment;
    1ca8:	e9 a6       	std	Y+41, r14	; 0x29
    1caa:	fa a6       	std	Y+42, r15	; 0x2a
		theta += theta_per_segment;
		target[axis_1] = center_x+sin(theta)*radius;
    1cac:	f8 01       	movw	r30, r16
    1cae:	e8 0d       	add	r30, r8
    1cb0:	f9 1d       	adc	r31, r9
    1cb2:	eb a7       	std	Y+43, r30	; 0x2b
    1cb4:	fc a7       	std	Y+44, r31	; 0x2c
		target[axis_2] = center_y+cos(theta)*radius;
    1cb6:	60 0e       	add	r6, r16
    1cb8:	71 1e       	adc	r7, r17
    1cba:	68 c0       	rjmp	.+208    	; 0x1d8c <mc_arc+0x31e>
  	/* 	A vector to track the end point of each segment
		Initialize the linear axis */
	
	target[axis_linear] = position[axis_linear]/Z_STEPS_PER_MM;
  	for (i=0; i<=segments; i++) {
		target[axis_linear] += linear_per_segment;
    1cbc:	a9 a5       	ldd	r26, Y+41	; 0x29
    1cbe:	ba a5       	ldd	r27, Y+42	; 0x2a
    1cc0:	6d 91       	ld	r22, X+
    1cc2:	7d 91       	ld	r23, X+
    1cc4:	8d 91       	ld	r24, X+
    1cc6:	9c 91       	ld	r25, X
    1cc8:	29 8d       	ldd	r18, Y+25	; 0x19
    1cca:	3a 8d       	ldd	r19, Y+26	; 0x1a
    1ccc:	4b 8d       	ldd	r20, Y+27	; 0x1b
    1cce:	5c 8d       	ldd	r21, Y+28	; 0x1c
    1cd0:	0e 94 ac 18 	call	0x3158	; 0x3158 <__addsf3>
    1cd4:	e9 a5       	ldd	r30, Y+41	; 0x29
    1cd6:	fa a5       	ldd	r31, Y+42	; 0x2a
    1cd8:	60 83       	st	Z, r22
    1cda:	71 83       	std	Z+1, r23	; 0x01
    1cdc:	82 83       	std	Z+2, r24	; 0x02
    1cde:	93 83       	std	Z+3, r25	; 0x03
		theta += theta_per_segment;
    1ce0:	c2 01       	movw	r24, r4
    1ce2:	b1 01       	movw	r22, r2
    1ce4:	2d 8d       	ldd	r18, Y+29	; 0x1d
    1ce6:	3e 8d       	ldd	r19, Y+30	; 0x1e
    1ce8:	4f 8d       	ldd	r20, Y+31	; 0x1f
    1cea:	58 a1       	ldd	r21, Y+32	; 0x20
    1cec:	0e 94 ac 18 	call	0x3158	; 0x3158 <__addsf3>
    1cf0:	1b 01       	movw	r2, r22
    1cf2:	2c 01       	movw	r4, r24
		target[axis_1] = center_x+sin(theta)*radius;
    1cf4:	0e 94 c3 1c 	call	0x3986	; 0x3986 <sin>
    1cf8:	2d a1       	ldd	r18, Y+37	; 0x25
    1cfa:	3e a1       	ldd	r19, Y+38	; 0x26
    1cfc:	4f a1       	ldd	r20, Y+39	; 0x27
    1cfe:	58 a5       	ldd	r21, Y+40	; 0x28
    1d00:	0e 94 40 1c 	call	0x3880	; 0x3880 <__mulsf3>
    1d04:	9b 01       	movw	r18, r22
    1d06:	ac 01       	movw	r20, r24
    1d08:	6d 89       	ldd	r22, Y+21	; 0x15
    1d0a:	7e 89       	ldd	r23, Y+22	; 0x16
    1d0c:	8f 89       	ldd	r24, Y+23	; 0x17
    1d0e:	98 8d       	ldd	r25, Y+24	; 0x18
    1d10:	0e 94 ac 18 	call	0x3158	; 0x3158 <__addsf3>
    1d14:	ab a5       	ldd	r26, Y+43	; 0x2b
    1d16:	bc a5       	ldd	r27, Y+44	; 0x2c
    1d18:	6d 93       	st	X+, r22
    1d1a:	7d 93       	st	X+, r23
    1d1c:	8d 93       	st	X+, r24
    1d1e:	9c 93       	st	X, r25
    1d20:	13 97       	sbiw	r26, 0x03	; 3
		target[axis_2] = center_y+cos(theta)*radius;
    1d22:	c2 01       	movw	r24, r4
    1d24:	b1 01       	movw	r22, r2
    1d26:	0e 94 4f 19 	call	0x329e	; 0x329e <cos>
    1d2a:	2d a1       	ldd	r18, Y+37	; 0x25
    1d2c:	3e a1       	ldd	r19, Y+38	; 0x26
    1d2e:	4f a1       	ldd	r20, Y+39	; 0x27
    1d30:	58 a5       	ldd	r21, Y+40	; 0x28
    1d32:	0e 94 40 1c 	call	0x3880	; 0x3880 <__mulsf3>
    1d36:	9b 01       	movw	r18, r22
    1d38:	ac 01       	movw	r20, r24
    1d3a:	69 89       	ldd	r22, Y+17	; 0x11
    1d3c:	7a 89       	ldd	r23, Y+18	; 0x12
    1d3e:	8b 89       	ldd	r24, Y+19	; 0x13
    1d40:	9c 89       	ldd	r25, Y+20	; 0x14
    1d42:	0e 94 ac 18 	call	0x3158	; 0x3158 <__addsf3>
    1d46:	f3 01       	movw	r30, r6
    1d48:	60 83       	st	Z, r22
    1d4a:	71 83       	std	Z+1, r23	; 0x01
    1d4c:	82 83       	std	Z+2, r24	; 0x02
    1d4e:	93 83       	std	Z+3, r25	; 0x03
		mc_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], feed_rate, invert_feed_rate);
    1d50:	69 81       	ldd	r22, Y+1	; 0x01
    1d52:	7a 81       	ldd	r23, Y+2	; 0x02
    1d54:	8b 81       	ldd	r24, Y+3	; 0x03
    1d56:	9c 81       	ldd	r25, Y+4	; 0x04
    1d58:	2d 81       	ldd	r18, Y+5	; 0x05
    1d5a:	3e 81       	ldd	r19, Y+6	; 0x06
    1d5c:	4f 81       	ldd	r20, Y+7	; 0x07
    1d5e:	58 85       	ldd	r21, Y+8	; 0x08
    1d60:	e9 84       	ldd	r14, Y+9	; 0x09
    1d62:	fa 84       	ldd	r15, Y+10	; 0x0a
    1d64:	0b 85       	ldd	r16, Y+11	; 0x0b
    1d66:	1c 85       	ldd	r17, Y+12	; 0x0c
    1d68:	2a 96       	adiw	r28, 0x0a	; 10
    1d6a:	ac ac       	ldd	r10, Y+60	; 0x3c
    1d6c:	bd ac       	ldd	r11, Y+61	; 0x3d
    1d6e:	ce ac       	ldd	r12, Y+62	; 0x3e
    1d70:	df ac       	ldd	r13, Y+63	; 0x3f
    1d72:	2a 97       	sbiw	r28, 0x0a	; 10
    1d74:	2c 96       	adiw	r28, 0x0c	; 12
    1d76:	8e ac       	ldd	r8, Y+62	; 0x3e
    1d78:	9f ac       	ldd	r9, Y+63	; 0x3f
    1d7a:	2c 97       	sbiw	r28, 0x0c	; 12
    1d7c:	0e 94 0e 0c 	call	0x181c	; 0x181c <mc_line>

  	/* 	A vector to track the end point of each segment
		Initialize the linear axis */
	
	target[axis_linear] = position[axis_linear]/Z_STEPS_PER_MM;
  	for (i=0; i<=segments; i++) {
    1d80:	2f 85       	ldd	r18, Y+15	; 0x0f
    1d82:	38 89       	ldd	r19, Y+16	; 0x10
    1d84:	2f 5f       	subi	r18, 0xFF	; 255
    1d86:	3f 4f       	sbci	r19, 0xFF	; 255
    1d88:	2f 87       	std	Y+15, r18	; 0x0f
    1d8a:	38 8b       	std	Y+16, r19	; 0x10
    1d8c:	8f 85       	ldd	r24, Y+15	; 0x0f
    1d8e:	98 89       	ldd	r25, Y+16	; 0x10
    1d90:	ad 85       	ldd	r26, Y+13	; 0x0d
    1d92:	be 85       	ldd	r27, Y+14	; 0x0e
    1d94:	a8 17       	cp	r26, r24
    1d96:	b9 07       	cpc	r27, r25
    1d98:	08 f0       	brcs	.+2      	; 0x1d9c <mc_arc+0x32e>
    1d9a:	90 cf       	rjmp	.-224    	; 0x1cbc <mc_arc+0x24e>
		theta += theta_per_segment;
		target[axis_1] = center_x+sin(theta)*radius;
		target[axis_2] = center_y+cos(theta)*radius;
		mc_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], feed_rate, invert_feed_rate);
  	}
}
    1d9c:	ac 96       	adiw	r28, 0x2c	; 44
    1d9e:	cd bf       	out	0x3d, r28	; 61
    1da0:	de bf       	out	0x3e, r29	; 62
    1da2:	cf 91       	pop	r28
    1da4:	df 91       	pop	r29
    1da6:	1f 91       	pop	r17
    1da8:	0f 91       	pop	r16
    1daa:	ff 90       	pop	r15
    1dac:	ef 90       	pop	r14
    1dae:	df 90       	pop	r13
    1db0:	cf 90       	pop	r12
    1db2:	bf 90       	pop	r11
    1db4:	af 90       	pop	r10
    1db6:	9f 90       	pop	r9
    1db8:	8f 90       	pop	r8
    1dba:	7f 90       	pop	r7
    1dbc:	6f 90       	pop	r6
    1dbe:	5f 90       	pop	r5
    1dc0:	4f 90       	pop	r4
    1dc2:	3f 90       	pop	r3
    1dc4:	2f 90       	pop	r2
    1dc6:	08 95       	ret

00001dc8 <mc_dwell>:


/* mc_dwell() */

void mc_dwell(uint32_t milliseconds) 
{
    1dc8:	af 92       	push	r10
    1dca:	bf 92       	push	r11
    1dcc:	cf 92       	push	r12
    1dce:	df 92       	push	r13
    1dd0:	ef 92       	push	r14
    1dd2:	ff 92       	push	r15
    1dd4:	0f 93       	push	r16
    1dd6:	1f 93       	push	r17
    1dd8:	7b 01       	movw	r14, r22
    1dda:	8c 01       	movw	r16, r24
	st_synchronize();
    1ddc:	0e 94 a3 12 	call	0x2546	; 0x2546 <st_synchronize>
	_delay_ms(milliseconds);
    1de0:	c8 01       	movw	r24, r16
    1de2:	b7 01       	movw	r22, r14
    1de4:	0e 94 eb 19 	call	0x33d6	; 0x33d6 <__floatunsisf>
    1de8:	5b 01       	movw	r10, r22
    1dea:	6c 01       	movw	r12, r24
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1dec:	20 e0       	ldi	r18, 0x00	; 0
    1dee:	30 e0       	ldi	r19, 0x00	; 0
    1df0:	4a ef       	ldi	r20, 0xFA	; 250
    1df2:	55 e4       	ldi	r21, 0x45	; 69
    1df4:	0e 94 40 1c 	call	0x3880	; 0x3880 <__mulsf3>
    1df8:	7b 01       	movw	r14, r22
    1dfa:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    1dfc:	20 e0       	ldi	r18, 0x00	; 0
    1dfe:	30 e0       	ldi	r19, 0x00	; 0
    1e00:	40 e8       	ldi	r20, 0x80	; 128
    1e02:	5f e3       	ldi	r21, 0x3F	; 63
    1e04:	0e 94 4b 19 	call	0x3296	; 0x3296 <__cmpsf2>
    1e08:	88 23       	and	r24, r24
    1e0a:	1c f4       	brge	.+6      	; 0x1e12 <mc_dwell+0x4a>
    1e0c:	61 e0       	ldi	r22, 0x01	; 1
    1e0e:	70 e0       	ldi	r23, 0x00	; 0
    1e10:	24 c0       	rjmp	.+72     	; 0x1e5a <mc_dwell+0x92>
		__ticks = 1;
	else if (__tmp > 65535)
    1e12:	c8 01       	movw	r24, r16
    1e14:	b7 01       	movw	r22, r14
    1e16:	20 e0       	ldi	r18, 0x00	; 0
    1e18:	3f ef       	ldi	r19, 0xFF	; 255
    1e1a:	4f e7       	ldi	r20, 0x7F	; 127
    1e1c:	57 e4       	ldi	r21, 0x47	; 71
    1e1e:	0e 94 3b 1b 	call	0x3676	; 0x3676 <__gesf2>
    1e22:	18 16       	cp	r1, r24
    1e24:	b4 f4       	brge	.+44     	; 0x1e52 <mc_dwell+0x8a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1e26:	c6 01       	movw	r24, r12
    1e28:	b5 01       	movw	r22, r10
    1e2a:	20 e0       	ldi	r18, 0x00	; 0
    1e2c:	30 e0       	ldi	r19, 0x00	; 0
    1e2e:	40 e2       	ldi	r20, 0x20	; 32
    1e30:	51 e4       	ldi	r21, 0x41	; 65
    1e32:	0e 94 40 1c 	call	0x3880	; 0x3880 <__mulsf3>
    1e36:	0e 94 bf 19 	call	0x337e	; 0x337e <__fixunssfsi>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1e3a:	80 e2       	ldi	r24, 0x20	; 32
    1e3c:	93 e0       	ldi	r25, 0x03	; 3
    1e3e:	05 c0       	rjmp	.+10     	; 0x1e4a <mc_dwell+0x82>
    1e40:	fc 01       	movw	r30, r24
    1e42:	31 97       	sbiw	r30, 0x01	; 1
    1e44:	f1 f7       	brne	.-4      	; 0x1e42 <mc_dwell+0x7a>
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1e46:	61 50       	subi	r22, 0x01	; 1
    1e48:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1e4a:	61 15       	cp	r22, r1
    1e4c:	71 05       	cpc	r23, r1
    1e4e:	c1 f7       	brne	.-16     	; 0x1e40 <mc_dwell+0x78>
    1e50:	07 c0       	rjmp	.+14     	; 0x1e60 <mc_dwell+0x98>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1e52:	c8 01       	movw	r24, r16
    1e54:	b7 01       	movw	r22, r14
    1e56:	0e 94 bf 19 	call	0x337e	; 0x337e <__fixunssfsi>
    1e5a:	cb 01       	movw	r24, r22
    1e5c:	01 97       	sbiw	r24, 0x01	; 1
    1e5e:	f1 f7       	brne	.-4      	; 0x1e5c <mc_dwell+0x94>
}
    1e60:	1f 91       	pop	r17
    1e62:	0f 91       	pop	r16
    1e64:	ff 90       	pop	r15
    1e66:	ef 90       	pop	r14
    1e68:	df 90       	pop	r13
    1e6a:	cf 90       	pop	r12
    1e6c:	bf 90       	pop	r11
    1e6e:	af 90       	pop	r10
    1e70:	08 95       	ret

00001e72 <PMIC_SetVectorLocationToBoot>:
 *  Change Protection register before writing the CTRL register. Interrupts are
 *  automatically ignored during the change enable period.
 */
void PMIC_SetVectorLocationToBoot( void )
{
	uint8_t temp = PMIC.CTRL | PMIC_IVSEL_bm;
    1e72:	e0 ea       	ldi	r30, 0xA0	; 160
    1e74:	f0 e0       	ldi	r31, 0x00	; 0
    1e76:	82 81       	ldd	r24, Z+2	; 0x02
    1e78:	80 64       	ori	r24, 0x40	; 64
	CCP = CCP_IOREG_gc;
    1e7a:	98 ed       	ldi	r25, 0xD8	; 216
    1e7c:	94 bf       	out	0x34, r25	; 52
	PMIC.CTRL = temp;
    1e7e:	82 83       	std	Z+2, r24	; 0x02
}
    1e80:	08 95       	ret

00001e82 <PMIC_SetVectorLocationToApplication>:
 *  Change Protection register before writing the CTRL register. Interrupts are
 *  automatically ignored during the change enable period.
 */
void PMIC_SetVectorLocationToApplication( void )
{
	uint8_t temp = PMIC.CTRL & ~PMIC_IVSEL_bm;
    1e82:	e0 ea       	ldi	r30, 0xA0	; 160
    1e84:	f0 e0       	ldi	r31, 0x00	; 0
    1e86:	82 81       	ldd	r24, Z+2	; 0x02
    1e88:	8f 7b       	andi	r24, 0xBF	; 191
	CCP = CCP_IOREG_gc;
    1e8a:	98 ed       	ldi	r25, 0xD8	; 216
    1e8c:	94 bf       	out	0x34, r25	; 52
	PMIC.CTRL = temp;
    1e8e:	82 83       	std	Z+2, r24	; 0x02
}
    1e90:	08 95       	ret

00001e92 <prompt>:
char textline[LINE_BUFFER_SIZE];
uint8_t char_counter = 0;

void prompt() 
{
	printPgmString(PSTR("TinyG>> "));
    1e92:	81 ee       	ldi	r24, 0xE1	; 225
    1e94:	93 e0       	ldi	r25, 0x03	; 3
    1e96:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
}
    1e9a:	08 95       	ret

00001e9c <sp_process>:
}

/* sp_process() - process serial prototol */

void sp_process()
{
    1e9c:	1f 93       	push	r17
    1e9e:	4c c0       	rjmp	.+152    	; 0x1f38 <sp_process+0x9c>
	char c;

	while((c = serialRead()) != 0x04) {
		if (TRUE) {							// echo mode
			printByte(c);
    1ea0:	81 2f       	mov	r24, r17
    1ea2:	0e 94 0a 16 	call	0x2c14	; 0x2c14 <serialWrite>
		}			
		if((c == '\r') || (c == '\n') || (c == ';')) {  // Line complete. Execute!
    1ea6:	1d 30       	cpi	r17, 0x0D	; 13
    1ea8:	21 f0       	breq	.+8      	; 0x1eb2 <sp_process+0x16>
    1eaa:	1a 30       	cpi	r17, 0x0A	; 10
    1eac:	11 f0       	breq	.+4      	; 0x1eb2 <sp_process+0x16>
    1eae:	1b 33       	cpi	r17, 0x3B	; 59
    1eb0:	f9 f4       	brne	.+62     	; 0x1ef0 <sp_process+0x54>
			textline[char_counter] = 0;				// terminate and echo the string
    1eb2:	e0 91 32 20 	lds	r30, 0x2032
    1eb6:	f0 e0       	ldi	r31, 0x00	; 0
    1eb8:	ec 57       	subi	r30, 0x7C	; 124
    1eba:	ff 4d       	sbci	r31, 0xDF	; 223
    1ebc:	10 82       	st	Z, r1
			printPgmString(PSTR("\r\n EXEC>> "));
    1ebe:	8f ea       	ldi	r24, 0xAF	; 175
    1ec0:	93 e0       	ldi	r25, 0x03	; 3
    1ec2:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
			printString(textline);
    1ec6:	84 e8       	ldi	r24, 0x84	; 132
    1ec8:	90 e2       	ldi	r25, 0x20	; 32
    1eca:	0e 94 30 16 	call	0x2c60	; 0x2c60 <printString>
			printPgmString(PSTR("\r\n"));
    1ece:	8c ea       	ldi	r24, 0xAC	; 172
    1ed0:	93 e0       	ldi	r25, 0x03	; 3
    1ed2:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
			gc_execute_line(textline);				// execute the command
    1ed6:	84 e8       	ldi	r24, 0x84	; 132
    1ed8:	90 e2       	ldi	r25, 0x20	; 32
    1eda:	0e 94 95 03 	call	0x72a	; 0x72a <gc_execute_line>
			char_counter = 0;
    1ede:	10 92 32 20 	sts	0x2032, r1
			textline[char_counter] = 0;				// reset the buffer
    1ee2:	10 92 84 20 	sts	0x2084, r1
char textline[LINE_BUFFER_SIZE];
uint8_t char_counter = 0;

void prompt() 
{
	printPgmString(PSTR("TinyG>> "));
    1ee6:	81 ee       	ldi	r24, 0xE1	; 225
    1ee8:	93 e0       	ldi	r25, 0x03	; 3
    1eea:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
    1eee:	24 c0       	rjmp	.+72     	; 0x1f38 <sp_process+0x9c>
			printPgmString(PSTR("\r\n"));
			gc_execute_line(textline);				// execute the command
			char_counter = 0;
			textline[char_counter] = 0;				// reset the buffer
      		prompt();							
		} else if ((c == 0x08) || (c == 0x7F)) {  	// backspace or delete
    1ef0:	18 30       	cpi	r17, 0x08	; 8
    1ef2:	11 f0       	breq	.+4      	; 0x1ef8 <sp_process+0x5c>
    1ef4:	1f 37       	cpi	r17, 0x7F	; 127
    1ef6:	51 f4       	brne	.+20     	; 0x1f0c <sp_process+0x70>
			textline[--char_counter] = 0;
    1ef8:	e0 91 32 20 	lds	r30, 0x2032
    1efc:	e1 50       	subi	r30, 0x01	; 1
    1efe:	e0 93 32 20 	sts	0x2032, r30
    1f02:	f0 e0       	ldi	r31, 0x00	; 0
    1f04:	ec 57       	subi	r30, 0x7C	; 124
    1f06:	ff 4d       	sbci	r31, 0xDF	; 223
    1f08:	10 82       	st	Z, r1
    1f0a:	16 c0       	rjmp	.+44     	; 0x1f38 <sp_process+0x9c>
		} else if (c <= ' ') { 						// throw away WS & ctrl chars
    1f0c:	11 32       	cpi	r17, 0x21	; 33
    1f0e:	a0 f0       	brcs	.+40     	; 0x1f38 <sp_process+0x9c>
		} else if (c >= 'a' && c <= 'z') {			// convert lower to upper
    1f10:	81 2f       	mov	r24, r17
    1f12:	81 56       	subi	r24, 0x61	; 97
    1f14:	90 91 32 20 	lds	r25, 0x2032
    1f18:	8a 31       	cpi	r24, 0x1A	; 26
    1f1a:	30 f4       	brcc	.+12     	; 0x1f28 <sp_process+0x8c>
			textline[char_counter++] = c-'a'+'A';
    1f1c:	e9 2f       	mov	r30, r25
    1f1e:	f0 e0       	ldi	r31, 0x00	; 0
    1f20:	ec 57       	subi	r30, 0x7C	; 124
    1f22:	ff 4d       	sbci	r31, 0xDF	; 223
    1f24:	10 52       	subi	r17, 0x20	; 32
    1f26:	04 c0       	rjmp	.+8      	; 0x1f30 <sp_process+0x94>
		} else {
			textline[char_counter++] = c;
    1f28:	e9 2f       	mov	r30, r25
    1f2a:	f0 e0       	ldi	r31, 0x00	; 0
    1f2c:	ec 57       	subi	r30, 0x7C	; 124
    1f2e:	ff 4d       	sbci	r31, 0xDF	; 223
    1f30:	10 83       	st	Z, r17
    1f32:	9f 5f       	subi	r25, 0xFF	; 255
    1f34:	90 93 32 20 	sts	0x2032, r25

void sp_process()
{
	char c;

	while((c = serialRead()) != 0x04) {
    1f38:	0e 94 19 16 	call	0x2c32	; 0x2c32 <serialRead>
    1f3c:	18 2f       	mov	r17, r24
    1f3e:	84 30       	cpi	r24, 0x04	; 4
    1f40:	09 f0       	breq	.+2      	; 0x1f44 <sp_process+0xa8>
    1f42:	ae cf       	rjmp	.-164    	; 0x1ea0 <sp_process+0x4>
			textline[char_counter++] = c-'a'+'A';
		} else {
			textline[char_counter++] = c;
		}
	}
}
    1f44:	1f 91       	pop	r17
    1f46:	08 95       	ret

00001f48 <sp_init>:
	printPgmString(PSTR("TinyG>> "));
}

void sp_init() 
{
	beginSerial(USB_BAUD_RATE);
    1f48:	60 e0       	ldi	r22, 0x00	; 0
    1f4a:	72 ec       	ldi	r23, 0xC2	; 194
    1f4c:	81 e0       	ldi	r24, 0x01	; 1
    1f4e:	90 e0       	ldi	r25, 0x00	; 0
    1f50:	0e 94 8a 15 	call	0x2b14	; 0x2b14 <beginSerial>
	printPgmString(PSTR("\r\nTinyG [TEST MODE] - Version "));
    1f54:	82 ec       	ldi	r24, 0xC2	; 194
    1f56:	93 e0       	ldi	r25, 0x03	; 3
    1f58:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
	printPgmString(PSTR(TINYG_VERSION));
    1f5c:	8d eb       	ldi	r24, 0xBD	; 189
    1f5e:	93 e0       	ldi	r25, 0x03	; 3
    1f60:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
	printPgmString(PSTR("\r\n"));
    1f64:	8a eb       	ldi	r24, 0xBA	; 186
    1f66:	93 e0       	ldi	r25, 0x03	; 3
    1f68:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
	textline[0] = 0;		// initialize line buffer
    1f6c:	10 92 84 20 	sts	0x2084, r1
char textline[LINE_BUFFER_SIZE];
uint8_t char_counter = 0;

void prompt() 
{
	printPgmString(PSTR("TinyG>> "));
    1f70:	81 ee       	ldi	r24, 0xE1	; 225
    1f72:	93 e0       	ldi	r25, 0x03	; 3
    1f74:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
	printPgmString(PSTR("\r\nTinyG [TEST MODE] - Version "));
	printPgmString(PSTR(TINYG_VERSION));
	printPgmString(PSTR("\r\n"));
	textline[0] = 0;		// initialize line buffer
	prompt();
}
    1f78:	08 95       	ret

00001f7a <spindle_init>:
	See config.h for settings
*/

void spindle_init()
{
	SPINDLE_ENABLE_PORT.DIRSET = SPINDLE_ENABLE_BIT_bm;
    1f7a:	e0 e6       	ldi	r30, 0x60	; 96
    1f7c:	f6 e0       	ldi	r31, 0x06	; 6
    1f7e:	80 e4       	ldi	r24, 0x40	; 64
    1f80:	81 83       	std	Z+1, r24	; 0x01
	SPINDLE_DIRECTION_PORT.DIRSET = SPINDLE_DIRECTION_BIT_bm;
    1f82:	80 e8       	ldi	r24, 0x80	; 128
    1f84:	81 83       	std	Z+1, r24	; 0x01
}
    1f86:	08 95       	ret

00001f88 <spindle_run>:

void spindle_run(int direction, uint32_t rpm) 
{
	if(direction >= 0) {
    1f88:	97 fd       	sbrc	r25, 7
    1f8a:	05 c0       	rjmp	.+10     	; 0x1f96 <spindle_run+0xe>
    	SPINDLE_DIRECTION_PORT.OUTSET = SPINDLE_DIRECTION_BIT_bm;
    1f8c:	80 e8       	ldi	r24, 0x80	; 128
    1f8e:	e0 e6       	ldi	r30, 0x60	; 96
    1f90:	f6 e0       	ldi	r31, 0x06	; 6
    1f92:	85 83       	std	Z+5, r24	; 0x05
    1f94:	04 c0       	rjmp	.+8      	; 0x1f9e <spindle_run+0x16>
	} else {
    	SPINDLE_DIRECTION_PORT.OUTCLR = SPINDLE_DIRECTION_BIT_bm;
    1f96:	80 e8       	ldi	r24, 0x80	; 128
    1f98:	e0 e6       	ldi	r30, 0x60	; 96
    1f9a:	f6 e0       	ldi	r31, 0x06	; 6
    1f9c:	86 83       	std	Z+6, r24	; 0x06
	}
	SPINDLE_ENABLE_PORT.OUTSET = SPINDLE_ENABLE_BIT_bm;
    1f9e:	80 e4       	ldi	r24, 0x40	; 64
    1fa0:	e0 e6       	ldi	r30, 0x60	; 96
    1fa2:	f6 e0       	ldi	r31, 0x06	; 6
    1fa4:	85 83       	std	Z+5, r24	; 0x05
}
    1fa6:	08 95       	ret

00001fa8 <spindle_stop>:

void spindle_stop()
{
	SPINDLE_ENABLE_PORT.OUTCLR = SPINDLE_ENABLE_BIT_bm;
    1fa8:	80 e4       	ldi	r24, 0x40	; 64
    1faa:	e0 e6       	ldi	r30, 0x60	; 96
    1fac:	f6 e0       	ldi	r31, 0x06	; 6
    1fae:	86 83       	std	Z+6, r24	; 0x06
}
    1fb0:	08 95       	ret

00001fb2 <st_motor_test>:


/* st_motor_test() - test motor subsystem */

void st_motor_test() {
	ax.x.counter = 0x00001000;					// number of steps
    1fb2:	80 e0       	ldi	r24, 0x00	; 0
    1fb4:	90 e1       	ldi	r25, 0x10	; 16
    1fb6:	a0 e0       	ldi	r26, 0x00	; 0
    1fb8:	b0 e0       	ldi	r27, 0x00	; 0
    1fba:	80 93 07 21 	sts	0x2107, r24
    1fbe:	90 93 08 21 	sts	0x2108, r25
    1fc2:	a0 93 09 21 	sts	0x2109, r26
    1fc6:	b0 93 0a 21 	sts	0x210A, r27
	ax.x.timer->CTRLA = TC_CLK_DIV_1;			// clock division ratio
    1fca:	e0 91 22 21 	lds	r30, 0x2122
    1fce:	f0 91 23 21 	lds	r31, 0x2123
    1fd2:	21 e0       	ldi	r18, 0x01	; 1
    1fd4:	20 83       	st	Z, r18
	ax.x.timer->PERH = 0x10;					// step rate (period) high
    1fd6:	e0 91 22 21 	lds	r30, 0x2122
    1fda:	f0 91 23 21 	lds	r31, 0x2123
    1fde:	80 e1       	ldi	r24, 0x10	; 16
    1fe0:	87 a3       	std	Z+39, r24	; 0x27
	ax.x.timer->PERL = 0x00;					// step rate (period) low
    1fe2:	16 a2       	std	Z+38, r1	; 0x26

	ax.y.counter = 0x00000800;					// number of steps
    1fe4:	80 e0       	ldi	r24, 0x00	; 0
    1fe6:	98 e0       	ldi	r25, 0x08	; 8
    1fe8:	a0 e0       	ldi	r26, 0x00	; 0
    1fea:	b0 e0       	ldi	r27, 0x00	; 0
    1fec:	80 93 24 21 	sts	0x2124, r24
    1ff0:	90 93 25 21 	sts	0x2125, r25
    1ff4:	a0 93 26 21 	sts	0x2126, r26
    1ff8:	b0 93 27 21 	sts	0x2127, r27
	ax.y.timer->CTRLA = TC_CLK_DIV_1;			// clock division ratio
    1ffc:	e0 91 3f 21 	lds	r30, 0x213F
    2000:	f0 91 40 21 	lds	r31, 0x2140
    2004:	20 83       	st	Z, r18
	ax.y.timer->PERH = 0x20;					// step rate (period) high
    2006:	e0 91 3f 21 	lds	r30, 0x213F
    200a:	f0 91 40 21 	lds	r31, 0x2140
    200e:	80 e2       	ldi	r24, 0x20	; 32
    2010:	87 a3       	std	Z+39, r24	; 0x27
	ax.y.timer->PERL = 0x00;					// step rate (period) low
    2012:	16 a2       	std	Z+38, r1	; 0x26

	ax.z.counter = 0x00000600;					// number of steps
    2014:	80 e0       	ldi	r24, 0x00	; 0
    2016:	96 e0       	ldi	r25, 0x06	; 6
    2018:	a0 e0       	ldi	r26, 0x00	; 0
    201a:	b0 e0       	ldi	r27, 0x00	; 0
    201c:	80 93 41 21 	sts	0x2141, r24
    2020:	90 93 42 21 	sts	0x2142, r25
    2024:	a0 93 43 21 	sts	0x2143, r26
    2028:	b0 93 44 21 	sts	0x2144, r27
	ax.z.timer->CTRLA = TC_CLK_DIV_1;			// clock division ratio
    202c:	e0 91 5c 21 	lds	r30, 0x215C
    2030:	f0 91 5d 21 	lds	r31, 0x215D
    2034:	20 83       	st	Z, r18
	ax.z.timer->PERH = 0x30;					// step rate (period) high
    2036:	e0 91 5c 21 	lds	r30, 0x215C
    203a:	f0 91 5d 21 	lds	r31, 0x215D
    203e:	80 e3       	ldi	r24, 0x30	; 48
    2040:	87 a3       	std	Z+39, r24	; 0x27
	ax.z.timer->PERL = 0x00;					// step rate (period) low
    2042:	16 a2       	std	Z+38, r1	; 0x26

	ax.a.counter = 0x00000400;					// number of steps
    2044:	80 e0       	ldi	r24, 0x00	; 0
    2046:	94 e0       	ldi	r25, 0x04	; 4
    2048:	a0 e0       	ldi	r26, 0x00	; 0
    204a:	b0 e0       	ldi	r27, 0x00	; 0
    204c:	80 93 5e 21 	sts	0x215E, r24
    2050:	90 93 5f 21 	sts	0x215F, r25
    2054:	a0 93 60 21 	sts	0x2160, r26
    2058:	b0 93 61 21 	sts	0x2161, r27
	ax.a.timer->CTRLA = TC_CLK_DIV_1;			// clock division ratio
    205c:	e0 91 79 21 	lds	r30, 0x2179
    2060:	f0 91 7a 21 	lds	r31, 0x217A
    2064:	20 83       	st	Z, r18
	ax.a.timer->PERH = 0x40;					// step rate (period) high
    2066:	e0 91 79 21 	lds	r30, 0x2179
    206a:	f0 91 7a 21 	lds	r31, 0x217A
    206e:	80 e4       	ldi	r24, 0x40	; 64
    2070:	87 a3       	std	Z+39, r24	; 0x27
	ax.a.timer->PERL = 0x00;					// step rate (period) low
    2072:	16 a2       	std	Z+38, r1	; 0x26

	ax.active_axes |= (X_BIT_bm | Y_BIT_bm | Z_BIT_bm | A_BIT_bm);
    2074:	80 91 7b 21 	lds	r24, 0x217B
    2078:	8f 60       	ori	r24, 0x0F	; 15
    207a:	80 93 7b 21 	sts	0x217B, r24
}
    207e:	08 95       	ret

00002080 <st_init>:
   Note: high level interrupts must be enabled in main()

*/

void st_init()
{
    2080:	6f 92       	push	r6
    2082:	7f 92       	push	r7
    2084:	8f 92       	push	r8
    2086:	9f 92       	push	r9
    2088:	af 92       	push	r10
    208a:	bf 92       	push	r11
    208c:	cf 92       	push	r12
    208e:	df 92       	push	r13
    2090:	ef 92       	push	r14
    2092:	ff 92       	push	r15
    2094:	0f 93       	push	r16
    2096:	1f 93       	push	r17
	ax.active_axes = 0;							// clear all active bits
    2098:	10 92 7b 21 	sts	0x217B, r1
	busy = FALSE;								// clear the busy flag
    209c:	10 92 05 21 	sts	0x2105, r1
    20a0:	10 92 06 21 	sts	0x2106, r1

 /* initialize X axis */
 	// operating variables
	ax.x.counter = 0;							// down counts timer steps 
    20a4:	10 92 07 21 	sts	0x2107, r1
    20a8:	10 92 08 21 	sts	0x2108, r1
    20ac:	10 92 09 21 	sts	0x2109, r1
    20b0:	10 92 0a 21 	sts	0x210A, r1

	// configuration variables
	ax.x.microsteps = X_MICROSTEPS;
    20b4:	78 e0       	ldi	r23, 0x08	; 8
    20b6:	70 93 0b 21 	sts	0x210B, r23
	ax.x.max_seek_rate = X_SEEK_WHOLE_STEPS_PER_SEC;
    20ba:	0f 2e       	mov	r0, r31
    20bc:	f0 e0       	ldi	r31, 0x00	; 0
    20be:	6f 2e       	mov	r6, r31
    20c0:	f0 e0       	ldi	r31, 0x00	; 0
    20c2:	7f 2e       	mov	r7, r31
    20c4:	f8 ec       	ldi	r31, 0xC8	; 200
    20c6:	8f 2e       	mov	r8, r31
    20c8:	f4 e4       	ldi	r31, 0x44	; 68
    20ca:	9f 2e       	mov	r9, r31
    20cc:	f0 2d       	mov	r31, r0
    20ce:	60 92 0c 21 	sts	0x210C, r6
    20d2:	70 92 0d 21 	sts	0x210D, r7
    20d6:	80 92 0e 21 	sts	0x210E, r8
    20da:	90 92 0f 21 	sts	0x210F, r9
	ax.x.max_seek_steps = X_STEPS_PER_MM / DEFAULT_FEEDRATE;
    20de:	2a e1       	ldi	r18, 0x1A	; 26
    20e0:	32 e6       	ldi	r19, 0x62	; 98
    20e2:	46 e0       	ldi	r20, 0x06	; 6
    20e4:	50 e4       	ldi	r21, 0x40	; 64
    20e6:	20 93 10 21 	sts	0x2110, r18
    20ea:	30 93 11 21 	sts	0x2111, r19
    20ee:	40 93 12 21 	sts	0x2112, r20
    20f2:	50 93 13 21 	sts	0x2113, r21
	ax.x.max_feed_rate = DEFAULT_FEEDRATE;
    20f6:	0f 2e       	mov	r0, r31
    20f8:	f0 e0       	ldi	r31, 0x00	; 0
    20fa:	af 2e       	mov	r10, r31
    20fc:	f0 e0       	ldi	r31, 0x00	; 0
    20fe:	bf 2e       	mov	r11, r31
    2100:	f6 e9       	ldi	r31, 0x96	; 150
    2102:	cf 2e       	mov	r12, r31
    2104:	f3 e4       	ldi	r31, 0x43	; 67
    2106:	df 2e       	mov	r13, r31
    2108:	f0 2d       	mov	r31, r0
    210a:	a0 92 14 21 	sts	0x2114, r10
    210e:	b0 92 15 21 	sts	0x2115, r11
    2112:	c0 92 16 21 	sts	0x2116, r12
    2116:	d0 92 17 21 	sts	0x2117, r13
	ax.x.max_feed_steps = X_STEPS_PER_MM / DEFAULT_FEEDRATE;
    211a:	20 93 18 21 	sts	0x2118, r18
    211e:	30 93 19 21 	sts	0x2119, r19
    2122:	40 93 1a 21 	sts	0x211A, r20
    2126:	50 93 1b 21 	sts	0x211B, r21
	ax.x.steps_per_mm = X_STEPS_PER_MM;
    212a:	0f 2e       	mov	r0, r31
    212c:	f6 ef       	ldi	r31, 0xF6	; 246
    212e:	ef 2e       	mov	r14, r31
    2130:	fa e7       	ldi	r31, 0x7A	; 122
    2132:	ff 2e       	mov	r15, r31
    2134:	fd e1       	ldi	r31, 0x1D	; 29
    2136:	0f 2f       	mov	r16, r31
    2138:	f4 e4       	ldi	r31, 0x44	; 68
    213a:	1f 2f       	mov	r17, r31
    213c:	f0 2d       	mov	r31, r0
    213e:	e0 92 1c 21 	sts	0x211C, r14
    2142:	f0 92 1d 21 	sts	0x211D, r15
    2146:	00 93 1e 21 	sts	0x211E, r16
    214a:	10 93 1f 21 	sts	0x211F, r17

	// motor control port bound to structure 
	ax.x.port = &X_MOTOR_PORT;
    214e:	e0 e0       	ldi	r30, 0x00	; 0
    2150:	f6 e0       	ldi	r31, 0x06	; 6
    2152:	e0 93 20 21 	sts	0x2120, r30
    2156:	f0 93 21 21 	sts	0x2121, r31
	ax.x.port->DIR = X_MOTOR_PORT_DIR_gm;		// set inputs and outputs
    215a:	6f e3       	ldi	r22, 0x3F	; 63
    215c:	60 83       	st	Z, r22
	ax.x.port->OUT = 0;							// set port bits to zero initially
    215e:	14 82       	std	Z+4, r1	; 0x04
	ax.x.port->OUT |= MICROSTEP_EIGHTH_bm;		// set microstep bits to eighth
    2160:	84 81       	ldd	r24, Z+4	; 0x04
    2162:	88 61       	ori	r24, 0x18	; 24
    2164:	84 83       	std	Z+4, r24	; 0x04

	// motor control timer channel bound to structure
	ax.x.timer = &X_TIMER;
    2166:	e0 e0       	ldi	r30, 0x00	; 0
    2168:	f8 e0       	ldi	r31, 0x08	; 8
    216a:	e0 93 22 21 	sts	0x2122, r30
    216e:	f0 93 23 21 	sts	0x2123, r31
	ax.x.timer->CTRLA = TC_CLK_OFF;				// turn motor off
    2172:	10 82       	st	Z, r1
	ax.x.timer->CTRLB = TC_WGMODE;				// waveform generation mode
    2174:	11 82       	std	Z+1, r1	; 0x01
	ax.x.timer->INTCTRLA = TC_OVFINTLVL;		// interrupt mode
    2176:	93 e0       	ldi	r25, 0x03	; 3
    2178:	96 83       	std	Z+6, r25	; 0x06
	ax.x.timer->PERH = 0x00;					// period high
    217a:	17 a2       	std	Z+39, r1	; 0x27
	ax.x.timer->PERL = 0x00;					// period low
    217c:	16 a2       	std	Z+38, r1	; 0x26

 /* initialize Y axis */
	ax.y.counter = 0;
    217e:	10 92 24 21 	sts	0x2124, r1
    2182:	10 92 25 21 	sts	0x2125, r1
    2186:	10 92 26 21 	sts	0x2126, r1
    218a:	10 92 27 21 	sts	0x2127, r1

	ax.y.microsteps = Y_MICROSTEPS;
    218e:	70 93 28 21 	sts	0x2128, r23
	ax.y.max_seek_rate = Y_SEEK_WHOLE_STEPS_PER_SEC;
    2192:	60 92 29 21 	sts	0x2129, r6
    2196:	70 92 2a 21 	sts	0x212A, r7
    219a:	80 92 2b 21 	sts	0x212B, r8
    219e:	90 92 2c 21 	sts	0x212C, r9
	ax.y.max_seek_steps = Y_STEPS_PER_MM / DEFAULT_FEEDRATE;
    21a2:	20 93 2d 21 	sts	0x212D, r18
    21a6:	30 93 2e 21 	sts	0x212E, r19
    21aa:	40 93 2f 21 	sts	0x212F, r20
    21ae:	50 93 30 21 	sts	0x2130, r21
	ax.y.max_feed_rate = DEFAULT_FEEDRATE;
    21b2:	a0 92 31 21 	sts	0x2131, r10
    21b6:	b0 92 32 21 	sts	0x2132, r11
    21ba:	c0 92 33 21 	sts	0x2133, r12
    21be:	d0 92 34 21 	sts	0x2134, r13
	ax.y.max_feed_steps = Y_STEPS_PER_MM / DEFAULT_FEEDRATE;
    21c2:	20 93 35 21 	sts	0x2135, r18
    21c6:	30 93 36 21 	sts	0x2136, r19
    21ca:	40 93 37 21 	sts	0x2137, r20
    21ce:	50 93 38 21 	sts	0x2138, r21
	ax.y.steps_per_mm = Y_STEPS_PER_MM;
    21d2:	e0 92 39 21 	sts	0x2139, r14
    21d6:	f0 92 3a 21 	sts	0x213A, r15
    21da:	00 93 3b 21 	sts	0x213B, r16
    21de:	10 93 3c 21 	sts	0x213C, r17

	ax.y.port = &Y_MOTOR_PORT;					// bind port to structure 
    21e2:	e0 ea       	ldi	r30, 0xA0	; 160
    21e4:	f6 e0       	ldi	r31, 0x06	; 6
    21e6:	e0 93 3d 21 	sts	0x213D, r30
    21ea:	f0 93 3e 21 	sts	0x213E, r31
	ax.y.port->DIR = Y_MOTOR_PORT_DIR_gm;
    21ee:	60 83       	st	Z, r22
	ax.y.port->OUT = 0;							// set port bits to zero initially
    21f0:	14 82       	std	Z+4, r1	; 0x04
	ax.y.port->OUT |= MICROSTEP_EIGHTH_bm;		// set microstep bits to eighth
    21f2:	84 81       	ldd	r24, Z+4	; 0x04
    21f4:	88 61       	ori	r24, 0x18	; 24
    21f6:	84 83       	std	Z+4, r24	; 0x04

	ax.y.timer = &Y_TIMER;
    21f8:	e0 e0       	ldi	r30, 0x00	; 0
    21fa:	f9 e0       	ldi	r31, 0x09	; 9
    21fc:	e0 93 3f 21 	sts	0x213F, r30
    2200:	f0 93 40 21 	sts	0x2140, r31
	ax.y.timer->CTRLA = TC_CLK_OFF;				// default division ratio
    2204:	10 82       	st	Z, r1
	ax.y.timer->CTRLB = TC_WGMODE;				// waveform generation mode
    2206:	11 82       	std	Z+1, r1	; 0x01
	ax.y.timer->INTCTRLA = TC_OVFINTLVL;		// interrupt mode
    2208:	96 83       	std	Z+6, r25	; 0x06
	ax.y.timer->PERH = 0x00;					// period high
    220a:	17 a2       	std	Z+39, r1	; 0x27
	ax.y.timer->PERL = 0x00;					// period low
    220c:	16 a2       	std	Z+38, r1	; 0x26

/* initialize Z axis */
	ax.z.counter = 0;
    220e:	10 92 41 21 	sts	0x2141, r1
    2212:	10 92 42 21 	sts	0x2142, r1
    2216:	10 92 43 21 	sts	0x2143, r1
    221a:	10 92 44 21 	sts	0x2144, r1

	ax.z.microsteps = Z_MICROSTEPS;
    221e:	e7 e0       	ldi	r30, 0x07	; 7
    2220:	f1 e2       	ldi	r31, 0x21	; 33
    2222:	76 af       	std	Z+62, r23	; 0x3e
	ax.z.max_seek_rate = Z_SEEK_WHOLE_STEPS_PER_SEC;
    2224:	60 92 46 21 	sts	0x2146, r6
    2228:	70 92 47 21 	sts	0x2147, r7
    222c:	80 92 48 21 	sts	0x2148, r8
    2230:	90 92 49 21 	sts	0x2149, r9
	ax.z.max_seek_steps = Z_STEPS_PER_MM / DEFAULT_FEEDRATE;
    2234:	20 93 4a 21 	sts	0x214A, r18
    2238:	30 93 4b 21 	sts	0x214B, r19
    223c:	40 93 4c 21 	sts	0x214C, r20
    2240:	50 93 4d 21 	sts	0x214D, r21
	ax.z.max_feed_rate = DEFAULT_FEEDRATE;
    2244:	a0 92 4e 21 	sts	0x214E, r10
    2248:	b0 92 4f 21 	sts	0x214F, r11
    224c:	c0 92 50 21 	sts	0x2150, r12
    2250:	d0 92 51 21 	sts	0x2151, r13
	ax.z.max_feed_steps = Z_STEPS_PER_MM / DEFAULT_FEEDRATE;
    2254:	20 93 52 21 	sts	0x2152, r18
    2258:	30 93 53 21 	sts	0x2153, r19
    225c:	40 93 54 21 	sts	0x2154, r20
    2260:	50 93 55 21 	sts	0x2155, r21
	ax.z.steps_per_mm = Z_STEPS_PER_MM;
    2264:	e0 92 56 21 	sts	0x2156, r14
    2268:	f0 92 57 21 	sts	0x2157, r15
    226c:	00 93 58 21 	sts	0x2158, r16
    2270:	10 93 59 21 	sts	0x2159, r17

	ax.z.port = &Z_MOTOR_PORT;
    2274:	e0 e8       	ldi	r30, 0x80	; 128
    2276:	f6 e0       	ldi	r31, 0x06	; 6
    2278:	e0 93 5a 21 	sts	0x215A, r30
    227c:	f0 93 5b 21 	sts	0x215B, r31
	ax.z.port->DIR = Z_MOTOR_PORT_DIR_gm;
    2280:	60 83       	st	Z, r22
	ax.z.port->OUT = 0;							// set port bits to zero initially
    2282:	14 82       	std	Z+4, r1	; 0x04
	ax.z.port->OUT |= MICROSTEP_EIGHTH_bm;		// set microstep bits to eighth
    2284:	84 81       	ldd	r24, Z+4	; 0x04
    2286:	88 61       	ori	r24, 0x18	; 24
    2288:	84 83       	std	Z+4, r24	; 0x04

	ax.z.timer = &Z_TIMER;
    228a:	e0 e0       	ldi	r30, 0x00	; 0
    228c:	fa e0       	ldi	r31, 0x0A	; 10
    228e:	e0 93 5c 21 	sts	0x215C, r30
    2292:	f0 93 5d 21 	sts	0x215D, r31
	ax.z.timer->CTRLA = TC_CLK_OFF;				// timer clock control or division
    2296:	10 82       	st	Z, r1
	ax.z.timer->CTRLB = TC_WGMODE;				// waveform generation mode
    2298:	11 82       	std	Z+1, r1	; 0x01
	ax.z.timer->INTCTRLA = TC_OVFINTLVL;		// interrupt mode
    229a:	96 83       	std	Z+6, r25	; 0x06
	ax.z.timer->PERH = 0x00;					// period high
    229c:	17 a2       	std	Z+39, r1	; 0x27
	ax.z.timer->PERL = 0x00;					// period low
    229e:	16 a2       	std	Z+38, r1	; 0x26

/* initialize A axis */
	ax.a.counter = 0;
    22a0:	10 92 5e 21 	sts	0x215E, r1
    22a4:	10 92 5f 21 	sts	0x215F, r1
    22a8:	10 92 60 21 	sts	0x2160, r1
    22ac:	10 92 61 21 	sts	0x2161, r1

	ax.a.microsteps = A_MICROSTEPS;
    22b0:	70 93 62 21 	sts	0x2162, r23
	ax.a.max_seek_rate = A_SEEK_WHOLE_STEPS_PER_SEC;
    22b4:	60 92 63 21 	sts	0x2163, r6
    22b8:	70 92 64 21 	sts	0x2164, r7
    22bc:	80 92 65 21 	sts	0x2165, r8
    22c0:	90 92 66 21 	sts	0x2166, r9
	ax.a.max_seek_steps = A_STEPS_PER_MM / DEFAULT_FEEDRATE;
    22c4:	20 93 67 21 	sts	0x2167, r18
    22c8:	30 93 68 21 	sts	0x2168, r19
    22cc:	40 93 69 21 	sts	0x2169, r20
    22d0:	50 93 6a 21 	sts	0x216A, r21
	ax.a.max_feed_rate = DEFAULT_FEEDRATE;
    22d4:	a0 92 6b 21 	sts	0x216B, r10
    22d8:	b0 92 6c 21 	sts	0x216C, r11
    22dc:	c0 92 6d 21 	sts	0x216D, r12
    22e0:	d0 92 6e 21 	sts	0x216E, r13
	ax.a.max_feed_steps = A_STEPS_PER_MM / DEFAULT_FEEDRATE;
    22e4:	20 93 6f 21 	sts	0x216F, r18
    22e8:	30 93 70 21 	sts	0x2170, r19
    22ec:	40 93 71 21 	sts	0x2171, r20
    22f0:	50 93 72 21 	sts	0x2172, r21
	ax.a.steps_per_mm = A_STEPS_PER_MM;
    22f4:	e0 92 73 21 	sts	0x2173, r14
    22f8:	f0 92 74 21 	sts	0x2174, r15
    22fc:	00 93 75 21 	sts	0x2175, r16
    2300:	10 93 76 21 	sts	0x2176, r17

	ax.a.port = &A_MOTOR_PORT;
    2304:	e0 e6       	ldi	r30, 0x60	; 96
    2306:	f6 e0       	ldi	r31, 0x06	; 6
    2308:	e0 93 77 21 	sts	0x2177, r30
    230c:	f0 93 78 21 	sts	0x2178, r31
	ax.a.port->DIR = A_MOTOR_PORT_DIR_gm;
    2310:	60 83       	st	Z, r22
	ax.a.port->OUT = 0;							// set port bits to zero initially
    2312:	14 82       	std	Z+4, r1	; 0x04
	ax.a.port->OUT |= MICROSTEP_EIGHTH_bm;		// set microstep bits to eighth
    2314:	84 81       	ldd	r24, Z+4	; 0x04
    2316:	88 61       	ori	r24, 0x18	; 24
    2318:	84 83       	std	Z+4, r24	; 0x04

	ax.a.timer = &A_TIMER;
    231a:	e0 e0       	ldi	r30, 0x00	; 0
    231c:	fb e0       	ldi	r31, 0x0B	; 11
    231e:	e0 93 79 21 	sts	0x2179, r30
    2322:	f0 93 7a 21 	sts	0x217A, r31
	ax.a.timer->CTRLA = TC_CLK_OFF;				
    2326:	10 82       	st	Z, r1
	ax.a.timer->CTRLB = TC_WGMODE;				// waveform generation mode
    2328:	11 82       	std	Z+1, r1	; 0x01
	ax.a.timer->INTCTRLA = TC_OVFINTLVL;		// interrupt mode
    232a:	96 83       	std	Z+6, r25	; 0x06
	ax.a.timer->PERH = 0x00;					// period high
    232c:	17 a2       	std	Z+39, r1	; 0x27
	ax.a.timer->PERL = 0x00;					// period low
    232e:	16 a2       	std	Z+38, r1	; 0x26

	st_motor_test();							// run the startup motor test
    2330:	0e 94 d9 0f 	call	0x1fb2	; 0x1fb2 <st_motor_test>
}
    2334:	1f 91       	pop	r17
    2336:	0f 91       	pop	r16
    2338:	ff 90       	pop	r15
    233a:	ef 90       	pop	r14
    233c:	df 90       	pop	r13
    233e:	cf 90       	pop	r12
    2340:	bf 90       	pop	r11
    2342:	af 90       	pop	r10
    2344:	9f 90       	pop	r9
    2346:	8f 90       	pop	r8
    2348:	7f 90       	pop	r7
    234a:	6f 90       	pop	r6
    234c:	08 95       	ret

0000234e <_st_load_timer>:
  for power management reasons, and possibly revert the microsteps to whole
  if necessary to do this.  
*/

void _st_load_timer(struct Axis *A, uint32_t step_rate, uint32_t microseconds) 
{
    234e:	cf 92       	push	r12
    2350:	df 92       	push	r13
    2352:	ef 92       	push	r14
    2354:	ff 92       	push	r15
    2356:	0f 93       	push	r16
    2358:	1f 93       	push	r17
    235a:	cf 93       	push	r28
    235c:	df 93       	push	r29
    235e:	ec 01       	movw	r28, r24
    2360:	6a 01       	movw	r12, r20
    2362:	7b 01       	movw	r14, r22
//	st_print_four_ints( a->counter, step_rate, a->timer->CTRLA, microseconds);

	if (step_rate < DIV1_RANGE) {				// short timer - up to 2000 uSec
    2364:	40 30       	cpi	r20, 0x00	; 0
    2366:	88 e0       	ldi	r24, 0x08	; 8
    2368:	58 07       	cpc	r21, r24
    236a:	80 e0       	ldi	r24, 0x00	; 0
    236c:	68 07       	cpc	r22, r24
    236e:	80 e0       	ldi	r24, 0x00	; 0
    2370:	78 07       	cpc	r23, r24
    2372:	b0 f4       	brcc	.+44     	; 0x23a0 <_st_load_timer+0x52>
		A->timer->CTRLA = TC_CLK_DIV_1;			// set clock divisor
    2374:	eb 8d       	ldd	r30, Y+27	; 0x1b
    2376:	fc 8d       	ldd	r31, Y+28	; 0x1c
    2378:	81 e0       	ldi	r24, 0x01	; 1
    237a:	80 83       	st	Z, r24
		A->counter = (microseconds/step_rate);	// # of steps to make at this rate
    237c:	c9 01       	movw	r24, r18
    237e:	b8 01       	movw	r22, r16
    2380:	a7 01       	movw	r20, r14
    2382:	96 01       	movw	r18, r12
    2384:	0e 94 31 1d 	call	0x3a62	; 0x3a62 <__udivmodsi4>
    2388:	28 83       	st	Y, r18
    238a:	39 83       	std	Y+1, r19	; 0x01
    238c:	4a 83       	std	Y+2, r20	; 0x02
    238e:	5b 83       	std	Y+3, r21	; 0x03
		step_rate = (step_rate * 32);			// normalize step rate to timer clock
    2390:	65 e0       	ldi	r22, 0x05	; 5
    2392:	cc 0c       	add	r12, r12
    2394:	dd 1c       	adc	r13, r13
    2396:	ee 1c       	adc	r14, r14
    2398:	ff 1c       	adc	r15, r15
    239a:	6a 95       	dec	r22
    239c:	d1 f7       	brne	.-12     	; 0x2392 <_st_load_timer+0x44>
    239e:	92 c0       	rjmp	.+292    	; 0x24c4 <_st_load_timer+0x176>
	} else if (step_rate < DIV2_RANGE) {
    23a0:	40 30       	cpi	r20, 0x00	; 0
    23a2:	80 e1       	ldi	r24, 0x10	; 16
    23a4:	58 07       	cpc	r21, r24
    23a6:	80 e0       	ldi	r24, 0x00	; 0
    23a8:	68 07       	cpc	r22, r24
    23aa:	80 e0       	ldi	r24, 0x00	; 0
    23ac:	78 07       	cpc	r23, r24
    23ae:	b0 f4       	brcc	.+44     	; 0x23dc <_st_load_timer+0x8e>
		A->timer->CTRLA = TC_CLK_DIV_2;	
    23b0:	eb 8d       	ldd	r30, Y+27	; 0x1b
    23b2:	fc 8d       	ldd	r31, Y+28	; 0x1c
    23b4:	82 e0       	ldi	r24, 0x02	; 2
    23b6:	80 83       	st	Z, r24
		A->counter = (microseconds/step_rate);
    23b8:	c9 01       	movw	r24, r18
    23ba:	b8 01       	movw	r22, r16
    23bc:	a7 01       	movw	r20, r14
    23be:	96 01       	movw	r18, r12
    23c0:	0e 94 31 1d 	call	0x3a62	; 0x3a62 <__udivmodsi4>
    23c4:	28 83       	st	Y, r18
    23c6:	39 83       	std	Y+1, r19	; 0x01
    23c8:	4a 83       	std	Y+2, r20	; 0x02
    23ca:	5b 83       	std	Y+3, r21	; 0x03
		step_rate = (step_rate * 16);
    23cc:	54 e0       	ldi	r21, 0x04	; 4
    23ce:	cc 0c       	add	r12, r12
    23d0:	dd 1c       	adc	r13, r13
    23d2:	ee 1c       	adc	r14, r14
    23d4:	ff 1c       	adc	r15, r15
    23d6:	5a 95       	dec	r21
    23d8:	d1 f7       	brne	.-12     	; 0x23ce <_st_load_timer+0x80>
    23da:	74 c0       	rjmp	.+232    	; 0x24c4 <_st_load_timer+0x176>
	} else if (step_rate < DIV4_RANGE) {
    23dc:	40 30       	cpi	r20, 0x00	; 0
    23de:	80 e2       	ldi	r24, 0x20	; 32
    23e0:	58 07       	cpc	r21, r24
    23e2:	80 e0       	ldi	r24, 0x00	; 0
    23e4:	68 07       	cpc	r22, r24
    23e6:	80 e0       	ldi	r24, 0x00	; 0
    23e8:	78 07       	cpc	r23, r24
    23ea:	b0 f4       	brcc	.+44     	; 0x2418 <_st_load_timer+0xca>
		A->timer->CTRLA = TC_CLK_DIV_4;	
    23ec:	eb 8d       	ldd	r30, Y+27	; 0x1b
    23ee:	fc 8d       	ldd	r31, Y+28	; 0x1c
    23f0:	83 e0       	ldi	r24, 0x03	; 3
    23f2:	80 83       	st	Z, r24
		A->counter = (microseconds/step_rate);
    23f4:	c9 01       	movw	r24, r18
    23f6:	b8 01       	movw	r22, r16
    23f8:	a7 01       	movw	r20, r14
    23fa:	96 01       	movw	r18, r12
    23fc:	0e 94 31 1d 	call	0x3a62	; 0x3a62 <__udivmodsi4>
    2400:	28 83       	st	Y, r18
    2402:	39 83       	std	Y+1, r19	; 0x01
    2404:	4a 83       	std	Y+2, r20	; 0x02
    2406:	5b 83       	std	Y+3, r21	; 0x03
		step_rate = (step_rate * 8);
    2408:	43 e0       	ldi	r20, 0x03	; 3
    240a:	cc 0c       	add	r12, r12
    240c:	dd 1c       	adc	r13, r13
    240e:	ee 1c       	adc	r14, r14
    2410:	ff 1c       	adc	r15, r15
    2412:	4a 95       	dec	r20
    2414:	d1 f7       	brne	.-12     	; 0x240a <_st_load_timer+0xbc>
    2416:	56 c0       	rjmp	.+172    	; 0x24c4 <_st_load_timer+0x176>
	} else if (step_rate < DIV8_RANGE) {
    2418:	40 30       	cpi	r20, 0x00	; 0
    241a:	80 e4       	ldi	r24, 0x40	; 64
    241c:	58 07       	cpc	r21, r24
    241e:	80 e0       	ldi	r24, 0x00	; 0
    2420:	68 07       	cpc	r22, r24
    2422:	80 e0       	ldi	r24, 0x00	; 0
    2424:	78 07       	cpc	r23, r24
    2426:	b0 f4       	brcc	.+44     	; 0x2454 <_st_load_timer+0x106>
		A->timer->CTRLA = TC_CLK_DIV_8;	
    2428:	eb 8d       	ldd	r30, Y+27	; 0x1b
    242a:	fc 8d       	ldd	r31, Y+28	; 0x1c
    242c:	84 e0       	ldi	r24, 0x04	; 4
    242e:	80 83       	st	Z, r24
		A->counter = (microseconds/step_rate);
    2430:	c9 01       	movw	r24, r18
    2432:	b8 01       	movw	r22, r16
    2434:	a7 01       	movw	r20, r14
    2436:	96 01       	movw	r18, r12
    2438:	0e 94 31 1d 	call	0x3a62	; 0x3a62 <__udivmodsi4>
    243c:	28 83       	st	Y, r18
    243e:	39 83       	std	Y+1, r19	; 0x01
    2440:	4a 83       	std	Y+2, r20	; 0x02
    2442:	5b 83       	std	Y+3, r21	; 0x03
		step_rate = (step_rate * 4);
    2444:	32 e0       	ldi	r19, 0x02	; 2
    2446:	cc 0c       	add	r12, r12
    2448:	dd 1c       	adc	r13, r13
    244a:	ee 1c       	adc	r14, r14
    244c:	ff 1c       	adc	r15, r15
    244e:	3a 95       	dec	r19
    2450:	d1 f7       	brne	.-12     	; 0x2446 <_st_load_timer+0xf8>
    2452:	38 c0       	rjmp	.+112    	; 0x24c4 <_st_load_timer+0x176>
	} else if (step_rate < DIV64_RANGE) {
    2454:	40 30       	cpi	r20, 0x00	; 0
    2456:	80 e0       	ldi	r24, 0x00	; 0
    2458:	58 07       	cpc	r21, r24
    245a:	82 e0       	ldi	r24, 0x02	; 2
    245c:	68 07       	cpc	r22, r24
    245e:	80 e0       	ldi	r24, 0x00	; 0
    2460:	78 07       	cpc	r23, r24
    2462:	98 f4       	brcc	.+38     	; 0x248a <_st_load_timer+0x13c>
		A->timer->CTRLA = TC_CLK_DIV_64;	
    2464:	eb 8d       	ldd	r30, Y+27	; 0x1b
    2466:	fc 8d       	ldd	r31, Y+28	; 0x1c
    2468:	85 e0       	ldi	r24, 0x05	; 5
    246a:	80 83       	st	Z, r24
		A->counter = (microseconds/step_rate);
    246c:	c9 01       	movw	r24, r18
    246e:	b8 01       	movw	r22, r16
    2470:	a7 01       	movw	r20, r14
    2472:	96 01       	movw	r18, r12
    2474:	0e 94 31 1d 	call	0x3a62	; 0x3a62 <__udivmodsi4>
    2478:	28 83       	st	Y, r18
    247a:	39 83       	std	Y+1, r19	; 0x01
    247c:	4a 83       	std	Y+2, r20	; 0x02
    247e:	5b 83       	std	Y+3, r21	; 0x03
		step_rate = (step_rate / 2);
    2480:	f6 94       	lsr	r15
    2482:	e7 94       	ror	r14
    2484:	d7 94       	ror	r13
    2486:	c7 94       	ror	r12
    2488:	1d c0       	rjmp	.+58     	; 0x24c4 <_st_load_timer+0x176>
	} else if (step_rate < DIV256_RANGE) {
    248a:	40 32       	cpi	r20, 0x20	; 32
    248c:	8e e4       	ldi	r24, 0x4E	; 78
    248e:	58 07       	cpc	r21, r24
    2490:	88 e0       	ldi	r24, 0x08	; 8
    2492:	68 07       	cpc	r22, r24
    2494:	80 e0       	ldi	r24, 0x00	; 0
    2496:	78 07       	cpc	r23, r24
    2498:	a8 f4       	brcc	.+42     	; 0x24c4 <_st_load_timer+0x176>
		A->timer->CTRLA = TC_CLK_DIV_256;	
    249a:	eb 8d       	ldd	r30, Y+27	; 0x1b
    249c:	fc 8d       	ldd	r31, Y+28	; 0x1c
    249e:	86 e0       	ldi	r24, 0x06	; 6
    24a0:	80 83       	st	Z, r24
		A->counter = (microseconds/step_rate);
    24a2:	c9 01       	movw	r24, r18
    24a4:	b8 01       	movw	r22, r16
    24a6:	a7 01       	movw	r20, r14
    24a8:	96 01       	movw	r18, r12
    24aa:	0e 94 31 1d 	call	0x3a62	; 0x3a62 <__udivmodsi4>
    24ae:	28 83       	st	Y, r18
    24b0:	39 83       	std	Y+1, r19	; 0x01
    24b2:	4a 83       	std	Y+2, r20	; 0x02
    24b4:	5b 83       	std	Y+3, r21	; 0x03
		step_rate = (step_rate / 8);
    24b6:	93 e0       	ldi	r25, 0x03	; 3
    24b8:	f6 94       	lsr	r15
    24ba:	e7 94       	ror	r14
    24bc:	d7 94       	ror	r13
    24be:	c7 94       	ror	r12
    24c0:	9a 95       	dec	r25
    24c2:	d1 f7       	brne	.-12     	; 0x24b8 <_st_load_timer+0x16a>
	}
	A->timer->PERH = (uint8_t)((step_rate >> 8) & 0x000000FF);	// period high
    24c4:	eb 8d       	ldd	r30, Y+27	; 0x1b
    24c6:	fc 8d       	ldd	r31, Y+28	; 0x1c
    24c8:	bb 27       	eor	r27, r27
    24ca:	af 2d       	mov	r26, r15
    24cc:	9e 2d       	mov	r25, r14
    24ce:	8d 2d       	mov	r24, r13
    24d0:	87 a3       	std	Z+39, r24	; 0x27
	A->timer->PERL = (uint8_t)(step_rate & 0x000000FF);			// period low
    24d2:	eb 8d       	ldd	r30, Y+27	; 0x1b
    24d4:	fc 8d       	ldd	r31, Y+28	; 0x1c
    24d6:	c6 a2       	std	Z+38, r12	; 0x26
}
    24d8:	df 91       	pop	r29
    24da:	cf 91       	pop	r28
    24dc:	1f 91       	pop	r17
    24de:	0f 91       	pop	r16
    24e0:	ff 90       	pop	r15
    24e2:	ef 90       	pop	r14
    24e4:	df 90       	pop	r13
    24e6:	cf 90       	pop	r12
    24e8:	08 95       	ret

000024ea <st_get_next_line>:

struct Line *st_get_next_line()
{
	struct Line *ln;
	 
	if (line_buffer_head == line_buffer_tail) {	// buffer empty
    24ea:	20 91 35 20 	lds	r18, 0x2035
    24ee:	30 91 36 20 	lds	r19, 0x2036
    24f2:	80 91 37 20 	lds	r24, 0x2037
    24f6:	90 91 38 20 	lds	r25, 0x2038
    24fa:	28 17       	cp	r18, r24
    24fc:	39 07       	cpc	r19, r25
    24fe:	19 f4       	brne	.+6      	; 0x2506 <st_get_next_line+0x1c>
    2500:	20 e0       	ldi	r18, 0x00	; 0
    2502:	30 e0       	ldi	r19, 0x00	; 0
    2504:	1e c0       	rjmp	.+60     	; 0x2542 <st_get_next_line+0x58>
		return (NULL);
	}
	ln = &line_buffer[line_buffer_tail];		 // get and save the current pointer
    2506:	20 91 37 20 	lds	r18, 0x2037
    250a:	30 91 38 20 	lds	r19, 0x2038
    250e:	74 e0       	ldi	r23, 0x04	; 4
    2510:	22 0f       	add	r18, r18
    2512:	33 1f       	adc	r19, r19
    2514:	7a 95       	dec	r23
    2516:	e1 f7       	brne	.-8      	; 0x2510 <st_get_next_line+0x26>
    2518:	24 58       	subi	r18, 0x84	; 132
    251a:	3e 4d       	sbci	r19, 0xDE	; 222
	if (++line_buffer_tail > LINE_BUFFER_SIZE) { // increment and wrap
    251c:	80 91 37 20 	lds	r24, 0x2037
    2520:	90 91 38 20 	lds	r25, 0x2038
    2524:	01 96       	adiw	r24, 0x01	; 1
    2526:	80 93 37 20 	sts	0x2037, r24
    252a:	90 93 38 20 	sts	0x2038, r25
    252e:	80 91 37 20 	lds	r24, 0x2037
    2532:	90 91 38 20 	lds	r25, 0x2038
    2536:	0b 97       	sbiw	r24, 0x0b	; 11
    2538:	24 f0       	brlt	.+8      	; 0x2542 <st_get_next_line+0x58>
		line_buffer_tail = 0;
    253a:	10 92 37 20 	sts	0x2037, r1
    253e:	10 92 38 20 	sts	0x2038, r1
	}
	return (ln); 
}
    2542:	c9 01       	movw	r24, r18
    2544:	08 95       	ret

00002546 <st_synchronize>:
}

/* st_synchronize() - block until all buffered steps are executed */

void st_synchronize()
{
    2546:	0b c0       	rjmp	.+22     	; 0x255e <st_synchronize+0x18>
	while(line_buffer_tail != line_buffer_head) {
		sleep_mode();
    2548:	80 91 48 00 	lds	r24, 0x0048
    254c:	81 60       	ori	r24, 0x01	; 1
    254e:	80 93 48 00 	sts	0x0048, r24
    2552:	88 95       	sleep
    2554:	80 91 48 00 	lds	r24, 0x0048
    2558:	8e 7f       	andi	r24, 0xFE	; 254
    255a:	80 93 48 00 	sts	0x0048, r24

/* st_synchronize() - block until all buffered steps are executed */

void st_synchronize()
{
	while(line_buffer_tail != line_buffer_head) {
    255e:	20 91 37 20 	lds	r18, 0x2037
    2562:	30 91 38 20 	lds	r19, 0x2038
    2566:	80 91 35 20 	lds	r24, 0x2035
    256a:	90 91 36 20 	lds	r25, 0x2036
    256e:	28 17       	cp	r18, r24
    2570:	39 07       	cpc	r19, r25
    2572:	51 f7       	brne	.-44     	; 0x2548 <st_synchronize+0x2>
		sleep_mode();
	}    
}
    2574:	08 95       	ret

00002576 <st_flush>:

/* st_flush() - cancel all buffered steps */

void st_flush()
{
	cli();
    2576:	f8 94       	cli
	line_buffer_tail = line_buffer_head;
    2578:	80 91 35 20 	lds	r24, 0x2035
    257c:	90 91 36 20 	lds	r25, 0x2036
    2580:	80 93 37 20 	sts	0x2037, r24
    2584:	90 93 38 20 	sts	0x2038, r25
	ln = NULL;
    2588:	10 92 33 20 	sts	0x2033, r1
    258c:	10 92 34 20 	sts	0x2034, r1
	sei();
    2590:	78 94       	sei
}
    2592:	08 95       	ret

00002594 <st_go_home>:
/* st_go_home() - perform the homing cycle */

void st_go_home()
{
  // Todo: Perform the homing cycle
}
    2594:	08 95       	ret

00002596 <st_execute_line>:
	step_rate is computed as steps_ / microseconds

******************************************************************************/

void st_execute_line()
{
    2596:	af 92       	push	r10
    2598:	bf 92       	push	r11
    259a:	cf 92       	push	r12
    259c:	df 92       	push	r13
    259e:	ef 92       	push	r14
    25a0:	ff 92       	push	r15
    25a2:	0f 93       	push	r16
    25a4:	1f 93       	push	r17
    25a6:	cf 93       	push	r28
    25a8:	df 93       	push	r29
	struct Line *ln;

//	printInteger(busy);
//	st_print_active(&ax);

	if (busy) { return; } 					// busy-flag to avoid reentry
    25aa:	80 91 05 21 	lds	r24, 0x2105
    25ae:	90 91 06 21 	lds	r25, 0x2106
    25b2:	89 2b       	or	r24, r25
    25b4:	09 f0       	breq	.+2      	; 0x25b8 <st_execute_line+0x22>
    25b6:	b8 c0       	rjmp	.+368    	; 0x2728 <st_execute_line+0x192>

	busy = TRUE;
    25b8:	81 e0       	ldi	r24, 0x01	; 1
    25ba:	90 e0       	ldi	r25, 0x00	; 0
    25bc:	80 93 05 21 	sts	0x2105, r24
    25c0:	90 93 06 21 	sts	0x2106, r25

	if (ax.active_axes != 0) {
    25c4:	80 91 7b 21 	lds	r24, 0x217B
    25c8:	88 23       	and	r24, r24
    25ca:	09 f0       	breq	.+2      	; 0x25ce <st_execute_line+0x38>
    25cc:	a9 c0       	rjmp	.+338    	; 0x2720 <st_execute_line+0x18a>
		busy = FALSE;	
		return;								// if any bit is set the robot is active
	}
	if ((ln = st_get_next_line()) == NULL) {
    25ce:	0e 94 75 12 	call	0x24ea	; 0x24ea <st_get_next_line>
    25d2:	ec 01       	movw	r28, r24
    25d4:	00 97       	sbiw	r24, 0x00	; 0
    25d6:	09 f4       	brne	.+2      	; 0x25da <st_execute_line+0x44>
    25d8:	a3 c0       	rjmp	.+326    	; 0x2720 <st_execute_line+0x18a>
		busy = FALSE;	
		return;
  	} 

	// set direction bits
	(ln->steps_x < 0) ? (ax.x.port->OUTSET=DIRECTION_BIT_bm) : 	// CCW
    25da:	28 81       	ld	r18, Y
    25dc:	39 81       	ldd	r19, Y+1	; 0x01
    25de:	4a 81       	ldd	r20, Y+2	; 0x02
    25e0:	5b 81       	ldd	r21, Y+3	; 0x03
    25e2:	57 ff       	sbrs	r21, 7
    25e4:	07 c0       	rjmp	.+14     	; 0x25f4 <st_execute_line+0x5e>
    25e6:	e0 91 20 21 	lds	r30, 0x2120
    25ea:	f0 91 21 21 	lds	r31, 0x2121
    25ee:	82 e0       	ldi	r24, 0x02	; 2
    25f0:	85 83       	std	Z+5, r24	; 0x05
    25f2:	06 c0       	rjmp	.+12     	; 0x2600 <st_execute_line+0x6a>
    25f4:	e0 91 20 21 	lds	r30, 0x2120
    25f8:	f0 91 21 21 	lds	r31, 0x2121
    25fc:	82 e0       	ldi	r24, 0x02	; 2
    25fe:	86 83       	std	Z+6, r24	; 0x06
						(ax.x.port->OUTCLR=DIRECTION_BIT_bm);	// CW
	(ln->steps_y < 0) ? (ax.y.port->OUTSET=DIRECTION_BIT_bm) : 
    2600:	8c 81       	ldd	r24, Y+4	; 0x04
    2602:	9d 81       	ldd	r25, Y+5	; 0x05
    2604:	ae 81       	ldd	r26, Y+6	; 0x06
    2606:	bf 81       	ldd	r27, Y+7	; 0x07
    2608:	b7 ff       	sbrs	r27, 7
    260a:	07 c0       	rjmp	.+14     	; 0x261a <st_execute_line+0x84>
    260c:	e0 91 3d 21 	lds	r30, 0x213D
    2610:	f0 91 3e 21 	lds	r31, 0x213E
    2614:	82 e0       	ldi	r24, 0x02	; 2
    2616:	85 83       	std	Z+5, r24	; 0x05
    2618:	06 c0       	rjmp	.+12     	; 0x2626 <st_execute_line+0x90>
    261a:	e0 91 3d 21 	lds	r30, 0x213D
    261e:	f0 91 3e 21 	lds	r31, 0x213E
    2622:	82 e0       	ldi	r24, 0x02	; 2
    2624:	86 83       	std	Z+6, r24	; 0x06
						(ax.y.port->OUTCLR=DIRECTION_BIT_bm);
	(ln->steps_z < 0) ? (ax.z.port->OUTSET=DIRECTION_BIT_bm) : 
    2626:	88 85       	ldd	r24, Y+8	; 0x08
    2628:	99 85       	ldd	r25, Y+9	; 0x09
    262a:	aa 85       	ldd	r26, Y+10	; 0x0a
    262c:	bb 85       	ldd	r27, Y+11	; 0x0b
    262e:	b7 ff       	sbrs	r27, 7
    2630:	07 c0       	rjmp	.+14     	; 0x2640 <st_execute_line+0xaa>
    2632:	e0 91 5a 21 	lds	r30, 0x215A
    2636:	f0 91 5b 21 	lds	r31, 0x215B
    263a:	82 e0       	ldi	r24, 0x02	; 2
    263c:	85 83       	std	Z+5, r24	; 0x05
    263e:	06 c0       	rjmp	.+12     	; 0x264c <st_execute_line+0xb6>
    2640:	e0 91 5a 21 	lds	r30, 0x215A
    2644:	f0 91 5b 21 	lds	r31, 0x215B
    2648:	82 e0       	ldi	r24, 0x02	; 2
    264a:	86 83       	std	Z+6, r24	; 0x06
						(ax.z.port->OUTCLR=DIRECTION_BIT_bm);

	// load timers: step rate = microseconds / absolute value of step count
	_st_load_timer(&ax.x, (ln->microseconds / labs(ln->steps_x)), ln->microseconds);
    264c:	ec 84       	ldd	r14, Y+12	; 0x0c
    264e:	fd 84       	ldd	r15, Y+13	; 0x0d
    2650:	0e 85       	ldd	r16, Y+14	; 0x0e
    2652:	1f 85       	ldd	r17, Y+15	; 0x0f
    2654:	57 ff       	sbrs	r21, 7
    2656:	07 c0       	rjmp	.+14     	; 0x2666 <st_execute_line+0xd0>
    2658:	50 95       	com	r21
    265a:	40 95       	com	r20
    265c:	30 95       	com	r19
    265e:	21 95       	neg	r18
    2660:	3f 4f       	sbci	r19, 0xFF	; 255
    2662:	4f 4f       	sbci	r20, 0xFF	; 255
    2664:	5f 4f       	sbci	r21, 0xFF	; 255
    2666:	c8 01       	movw	r24, r16
    2668:	b7 01       	movw	r22, r14
    266a:	0e 94 31 1d 	call	0x3a62	; 0x3a62 <__udivmodsi4>
    266e:	87 e0       	ldi	r24, 0x07	; 7
    2670:	91 e2       	ldi	r25, 0x21	; 33
    2672:	ba 01       	movw	r22, r20
    2674:	a9 01       	movw	r20, r18
    2676:	98 01       	movw	r18, r16
    2678:	87 01       	movw	r16, r14
    267a:	0e 94 a7 11 	call	0x234e	; 0x234e <_st_load_timer>
	_st_load_timer(&ax.y, (ln->microseconds / labs(ln->steps_y)), ln->microseconds);
    267e:	ec 84       	ldd	r14, Y+12	; 0x0c
    2680:	fd 84       	ldd	r15, Y+13	; 0x0d
    2682:	0e 85       	ldd	r16, Y+14	; 0x0e
    2684:	1f 85       	ldd	r17, Y+15	; 0x0f
    2686:	2c 81       	ldd	r18, Y+4	; 0x04
    2688:	3d 81       	ldd	r19, Y+5	; 0x05
    268a:	4e 81       	ldd	r20, Y+6	; 0x06
    268c:	5f 81       	ldd	r21, Y+7	; 0x07
    268e:	57 ff       	sbrs	r21, 7
    2690:	07 c0       	rjmp	.+14     	; 0x26a0 <st_execute_line+0x10a>
    2692:	50 95       	com	r21
    2694:	40 95       	com	r20
    2696:	30 95       	com	r19
    2698:	21 95       	neg	r18
    269a:	3f 4f       	sbci	r19, 0xFF	; 255
    269c:	4f 4f       	sbci	r20, 0xFF	; 255
    269e:	5f 4f       	sbci	r21, 0xFF	; 255
    26a0:	c8 01       	movw	r24, r16
    26a2:	b7 01       	movw	r22, r14
    26a4:	0e 94 31 1d 	call	0x3a62	; 0x3a62 <__udivmodsi4>
    26a8:	84 e2       	ldi	r24, 0x24	; 36
    26aa:	91 e2       	ldi	r25, 0x21	; 33
    26ac:	ba 01       	movw	r22, r20
    26ae:	a9 01       	movw	r20, r18
    26b0:	98 01       	movw	r18, r16
    26b2:	87 01       	movw	r16, r14
    26b4:	0e 94 a7 11 	call	0x234e	; 0x234e <_st_load_timer>
	_st_load_timer(&ax.z, (ln->microseconds / labs(ln->steps_z)), ln->microseconds);
    26b8:	ec 84       	ldd	r14, Y+12	; 0x0c
    26ba:	fd 84       	ldd	r15, Y+13	; 0x0d
    26bc:	0e 85       	ldd	r16, Y+14	; 0x0e
    26be:	1f 85       	ldd	r17, Y+15	; 0x0f
    26c0:	28 85       	ldd	r18, Y+8	; 0x08
    26c2:	39 85       	ldd	r19, Y+9	; 0x09
    26c4:	4a 85       	ldd	r20, Y+10	; 0x0a
    26c6:	5b 85       	ldd	r21, Y+11	; 0x0b
    26c8:	57 ff       	sbrs	r21, 7
    26ca:	07 c0       	rjmp	.+14     	; 0x26da <st_execute_line+0x144>
    26cc:	50 95       	com	r21
    26ce:	40 95       	com	r20
    26d0:	30 95       	com	r19
    26d2:	21 95       	neg	r18
    26d4:	3f 4f       	sbci	r19, 0xFF	; 255
    26d6:	4f 4f       	sbci	r20, 0xFF	; 255
    26d8:	5f 4f       	sbci	r21, 0xFF	; 255
    26da:	c8 01       	movw	r24, r16
    26dc:	b7 01       	movw	r22, r14
    26de:	0e 94 31 1d 	call	0x3a62	; 0x3a62 <__udivmodsi4>
    26e2:	81 e4       	ldi	r24, 0x41	; 65
    26e4:	91 e2       	ldi	r25, 0x21	; 33
    26e6:	ba 01       	movw	r22, r20
    26e8:	a9 01       	movw	r20, r18
    26ea:	98 01       	movw	r18, r16
    26ec:	87 01       	movw	r16, r14
    26ee:	0e 94 a7 11 	call	0x234e	; 0x234e <_st_load_timer>

	ax.active_axes |= (X_BIT_bm | Y_BIT_bm | Z_BIT_bm);			// set XYZ active
    26f2:	80 91 7b 21 	lds	r24, 0x217B
    26f6:	87 60       	ori	r24, 0x07	; 7
    26f8:	80 93 7b 21 	sts	0x217B, r24

//	st_print_axis(&ax.x, "X");					// ++++ DEBUG STATEMENT ++++
//	st_print_axis(&ax.y, "Y");					// ++++ DEBUG STATEMENT ++++
//	st_print_axis(&ax.z, "Z");					// ++++ DEBUG STATEMENT ++++
	st_print_exec_line(*ln);					// ++++ DEBUG STATEMENT ++++
    26fc:	a8 80       	ld	r10, Y
    26fe:	b9 80       	ldd	r11, Y+1	; 0x01
    2700:	ca 80       	ldd	r12, Y+2	; 0x02
    2702:	db 80       	ldd	r13, Y+3	; 0x03
    2704:	ec 80       	ldd	r14, Y+4	; 0x04
    2706:	fd 80       	ldd	r15, Y+5	; 0x05
    2708:	0e 81       	ldd	r16, Y+6	; 0x06
    270a:	1f 81       	ldd	r17, Y+7	; 0x07
    270c:	28 85       	ldd	r18, Y+8	; 0x08
    270e:	39 85       	ldd	r19, Y+9	; 0x09
    2710:	4a 85       	ldd	r20, Y+10	; 0x0a
    2712:	5b 85       	ldd	r21, Y+11	; 0x0b
    2714:	6c 85       	ldd	r22, Y+12	; 0x0c
    2716:	7d 85       	ldd	r23, Y+13	; 0x0d
    2718:	8e 85       	ldd	r24, Y+14	; 0x0e
    271a:	9f 85       	ldd	r25, Y+15	; 0x0f
    271c:	0e 94 55 17 	call	0x2eaa	; 0x2eaa <st_print_exec_line>

	busy = FALSE;
    2720:	10 92 05 21 	sts	0x2105, r1
    2724:	10 92 06 21 	sts	0x2106, r1
	return;
}
    2728:	df 91       	pop	r29
    272a:	cf 91       	pop	r28
    272c:	1f 91       	pop	r17
    272e:	0f 91       	pop	r16
    2730:	ff 90       	pop	r15
    2732:	ef 90       	pop	r14
    2734:	df 90       	pop	r13
    2736:	cf 90       	pop	r12
    2738:	bf 90       	pop	r11
    273a:	af 90       	pop	r10
    273c:	08 95       	ret

0000273e <st_buffer_line>:
	Buffer full:	line_buffer_head == line_buffer_tail
	Buffer empty:	line_buffer_head == line_buffer_tail+1 

*/
void st_buffer_line(int32_t steps_x, int32_t steps_y, int32_t steps_z, uint32_t microseconds) 
{
    273e:	2f 92       	push	r2
    2740:	3f 92       	push	r3
    2742:	4f 92       	push	r4
    2744:	5f 92       	push	r5
    2746:	6f 92       	push	r6
    2748:	7f 92       	push	r7
    274a:	8f 92       	push	r8
    274c:	9f 92       	push	r9
    274e:	af 92       	push	r10
    2750:	bf 92       	push	r11
    2752:	cf 92       	push	r12
    2754:	df 92       	push	r13
    2756:	ef 92       	push	r14
    2758:	ff 92       	push	r15
    275a:	0f 93       	push	r16
    275c:	1f 93       	push	r17
    275e:	3b 01       	movw	r6, r22
    2760:	4c 01       	movw	r8, r24
    2762:	17 01       	movw	r2, r14
    2764:	28 01       	movw	r4, r16
    2766:	7a 2d       	mov	r23, r10
	struct Line *ln;
	int next_buffer_head;

	// bail on a zero length line (perhaps test for abs val < min line length)
	if ((steps_x == 0) && (steps_y == 0) && (steps_z) == 0) {
    2768:	61 14       	cp	r6, r1
    276a:	71 04       	cpc	r7, r1
    276c:	81 04       	cpc	r8, r1
    276e:	91 04       	cpc	r9, r1
    2770:	59 f4       	brne	.+22     	; 0x2788 <st_buffer_line+0x4a>
    2772:	21 15       	cp	r18, r1
    2774:	31 05       	cpc	r19, r1
    2776:	41 05       	cpc	r20, r1
    2778:	51 05       	cpc	r21, r1
    277a:	31 f4       	brne	.+12     	; 0x2788 <st_buffer_line+0x4a>
    277c:	e1 14       	cp	r14, r1
    277e:	f1 04       	cpc	r15, r1
    2780:	01 05       	cpc	r16, r1
    2782:	11 05       	cpc	r17, r1
    2784:	09 f4       	brne	.+2      	; 0x2788 <st_buffer_line+0x4a>
    2786:	50 c0       	rjmp	.+160    	; 0x2828 <st_buffer_line+0xea>
		return;
	};

	// Calculate the buffer head needed to store this line
	if ((next_buffer_head = line_buffer_head + 1) > LINE_BUFFER_SIZE) {
    2788:	a0 91 35 20 	lds	r26, 0x2035
    278c:	b0 91 36 20 	lds	r27, 0x2036
    2790:	11 96       	adiw	r26, 0x01	; 1
    2792:	ab 30       	cpi	r26, 0x0B	; 11
    2794:	b1 05       	cpc	r27, r1
    2796:	74 f0       	brlt	.+28     	; 0x27b4 <st_buffer_line+0x76>
    2798:	a0 e0       	ldi	r26, 0x00	; 0
    279a:	b0 e0       	ldi	r27, 0x00	; 0
    279c:	0b c0       	rjmp	.+22     	; 0x27b4 <st_buffer_line+0x76>
		next_buffer_head = 0;					  // wrap condition
	}
	// If the buffer is full sleep until there is room in the buffer.
	while(line_buffer_tail == next_buffer_head) { // tail will advance, breaking this loop
		sleep_mode(); 
    279e:	80 91 48 00 	lds	r24, 0x0048
    27a2:	81 60       	ori	r24, 0x01	; 1
    27a4:	80 93 48 00 	sts	0x0048, r24
    27a8:	88 95       	sleep
    27aa:	80 91 48 00 	lds	r24, 0x0048
    27ae:	8e 7f       	andi	r24, 0xFE	; 254
    27b0:	80 93 48 00 	sts	0x0048, r24
	// Calculate the buffer head needed to store this line
	if ((next_buffer_head = line_buffer_head + 1) > LINE_BUFFER_SIZE) {
		next_buffer_head = 0;					  // wrap condition
	}
	// If the buffer is full sleep until there is room in the buffer.
	while(line_buffer_tail == next_buffer_head) { // tail will advance, breaking this loop
    27b4:	80 91 37 20 	lds	r24, 0x2037
    27b8:	90 91 38 20 	lds	r25, 0x2038
    27bc:	8a 17       	cp	r24, r26
    27be:	9b 07       	cpc	r25, r27
    27c0:	71 f3       	breq	.-36     	; 0x279e <st_buffer_line+0x60>
		sleep_mode(); 
//		_delay_us(10);
	};

	ln = &line_buffer[line_buffer_head];  		// write the line record to the buffer head
    27c2:	e0 91 35 20 	lds	r30, 0x2035
    27c6:	f0 91 36 20 	lds	r31, 0x2036
    27ca:	14 e0       	ldi	r17, 0x04	; 4
    27cc:	ee 0f       	add	r30, r30
    27ce:	ff 1f       	adc	r31, r31
    27d0:	1a 95       	dec	r17
    27d2:	e1 f7       	brne	.-8      	; 0x27cc <st_buffer_line+0x8e>
    27d4:	e4 58       	subi	r30, 0x84	; 132
    27d6:	fe 4d       	sbci	r31, 0xDE	; 222
	ln->steps_x = steps_x;
    27d8:	a6 2c       	mov	r10, r6
    27da:	60 82       	st	Z, r6
    27dc:	71 82       	std	Z+1, r7	; 0x01
    27de:	82 82       	std	Z+2, r8	; 0x02
    27e0:	93 82       	std	Z+3, r9	; 0x03
	ln->steps_y = steps_y;
    27e2:	e2 2e       	mov	r14, r18
    27e4:	24 83       	std	Z+4, r18	; 0x04
    27e6:	35 83       	std	Z+5, r19	; 0x05
    27e8:	46 83       	std	Z+6, r20	; 0x06
    27ea:	57 83       	std	Z+7, r21	; 0x07
	ln->steps_z = steps_z;  
    27ec:	22 2d       	mov	r18, r2
    27ee:	20 86       	std	Z+8, r2	; 0x08
    27f0:	31 86       	std	Z+9, r3	; 0x09
    27f2:	42 86       	std	Z+10, r4	; 0x0a
    27f4:	53 86       	std	Z+11, r5	; 0x0b
	ln->microseconds = microseconds;
    27f6:	67 2f       	mov	r22, r23
    27f8:	74 87       	std	Z+12, r23	; 0x0c
    27fa:	b5 86       	std	Z+13, r11	; 0x0d
    27fc:	c6 86       	std	Z+14, r12	; 0x0e
    27fe:	d7 86       	std	Z+15, r13	; 0x0f

	line_buffer_head = next_buffer_head;
    2800:	a0 93 35 20 	sts	0x2035, r26
    2804:	b0 93 36 20 	sts	0x2036, r27

	st_print_line(*ln);							// ++++ DEBUG STATEMENT ++++
    2808:	b1 80       	ldd	r11, Z+1	; 0x01
    280a:	c2 80       	ldd	r12, Z+2	; 0x02
    280c:	d3 80       	ldd	r13, Z+3	; 0x03
    280e:	f5 80       	ldd	r15, Z+5	; 0x05
    2810:	06 81       	ldd	r16, Z+6	; 0x06
    2812:	17 81       	ldd	r17, Z+7	; 0x07
    2814:	31 85       	ldd	r19, Z+9	; 0x09
    2816:	42 85       	ldd	r20, Z+10	; 0x0a
    2818:	53 85       	ldd	r21, Z+11	; 0x0b
    281a:	75 85       	ldd	r23, Z+13	; 0x0d
    281c:	86 85       	ldd	r24, Z+14	; 0x0e
    281e:	97 85       	ldd	r25, Z+15	; 0x0f
    2820:	0e 94 c6 17 	call	0x2f8c	; 0x2f8c <st_print_line>
	st_execute_line();							// attempt to run this line
    2824:	0e 94 cb 12 	call	0x2596	; 0x2596 <st_execute_line>
}
    2828:	1f 91       	pop	r17
    282a:	0f 91       	pop	r16
    282c:	ff 90       	pop	r15
    282e:	ef 90       	pop	r14
    2830:	df 90       	pop	r13
    2832:	cf 90       	pop	r12
    2834:	bf 90       	pop	r11
    2836:	af 90       	pop	r10
    2838:	9f 90       	pop	r9
    283a:	8f 90       	pop	r8
    283c:	7f 90       	pop	r7
    283e:	6f 90       	pop	r6
    2840:	5f 90       	pop	r5
    2842:	4f 90       	pop	r4
    2844:	3f 90       	pop	r3
    2846:	2f 90       	pop	r2
    2848:	08 95       	ret

0000284a <__vector_108>:
//	_delay_us(STEP_PULSE_MICROSECONDS);
	Z_MOTOR_PORT.OUTCLR	= STEP_BIT_bm;
}

ISR(A_TIMER_vect)
{
    284a:	1f 92       	push	r1
    284c:	0f 92       	push	r0
    284e:	0f b6       	in	r0, 0x3f	; 63
    2850:	0f 92       	push	r0
    2852:	0b b6       	in	r0, 0x3b	; 59
    2854:	0f 92       	push	r0
    2856:	11 24       	eor	r1, r1
    2858:	2f 93       	push	r18
    285a:	3f 93       	push	r19
    285c:	4f 93       	push	r20
    285e:	5f 93       	push	r21
    2860:	6f 93       	push	r22
    2862:	7f 93       	push	r23
    2864:	8f 93       	push	r24
    2866:	9f 93       	push	r25
    2868:	af 93       	push	r26
    286a:	bf 93       	push	r27
    286c:	ef 93       	push	r30
    286e:	ff 93       	push	r31
	A_MOTOR_PORT.OUTSET	= STEP_BIT_bm;
    2870:	81 e0       	ldi	r24, 0x01	; 1
    2872:	e0 e6       	ldi	r30, 0x60	; 96
    2874:	f6 e0       	ldi	r31, 0x06	; 6
    2876:	85 83       	std	Z+5, r24	; 0x05
	if (--ax.a.counter == 0) {
    2878:	80 91 5e 21 	lds	r24, 0x215E
    287c:	90 91 5f 21 	lds	r25, 0x215F
    2880:	a0 91 60 21 	lds	r26, 0x2160
    2884:	b0 91 61 21 	lds	r27, 0x2161
    2888:	01 97       	sbiw	r24, 0x01	; 1
    288a:	a1 09       	sbc	r26, r1
    288c:	b1 09       	sbc	r27, r1
    288e:	80 93 5e 21 	sts	0x215E, r24
    2892:	90 93 5f 21 	sts	0x215F, r25
    2896:	a0 93 60 21 	sts	0x2160, r26
    289a:	b0 93 61 21 	sts	0x2161, r27
    289e:	00 97       	sbiw	r24, 0x00	; 0
    28a0:	a1 05       	cpc	r26, r1
    28a2:	b1 05       	cpc	r27, r1
    28a4:	91 f4       	brne	.+36     	; 0x28ca <__vector_108+0x80>
		ax.a.timer->CTRLA = TC_CLK_OFF;			// stop the clock
    28a6:	e0 91 79 21 	lds	r30, 0x2179
    28aa:	f0 91 7a 21 	lds	r31, 0x217A
    28ae:	10 82       	st	Z, r1
		ax.active_axes &= ~A_BIT_bm;			// clear the A active bit
    28b0:	80 91 7b 21 	lds	r24, 0x217B
    28b4:	87 7f       	andi	r24, 0xF7	; 247
    28b6:	80 93 7b 21 	sts	0x217B, r24
		if (ax.active_axes == 0) {
    28ba:	88 23       	and	r24, r24
    28bc:	31 f4       	brne	.+12     	; 0x28ca <__vector_108+0x80>
			st_print_done_line("A");			// ++++ DEBUG STATEMENT ++++
    28be:	8a e2       	ldi	r24, 0x2A	; 42
    28c0:	90 e2       	ldi	r25, 0x20	; 32
    28c2:	0e 94 44 17 	call	0x2e88	; 0x2e88 <st_print_done_line>
			st_execute_line();					// run next line if all axes are done
    28c6:	0e 94 cb 12 	call	0x2596	; 0x2596 <st_execute_line>
		}
	}
//	_delay_us(STEP_PULSE_MICROSECONDS);
	A_MOTOR_PORT.OUTCLR	= STEP_BIT_bm;
    28ca:	81 e0       	ldi	r24, 0x01	; 1
    28cc:	e0 e6       	ldi	r30, 0x60	; 96
    28ce:	f6 e0       	ldi	r31, 0x06	; 6
    28d0:	86 83       	std	Z+6, r24	; 0x06
}
    28d2:	ff 91       	pop	r31
    28d4:	ef 91       	pop	r30
    28d6:	bf 91       	pop	r27
    28d8:	af 91       	pop	r26
    28da:	9f 91       	pop	r25
    28dc:	8f 91       	pop	r24
    28de:	7f 91       	pop	r23
    28e0:	6f 91       	pop	r22
    28e2:	5f 91       	pop	r21
    28e4:	4f 91       	pop	r20
    28e6:	3f 91       	pop	r19
    28e8:	2f 91       	pop	r18
    28ea:	0f 90       	pop	r0
    28ec:	0b be       	out	0x3b, r0	; 59
    28ee:	0f 90       	pop	r0
    28f0:	0f be       	out	0x3f, r0	; 63
    28f2:	0f 90       	pop	r0
    28f4:	1f 90       	pop	r1
    28f6:	18 95       	reti

000028f8 <__vector_47>:
//	_delay_us(STEP_PULSE_MICROSECONDS);
	Y_MOTOR_PORT.OUTCLR	= STEP_BIT_bm;
}

ISR(Z_TIMER_vect)
{
    28f8:	1f 92       	push	r1
    28fa:	0f 92       	push	r0
    28fc:	0f b6       	in	r0, 0x3f	; 63
    28fe:	0f 92       	push	r0
    2900:	0b b6       	in	r0, 0x3b	; 59
    2902:	0f 92       	push	r0
    2904:	11 24       	eor	r1, r1
    2906:	2f 93       	push	r18
    2908:	3f 93       	push	r19
    290a:	4f 93       	push	r20
    290c:	5f 93       	push	r21
    290e:	6f 93       	push	r22
    2910:	7f 93       	push	r23
    2912:	8f 93       	push	r24
    2914:	9f 93       	push	r25
    2916:	af 93       	push	r26
    2918:	bf 93       	push	r27
    291a:	ef 93       	push	r30
    291c:	ff 93       	push	r31
	Z_MOTOR_PORT.OUTSET	= STEP_BIT_bm;
    291e:	81 e0       	ldi	r24, 0x01	; 1
    2920:	e0 e8       	ldi	r30, 0x80	; 128
    2922:	f6 e0       	ldi	r31, 0x06	; 6
    2924:	85 83       	std	Z+5, r24	; 0x05
	if (--ax.z.counter == 0) {
    2926:	80 91 41 21 	lds	r24, 0x2141
    292a:	90 91 42 21 	lds	r25, 0x2142
    292e:	a0 91 43 21 	lds	r26, 0x2143
    2932:	b0 91 44 21 	lds	r27, 0x2144
    2936:	01 97       	sbiw	r24, 0x01	; 1
    2938:	a1 09       	sbc	r26, r1
    293a:	b1 09       	sbc	r27, r1
    293c:	80 93 41 21 	sts	0x2141, r24
    2940:	90 93 42 21 	sts	0x2142, r25
    2944:	a0 93 43 21 	sts	0x2143, r26
    2948:	b0 93 44 21 	sts	0x2144, r27
    294c:	00 97       	sbiw	r24, 0x00	; 0
    294e:	a1 05       	cpc	r26, r1
    2950:	b1 05       	cpc	r27, r1
    2952:	91 f4       	brne	.+36     	; 0x2978 <__vector_47+0x80>
		ax.z.timer->CTRLA = TC_CLK_OFF;			// stop the clock
    2954:	e0 91 5c 21 	lds	r30, 0x215C
    2958:	f0 91 5d 21 	lds	r31, 0x215D
    295c:	10 82       	st	Z, r1
		ax.active_axes &= ~Z_BIT_bm;			// clear the Z active bit
    295e:	80 91 7b 21 	lds	r24, 0x217B
    2962:	8b 7f       	andi	r24, 0xFB	; 251
    2964:	80 93 7b 21 	sts	0x217B, r24
		if (ax.active_axes == 0) {
    2968:	88 23       	and	r24, r24
    296a:	31 f4       	brne	.+12     	; 0x2978 <__vector_47+0x80>
			st_print_done_line("Z");			// ++++ DEBUG STATEMENT ++++
    296c:	8c e2       	ldi	r24, 0x2C	; 44
    296e:	90 e2       	ldi	r25, 0x20	; 32
    2970:	0e 94 44 17 	call	0x2e88	; 0x2e88 <st_print_done_line>
			st_execute_line();					// run next line if all axes are done
    2974:	0e 94 cb 12 	call	0x2596	; 0x2596 <st_execute_line>
		}
	}
//	_delay_us(STEP_PULSE_MICROSECONDS);
	Z_MOTOR_PORT.OUTCLR	= STEP_BIT_bm;
    2978:	81 e0       	ldi	r24, 0x01	; 1
    297a:	e0 e8       	ldi	r30, 0x80	; 128
    297c:	f6 e0       	ldi	r31, 0x06	; 6
    297e:	86 83       	std	Z+6, r24	; 0x06
}
    2980:	ff 91       	pop	r31
    2982:	ef 91       	pop	r30
    2984:	bf 91       	pop	r27
    2986:	af 91       	pop	r26
    2988:	9f 91       	pop	r25
    298a:	8f 91       	pop	r24
    298c:	7f 91       	pop	r23
    298e:	6f 91       	pop	r22
    2990:	5f 91       	pop	r21
    2992:	4f 91       	pop	r20
    2994:	3f 91       	pop	r19
    2996:	2f 91       	pop	r18
    2998:	0f 90       	pop	r0
    299a:	0b be       	out	0x3b, r0	; 59
    299c:	0f 90       	pop	r0
    299e:	0f be       	out	0x3f, r0	; 63
    29a0:	0f 90       	pop	r0
    29a2:	1f 90       	pop	r1
    29a4:	18 95       	reti

000029a6 <__vector_77>:
//	_delay_us(STEP_PULSE_MICROSECONDS);			// delay for correct pulse width
	ax.x.port->OUTCLR = STEP_BIT_bm;			// turn X step bit off
}

ISR(Y_TIMER_vect)
{
    29a6:	1f 92       	push	r1
    29a8:	0f 92       	push	r0
    29aa:	0f b6       	in	r0, 0x3f	; 63
    29ac:	0f 92       	push	r0
    29ae:	0b b6       	in	r0, 0x3b	; 59
    29b0:	0f 92       	push	r0
    29b2:	11 24       	eor	r1, r1
    29b4:	2f 93       	push	r18
    29b6:	3f 93       	push	r19
    29b8:	4f 93       	push	r20
    29ba:	5f 93       	push	r21
    29bc:	6f 93       	push	r22
    29be:	7f 93       	push	r23
    29c0:	8f 93       	push	r24
    29c2:	9f 93       	push	r25
    29c4:	af 93       	push	r26
    29c6:	bf 93       	push	r27
    29c8:	ef 93       	push	r30
    29ca:	ff 93       	push	r31
	ax.y.port->OUTSET = STEP_BIT_bm;
    29cc:	e0 91 3d 21 	lds	r30, 0x213D
    29d0:	f0 91 3e 21 	lds	r31, 0x213E
    29d4:	81 e0       	ldi	r24, 0x01	; 1
    29d6:	85 83       	std	Z+5, r24	; 0x05
	Y_MOTOR_PORT.OUTSET	= STEP_BIT_bm;
    29d8:	e0 ea       	ldi	r30, 0xA0	; 160
    29da:	f6 e0       	ldi	r31, 0x06	; 6
    29dc:	85 83       	std	Z+5, r24	; 0x05
	if (--ax.y.counter == 0) {
    29de:	80 91 24 21 	lds	r24, 0x2124
    29e2:	90 91 25 21 	lds	r25, 0x2125
    29e6:	a0 91 26 21 	lds	r26, 0x2126
    29ea:	b0 91 27 21 	lds	r27, 0x2127
    29ee:	01 97       	sbiw	r24, 0x01	; 1
    29f0:	a1 09       	sbc	r26, r1
    29f2:	b1 09       	sbc	r27, r1
    29f4:	80 93 24 21 	sts	0x2124, r24
    29f8:	90 93 25 21 	sts	0x2125, r25
    29fc:	a0 93 26 21 	sts	0x2126, r26
    2a00:	b0 93 27 21 	sts	0x2127, r27
    2a04:	00 97       	sbiw	r24, 0x00	; 0
    2a06:	a1 05       	cpc	r26, r1
    2a08:	b1 05       	cpc	r27, r1
    2a0a:	91 f4       	brne	.+36     	; 0x2a30 <__vector_77+0x8a>
		ax.y.timer->CTRLA = TC_CLK_OFF;			// stop the clock
    2a0c:	e0 91 3f 21 	lds	r30, 0x213F
    2a10:	f0 91 40 21 	lds	r31, 0x2140
    2a14:	10 82       	st	Z, r1
		ax.active_axes &= ~Y_BIT_bm;			// clear the Y active bit
    2a16:	80 91 7b 21 	lds	r24, 0x217B
    2a1a:	8d 7f       	andi	r24, 0xFD	; 253
    2a1c:	80 93 7b 21 	sts	0x217B, r24
		if (ax.active_axes == 0) {
    2a20:	88 23       	and	r24, r24
    2a22:	31 f4       	brne	.+12     	; 0x2a30 <__vector_77+0x8a>
			st_print_done_line("Y");			// ++++ DEBUG STATEMENT ++++
    2a24:	8e e2       	ldi	r24, 0x2E	; 46
    2a26:	90 e2       	ldi	r25, 0x20	; 32
    2a28:	0e 94 44 17 	call	0x2e88	; 0x2e88 <st_print_done_line>
//			st_print_active(&ax);			// ++++ DEBUG STATEMENT ++++
			st_execute_line();					// run next line if all axes are done
    2a2c:	0e 94 cb 12 	call	0x2596	; 0x2596 <st_execute_line>
		}
	}
//	_delay_us(STEP_PULSE_MICROSECONDS);
	Y_MOTOR_PORT.OUTCLR	= STEP_BIT_bm;
    2a30:	81 e0       	ldi	r24, 0x01	; 1
    2a32:	e0 ea       	ldi	r30, 0xA0	; 160
    2a34:	f6 e0       	ldi	r31, 0x06	; 6
    2a36:	86 83       	std	Z+6, r24	; 0x06
}
    2a38:	ff 91       	pop	r31
    2a3a:	ef 91       	pop	r30
    2a3c:	bf 91       	pop	r27
    2a3e:	af 91       	pop	r26
    2a40:	9f 91       	pop	r25
    2a42:	8f 91       	pop	r24
    2a44:	7f 91       	pop	r23
    2a46:	6f 91       	pop	r22
    2a48:	5f 91       	pop	r21
    2a4a:	4f 91       	pop	r20
    2a4c:	3f 91       	pop	r19
    2a4e:	2f 91       	pop	r18
    2a50:	0f 90       	pop	r0
    2a52:	0b be       	out	0x3b, r0	; 59
    2a54:	0f 90       	pop	r0
    2a56:	0f be       	out	0x3f, r0	; 63
    2a58:	0f 90       	pop	r0
    2a5a:	1f 90       	pop	r1
    2a5c:	18 95       	reti

00002a5e <__vector_14>:
/*******************************************************************************
 Motor timer interrupt service routines - service a tick from the axis timer
*******************************************************************************/

ISR(X_TIMER_vect)
{
    2a5e:	1f 92       	push	r1
    2a60:	0f 92       	push	r0
    2a62:	0f b6       	in	r0, 0x3f	; 63
    2a64:	0f 92       	push	r0
    2a66:	0b b6       	in	r0, 0x3b	; 59
    2a68:	0f 92       	push	r0
    2a6a:	11 24       	eor	r1, r1
    2a6c:	2f 93       	push	r18
    2a6e:	3f 93       	push	r19
    2a70:	4f 93       	push	r20
    2a72:	5f 93       	push	r21
    2a74:	6f 93       	push	r22
    2a76:	7f 93       	push	r23
    2a78:	8f 93       	push	r24
    2a7a:	9f 93       	push	r25
    2a7c:	af 93       	push	r26
    2a7e:	bf 93       	push	r27
    2a80:	ef 93       	push	r30
    2a82:	ff 93       	push	r31
	ax.x.port->OUTSET = STEP_BIT_bm;			// turn X step bit on
    2a84:	e0 91 20 21 	lds	r30, 0x2120
    2a88:	f0 91 21 21 	lds	r31, 0x2121
    2a8c:	81 e0       	ldi	r24, 0x01	; 1
    2a8e:	85 83       	std	Z+5, r24	; 0x05
	if (--ax.x.counter == 0) {
    2a90:	80 91 07 21 	lds	r24, 0x2107
    2a94:	90 91 08 21 	lds	r25, 0x2108
    2a98:	a0 91 09 21 	lds	r26, 0x2109
    2a9c:	b0 91 0a 21 	lds	r27, 0x210A
    2aa0:	01 97       	sbiw	r24, 0x01	; 1
    2aa2:	a1 09       	sbc	r26, r1
    2aa4:	b1 09       	sbc	r27, r1
    2aa6:	80 93 07 21 	sts	0x2107, r24
    2aaa:	90 93 08 21 	sts	0x2108, r25
    2aae:	a0 93 09 21 	sts	0x2109, r26
    2ab2:	b0 93 0a 21 	sts	0x210A, r27
    2ab6:	00 97       	sbiw	r24, 0x00	; 0
    2ab8:	a1 05       	cpc	r26, r1
    2aba:	b1 05       	cpc	r27, r1
    2abc:	91 f4       	brne	.+36     	; 0x2ae2 <__vector_14+0x84>
		ax.x.timer->CTRLA = TC_CLK_OFF;			// stop the clock
    2abe:	e0 91 22 21 	lds	r30, 0x2122
    2ac2:	f0 91 23 21 	lds	r31, 0x2123
    2ac6:	10 82       	st	Z, r1
		ax.active_axes &= ~X_BIT_bm;			// clear the X active bit
    2ac8:	80 91 7b 21 	lds	r24, 0x217B
    2acc:	8e 7f       	andi	r24, 0xFE	; 254
    2ace:	80 93 7b 21 	sts	0x217B, r24
		if (ax.active_axes == 0) {				// if all axes are done
    2ad2:	88 23       	and	r24, r24
    2ad4:	31 f4       	brne	.+12     	; 0x2ae2 <__vector_14+0x84>
			st_print_done_line("X");			// ++++ DEBUG STATEMENT ++++
    2ad6:	80 e3       	ldi	r24, 0x30	; 48
    2ad8:	90 e2       	ldi	r25, 0x20	; 32
    2ada:	0e 94 44 17 	call	0x2e88	; 0x2e88 <st_print_done_line>
			st_execute_line();					// ...run next line
    2ade:	0e 94 cb 12 	call	0x2596	; 0x2596 <st_execute_line>
		}
	}
//	_delay_us(STEP_PULSE_MICROSECONDS);			// delay for correct pulse width
	ax.x.port->OUTCLR = STEP_BIT_bm;			// turn X step bit off
    2ae2:	e0 91 20 21 	lds	r30, 0x2120
    2ae6:	f0 91 21 21 	lds	r31, 0x2121
    2aea:	81 e0       	ldi	r24, 0x01	; 1
    2aec:	86 83       	std	Z+6, r24	; 0x06
}
    2aee:	ff 91       	pop	r31
    2af0:	ef 91       	pop	r30
    2af2:	bf 91       	pop	r27
    2af4:	af 91       	pop	r26
    2af6:	9f 91       	pop	r25
    2af8:	8f 91       	pop	r24
    2afa:	7f 91       	pop	r23
    2afc:	6f 91       	pop	r22
    2afe:	5f 91       	pop	r21
    2b00:	4f 91       	pop	r20
    2b02:	3f 91       	pop	r19
    2b04:	2f 91       	pop	r18
    2b06:	0f 90       	pop	r0
    2b08:	0b be       	out	0x3b, r0	; 59
    2b0a:	0f 90       	pop	r0
    2b0c:	0f be       	out	0x3f, r0	; 63
    2b0e:	0f 90       	pop	r0
    2b10:	1f 90       	pop	r1
    2b12:	18 95       	reti

00002b14 <beginSerial>:
   "baud" value is ignored and set internally to the routine
 */

void beginSerial(long baud) 
{
	PORTC.DIRCLR = (1<<2); 					// clr PORTC:6 receive pin as input
    2b14:	e0 e4       	ldi	r30, 0x40	; 64
    2b16:	f6 e0       	ldi	r31, 0x06	; 6
    2b18:	84 e0       	ldi	r24, 0x04	; 4
    2b1a:	82 83       	std	Z+2, r24	; 0x02
	PORTC.DIRSET = (1<<3); 					// set PORTC:7 transmit pin as output
    2b1c:	88 e0       	ldi	r24, 0x08	; 8
    2b1e:	81 83       	std	Z+1, r24	; 0x01
	PORTC.OUTSET = (1<<3);					// set TX pin HI as initial state
    2b20:	85 83       	std	Z+5, r24	; 0x05

	USARTC0.BAUDCTRLA = USB_BSEL;
    2b22:	e0 ea       	ldi	r30, 0xA0	; 160
    2b24:	f8 e0       	ldi	r31, 0x08	; 8
    2b26:	81 e2       	ldi	r24, 0x21	; 33
    2b28:	86 83       	std	Z+6, r24	; 0x06
	USARTC0.BAUDCTRLB = USB_BSCALE;
    2b2a:	80 ef       	ldi	r24, 0xF0	; 240
    2b2c:	87 83       	std	Z+7, r24	; 0x07
	USARTC0.CTRLB = USART_TXEN_bm | USART_RXEN_bm; // enable tx and rx on USART
    2b2e:	88 e1       	ldi	r24, 0x18	; 24
    2b30:	84 83       	std	Z+4, r24	; 0x04
	USARTC0.CTRLA = USART_RXCINTLVL_MED_gc;		   // receive interrupt medium level
    2b32:	80 e2       	ldi	r24, 0x20	; 32
    2b34:	83 83       	std	Z+3, r24	; 0x03
    2b36:	80 e2       	ldi	r24, 0x20	; 32
    2b38:	93 e0       	ldi	r25, 0x03	; 3
    2b3a:	01 97       	sbiw	r24, 0x01	; 1
    2b3c:	f1 f7       	brne	.-4      	; 0x2b3a <beginSerial+0x26>

	_delay_us(100);							// give it a chance to settle before use
}
    2b3e:	08 95       	ret

00002b40 <beginSerialC1>:

void beginSerialC1(long baud) 
{
	PORTC.DIRCLR = (1<<6); 					// clr PORTC:6 receive pin as input
    2b40:	e0 e4       	ldi	r30, 0x40	; 64
    2b42:	f6 e0       	ldi	r31, 0x06	; 6
    2b44:	80 e4       	ldi	r24, 0x40	; 64
    2b46:	82 83       	std	Z+2, r24	; 0x02
	PORTC.DIRSET = (1<<7); 					// set PORTC:7 transmit pin as output
    2b48:	80 e8       	ldi	r24, 0x80	; 128
    2b4a:	81 83       	std	Z+1, r24	; 0x01
	PORTC.OUTSET = (1<<7);					// set TX pin HI as initial state
    2b4c:	85 83       	std	Z+5, r24	; 0x05
//	PORTC.DIRSET = enableDE_bm;				// set PORTC:5 for DE line as output
//	PORTC.OUTCLR = enableDE_bm;        		// clr PORTC:5 (disabled)
//	PORTC.DIRSET = enableRE_bm;				// set PORTC:4 for ~RE line as output
//	PORTC.OUTCLR = enableRE_bm;				// clr PORTC:4 (enabled) 

	USARTC1.BAUDCTRLA = USB_BSEL;
    2b4e:	e0 eb       	ldi	r30, 0xB0	; 176
    2b50:	f8 e0       	ldi	r31, 0x08	; 8
    2b52:	81 e2       	ldi	r24, 0x21	; 33
    2b54:	86 83       	std	Z+6, r24	; 0x06
	USARTC1.BAUDCTRLB = USB_BSCALE;
    2b56:	80 ef       	ldi	r24, 0xF0	; 240
    2b58:	87 83       	std	Z+7, r24	; 0x07
	USARTC1.CTRLB = USART_TXEN_bm | USART_RXEN_bm; // enable tx and rx on USART
    2b5a:	88 e1       	ldi	r24, 0x18	; 24
    2b5c:	84 83       	std	Z+4, r24	; 0x04
	USARTC1.CTRLA = USART_RXCINTLVL_MED_gc;		   // receive interrupt medium level
    2b5e:	80 e2       	ldi	r24, 0x20	; 32
    2b60:	83 83       	std	Z+3, r24	; 0x03
    2b62:	80 e2       	ldi	r24, 0x20	; 32
    2b64:	93 e0       	ldi	r25, 0x03	; 3
    2b66:	01 97       	sbiw	r24, 0x01	; 1
    2b68:	f1 f7       	brne	.-4      	; 0x2b66 <beginSerialC1+0x26>

	_delay_us(100);							// give it a chance to settle before use
}
    2b6a:	08 95       	ret

00002b6c <__vector_25>:

/* ISR for USB serial RX - receive serial byte from USB port*/

ISR(USARTC0_RXC_vect)
{
    2b6c:	1f 92       	push	r1
    2b6e:	0f 92       	push	r0
    2b70:	0f b6       	in	r0, 0x3f	; 63
    2b72:	0f 92       	push	r0
    2b74:	0b b6       	in	r0, 0x3b	; 59
    2b76:	0f 92       	push	r0
    2b78:	11 24       	eor	r1, r1
    2b7a:	2f 93       	push	r18
    2b7c:	8f 93       	push	r24
    2b7e:	9f 93       	push	r25
    2b80:	ef 93       	push	r30
    2b82:	ff 93       	push	r31
	unsigned char c = USARTC0.DATA;
    2b84:	20 91 a0 08 	lds	r18, 0x08A0
	uint8_t i = (rx_buffer_head + 1) & RX_BUFFER_MASK;
    2b88:	e0 91 39 20 	lds	r30, 0x2039
    2b8c:	ef 5f       	subi	r30, 0xFF	; 255
    2b8e:	9e 2f       	mov	r25, r30
    2b90:	9f 77       	andi	r25, 0x7F	; 127
    2b92:	e1 50       	subi	r30, 0x01	; 1
	/*  If we should be storing the received character into the location
		just before the tail (meaning that the head would advance to the
		current location of the tail), we're about to overflow the buffer
		and so we don't write the character or advance the head. */

	if (i != rx_buffer_tail) {
    2b94:	80 91 3a 20 	lds	r24, 0x203A
    2b98:	98 17       	cp	r25, r24
    2b9a:	31 f0       	breq	.+12     	; 0x2ba8 <__vector_25+0x3c>
		rx_buffer[rx_buffer_head] = c;
    2b9c:	f0 e0       	ldi	r31, 0x00	; 0
    2b9e:	e4 5e       	subi	r30, 0xE4	; 228
    2ba0:	fd 4d       	sbci	r31, 0xDD	; 221
    2ba2:	20 83       	st	Z, r18
		rx_buffer_head = i;
    2ba4:	90 93 39 20 	sts	0x2039, r25
	}
}
    2ba8:	ff 91       	pop	r31
    2baa:	ef 91       	pop	r30
    2bac:	9f 91       	pop	r25
    2bae:	8f 91       	pop	r24
    2bb0:	2f 91       	pop	r18
    2bb2:	0f 90       	pop	r0
    2bb4:	0b be       	out	0x3b, r0	; 59
    2bb6:	0f 90       	pop	r0
    2bb8:	0f be       	out	0x3f, r0	; 63
    2bba:	0f 90       	pop	r0
    2bbc:	1f 90       	pop	r1
    2bbe:	18 95       	reti

00002bc0 <__vector_28>:

ISR(USARTC1_RXC_vect)
{
    2bc0:	1f 92       	push	r1
    2bc2:	0f 92       	push	r0
    2bc4:	0f b6       	in	r0, 0x3f	; 63
    2bc6:	0f 92       	push	r0
    2bc8:	0b b6       	in	r0, 0x3b	; 59
    2bca:	0f 92       	push	r0
    2bcc:	11 24       	eor	r1, r1
    2bce:	2f 93       	push	r18
    2bd0:	8f 93       	push	r24
    2bd2:	9f 93       	push	r25
    2bd4:	ef 93       	push	r30
    2bd6:	ff 93       	push	r31
	unsigned char c = USARTC1.DATA;
    2bd8:	20 91 b0 08 	lds	r18, 0x08B0
	uint8_t i = (rx_buffer_head + 1) & RX_BUFFER_MASK;
    2bdc:	e0 91 39 20 	lds	r30, 0x2039
    2be0:	ef 5f       	subi	r30, 0xFF	; 255
    2be2:	9e 2f       	mov	r25, r30
    2be4:	9f 77       	andi	r25, 0x7F	; 127
    2be6:	e1 50       	subi	r30, 0x01	; 1
	/*  If we should be storing the received character into the location
		just before the tail (meaning that the head would advance to the
		current location of the tail), we're about to overflow the buffer
		and so we don't write the character or advance the head. */

	if (i != rx_buffer_tail) {
    2be8:	80 91 3a 20 	lds	r24, 0x203A
    2bec:	98 17       	cp	r25, r24
    2bee:	31 f0       	breq	.+12     	; 0x2bfc <__vector_28+0x3c>
		rx_buffer[rx_buffer_head] = c;
    2bf0:	f0 e0       	ldi	r31, 0x00	; 0
    2bf2:	e4 5e       	subi	r30, 0xE4	; 228
    2bf4:	fd 4d       	sbci	r31, 0xDD	; 221
    2bf6:	20 83       	st	Z, r18
		rx_buffer_head = i;
    2bf8:	90 93 39 20 	sts	0x2039, r25
	}
}
    2bfc:	ff 91       	pop	r31
    2bfe:	ef 91       	pop	r30
    2c00:	9f 91       	pop	r25
    2c02:	8f 91       	pop	r24
    2c04:	2f 91       	pop	r18
    2c06:	0f 90       	pop	r0
    2c08:	0b be       	out	0x3b, r0	; 59
    2c0a:	0f 90       	pop	r0
    2c0c:	0f be       	out	0x3f, r0	; 63
    2c0e:	0f 90       	pop	r0
    2c10:	1f 90       	pop	r1
    2c12:	18 95       	reti

00002c14 <serialWrite>:

/* writeSerial() - write character to serial port */

void serialWrite(unsigned char c) 
{
    2c14:	98 2f       	mov	r25, r24
	while(!(USARTC0.STATUS & USART_DREIF_bm)); 	// spin until TX data register is available
    2c16:	80 91 a1 08 	lds	r24, 0x08A1
    2c1a:	85 ff       	sbrs	r24, 5
    2c1c:	fc cf       	rjmp	.-8      	; 0x2c16 <serialWrite+0x2>
	USARTC0.DATA = c;							// write data register
    2c1e:	90 93 a0 08 	sts	0x08A0, r25
}
    2c22:	08 95       	ret

00002c24 <serialAvailable>:
*/

/* serialAvailable() - optimized for 8 bit operation */

uint8_t serialAvailable() 
{
    2c24:	80 91 39 20 	lds	r24, 0x2039
    2c28:	90 91 3a 20 	lds	r25, 0x203A
    2c2c:	89 1b       	sub	r24, r25
	return (RX_BUFFER_SIZE + rx_buffer_head - rx_buffer_tail) & RX_BUFFER_MASK;
}
    2c2e:	8f 77       	andi	r24, 0x7F	; 127
    2c30:	08 95       	ret

00002c32 <serialRead>:
*/

char serialRead() 
{
	/* if the head isn't ahead of the tail, we don't have any characters */
	if (rx_buffer_head == rx_buffer_tail) {
    2c32:	90 91 3a 20 	lds	r25, 0x203A
    2c36:	80 91 39 20 	lds	r24, 0x2039
    2c3a:	89 17       	cp	r24, r25
    2c3c:	11 f4       	brne	.+4      	; 0x2c42 <serialRead+0x10>
    2c3e:	84 e0       	ldi	r24, 0x04	; 4
    2c40:	08 95       	ret
		return 0x04;											// ASCII EOT
	} else {
		char c = rx_buffer[rx_buffer_tail];
    2c42:	e9 2f       	mov	r30, r25
    2c44:	f0 e0       	ldi	r31, 0x00	; 0
    2c46:	e4 5e       	subi	r30, 0xE4	; 228
    2c48:	fd 4d       	sbci	r31, 0xDD	; 221
    2c4a:	80 81       	ld	r24, Z
//		rx_buffer_tail = (rx_buffer_tail + 1) % RX_BUFFER_SIZE;	// original code
		rx_buffer_tail = (rx_buffer_tail + 1) & RX_BUFFER_MASK;	// optimized code
    2c4c:	9f 5f       	subi	r25, 0xFF	; 255
    2c4e:	9f 77       	andi	r25, 0x7F	; 127
    2c50:	90 93 3a 20 	sts	0x203A, r25
		return c;
	}
}
    2c54:	08 95       	ret

00002c56 <serialFlush>:
	/*  don't reverse this or there may be problems if the RX interrupt
		occurs after reading the value of rx_buffer_head but before writing
		the value to rx_buffer_tail; the previous value of rx_buffer_head
		may be written to rx_buffer_tail, making it appear as if the buffer
		were full, not empty. */
	rx_buffer_head = rx_buffer_tail;
    2c56:	80 91 3a 20 	lds	r24, 0x203A
    2c5a:	80 93 39 20 	sts	0x2039, r24
}
    2c5e:	08 95       	ret

00002c60 <printString>:
	serialWrite(c);
}
*/

void printString(const char *s)
{
    2c60:	fc 01       	movw	r30, r24
    2c62:	07 c0       	rjmp	.+14     	; 0x2c72 <printString+0x12>

/* writeSerial() - write character to serial port */

void serialWrite(unsigned char c) 
{
	while(!(USARTC0.STATUS & USART_DREIF_bm)); 	// spin until TX data register is available
    2c64:	80 91 a1 08 	lds	r24, 0x08A1
    2c68:	85 ff       	sbrs	r24, 5
    2c6a:	fc cf       	rjmp	.-8      	; 0x2c64 <printString+0x4>
*/

void printString(const char *s)
{
	while (*s) {
		printByte(*s++);
    2c6c:	31 96       	adiw	r30, 0x01	; 1
/* writeSerial() - write character to serial port */

void serialWrite(unsigned char c) 
{
	while(!(USARTC0.STATUS & USART_DREIF_bm)); 	// spin until TX data register is available
	USARTC0.DATA = c;							// write data register
    2c6e:	90 93 a0 08 	sts	0x08A0, r25
}
*/

void printString(const char *s)
{
	while (*s) {
    2c72:	90 81       	ld	r25, Z
    2c74:	99 23       	and	r25, r25
    2c76:	b1 f7       	brne	.-20     	; 0x2c64 <printString+0x4>
		printByte(*s++);
	}
}
    2c78:	08 95       	ret

00002c7a <printPgmString>:

/*  printPgmString() - print a string stored in PGM-memory */
void printPgmString(const char *s)
{
    2c7a:	9c 01       	movw	r18, r24
    2c7c:	06 c0       	rjmp	.+12     	; 0x2c8a <printPgmString+0x10>

/* writeSerial() - write character to serial port */

void serialWrite(unsigned char c) 
{
	while(!(USARTC0.STATUS & USART_DREIF_bm)); 	// spin until TX data register is available
    2c7e:	80 91 a1 08 	lds	r24, 0x08A1
    2c82:	85 ff       	sbrs	r24, 5
    2c84:	fc cf       	rjmp	.-8      	; 0x2c7e <printPgmString+0x4>
	USARTC0.DATA = c;							// write data register
    2c86:	90 93 a0 08 	sts	0x08A0, r25
    2c8a:	f9 01       	movw	r30, r18

/*  printPgmString() - print a string stored in PGM-memory */
void printPgmString(const char *s)
{
	unsigned char c;
	while ((c = pgm_read_byte_near(s++))) {
    2c8c:	2f 5f       	subi	r18, 0xFF	; 255
    2c8e:	3f 4f       	sbci	r19, 0xFF	; 255
    2c90:	94 91       	lpm	r25, Z+
    2c92:	99 23       	and	r25, r25
    2c94:	a1 f7       	brne	.-24     	; 0x2c7e <printPgmString+0x4>
		printByte(c);
	}
}
    2c96:	08 95       	ret

00002c98 <printIntegerInBase>:

/* printIntegerInBase() */

void printIntegerInBase(unsigned long n, unsigned long base)
{ 
    2c98:	2f 92       	push	r2
    2c9a:	3f 92       	push	r3
    2c9c:	4f 92       	push	r4
    2c9e:	5f 92       	push	r5
    2ca0:	6f 92       	push	r6
    2ca2:	7f 92       	push	r7
    2ca4:	8f 92       	push	r8
    2ca6:	9f 92       	push	r9
    2ca8:	af 92       	push	r10
    2caa:	bf 92       	push	r11
    2cac:	cf 92       	push	r12
    2cae:	df 92       	push	r13
    2cb0:	ef 92       	push	r14
    2cb2:	ff 92       	push	r15
    2cb4:	0f 93       	push	r16
    2cb6:	1f 93       	push	r17
    2cb8:	df 93       	push	r29
    2cba:	cf 93       	push	r28
    2cbc:	cd b7       	in	r28, 0x3d	; 61
    2cbe:	de b7       	in	r29, 0x3e	; 62
    2cc0:	a0 97       	sbiw	r28, 0x20	; 32
    2cc2:	cd bf       	out	0x3d, r28	; 61
    2cc4:	de bf       	out	0x3e, r29	; 62
    2cc6:	6b 01       	movw	r12, r22
    2cc8:	7c 01       	movw	r14, r24
    2cca:	29 01       	movw	r4, r18
    2ccc:	3a 01       	movw	r6, r20
	unsigned char buf[8 * sizeof(long)]; // Assumes 8-bit chars. 
	unsigned long i = 0;

	if (n == 0) {
    2cce:	61 15       	cp	r22, r1
    2cd0:	71 05       	cpc	r23, r1
    2cd2:	81 05       	cpc	r24, r1
    2cd4:	91 05       	cpc	r25, r1
    2cd6:	41 f4       	brne	.+16     	; 0x2ce8 <printIntegerInBase+0x50>

/* writeSerial() - write character to serial port */

void serialWrite(unsigned char c) 
{
	while(!(USARTC0.STATUS & USART_DREIF_bm)); 	// spin until TX data register is available
    2cd8:	80 91 a1 08 	lds	r24, 0x08A1
    2cdc:	85 ff       	sbrs	r24, 5
    2cde:	fc cf       	rjmp	.-8      	; 0x2cd8 <printIntegerInBase+0x40>
	USARTC0.DATA = c;							// write data register
    2ce0:	80 e3       	ldi	r24, 0x30	; 48
    2ce2:	80 93 a0 08 	sts	0x08A0, r24
    2ce6:	49 c0       	rjmp	.+146    	; 0x2d7a <printIntegerInBase+0xe2>
	unsigned char buf[8 * sizeof(long)]; // Assumes 8-bit chars. 
	unsigned long i = 0;

	if (n == 0) {
		printByte('0');
		return;
    2ce8:	88 24       	eor	r8, r8
    2cea:	99 24       	eor	r9, r9
    2cec:	54 01       	movw	r10, r8
	} 

	while (n > 0) {
		buf[i++] = n % base;
    2cee:	1e 01       	movw	r2, r28
    2cf0:	08 94       	sec
    2cf2:	21 1c       	adc	r2, r1
    2cf4:	31 1c       	adc	r3, r1
    2cf6:	81 01       	movw	r16, r2
    2cf8:	08 0d       	add	r16, r8
    2cfa:	19 1d       	adc	r17, r9
    2cfc:	c7 01       	movw	r24, r14
    2cfe:	b6 01       	movw	r22, r12
    2d00:	a3 01       	movw	r20, r6
    2d02:	92 01       	movw	r18, r4
    2d04:	0e 94 31 1d 	call	0x3a62	; 0x3a62 <__udivmodsi4>
    2d08:	f8 01       	movw	r30, r16
    2d0a:	60 83       	st	Z, r22
    2d0c:	08 94       	sec
    2d0e:	81 1c       	adc	r8, r1
    2d10:	91 1c       	adc	r9, r1
    2d12:	a1 1c       	adc	r10, r1
    2d14:	b1 1c       	adc	r11, r1
		n /= base;
    2d16:	c7 01       	movw	r24, r14
    2d18:	b6 01       	movw	r22, r12
    2d1a:	a3 01       	movw	r20, r6
    2d1c:	92 01       	movw	r18, r4
    2d1e:	0e 94 31 1d 	call	0x3a62	; 0x3a62 <__udivmodsi4>
    2d22:	c9 01       	movw	r24, r18
    2d24:	da 01       	movw	r26, r20
    2d26:	6c 01       	movw	r12, r24
    2d28:	7d 01       	movw	r14, r26
	if (n == 0) {
		printByte('0');
		return;
	} 

	while (n > 0) {
    2d2a:	c1 14       	cp	r12, r1
    2d2c:	d1 04       	cpc	r13, r1
    2d2e:	e1 04       	cpc	r14, r1
    2d30:	f1 04       	cpc	r15, r1
    2d32:	09 f7       	brne	.-62     	; 0x2cf6 <printIntegerInBase+0x5e>
    2d34:	91 01       	movw	r18, r2
    2d36:	28 0d       	add	r18, r8
    2d38:	39 1d       	adc	r19, r9
		buf[i++] = n % base;
		n /= base;
	}

	for (; i > 0; i--)
    2d3a:	be 01       	movw	r22, r28
    2d3c:	6f 5f       	subi	r22, 0xFF	; 255
    2d3e:	7f 4f       	sbci	r23, 0xFF	; 255
		printByte(buf[i - 1] < 10 ?
    2d40:	d5 01       	movw	r26, r10
    2d42:	c4 01       	movw	r24, r8
    2d44:	01 97       	sbiw	r24, 0x01	; 1
    2d46:	a1 09       	sbc	r26, r1
    2d48:	b1 09       	sbc	r27, r1
    2d4a:	ac 01       	movw	r20, r24
    2d4c:	48 19       	sub	r20, r8
    2d4e:	59 09       	sbc	r21, r9
    2d50:	11 c0       	rjmp	.+34     	; 0x2d74 <printIntegerInBase+0xdc>
    2d52:	fa 01       	movw	r30, r20
    2d54:	e2 0f       	add	r30, r18
    2d56:	f3 1f       	adc	r31, r19
    2d58:	e0 81       	ld	r30, Z
    2d5a:	ea 30       	cpi	r30, 0x0A	; 10
    2d5c:	10 f4       	brcc	.+4      	; 0x2d62 <printIntegerInBase+0xca>
    2d5e:	e0 5d       	subi	r30, 0xD0	; 208
    2d60:	01 c0       	rjmp	.+2      	; 0x2d64 <printIntegerInBase+0xcc>
    2d62:	e9 5c       	subi	r30, 0xC9	; 201

/* writeSerial() - write character to serial port */

void serialWrite(unsigned char c) 
{
	while(!(USARTC0.STATUS & USART_DREIF_bm)); 	// spin until TX data register is available
    2d64:	80 91 a1 08 	lds	r24, 0x08A1
    2d68:	85 ff       	sbrs	r24, 5
    2d6a:	fc cf       	rjmp	.-8      	; 0x2d64 <printIntegerInBase+0xcc>
	USARTC0.DATA = c;							// write data register
    2d6c:	e0 93 a0 08 	sts	0x08A0, r30
    2d70:	21 50       	subi	r18, 0x01	; 1
    2d72:	30 40       	sbci	r19, 0x00	; 0
	while (n > 0) {
		buf[i++] = n % base;
		n /= base;
	}

	for (; i > 0; i--)
    2d74:	62 17       	cp	r22, r18
    2d76:	73 07       	cpc	r23, r19
    2d78:	61 f7       	brne	.-40     	; 0x2d52 <printIntegerInBase+0xba>
		printByte(buf[i - 1] < 10 ?
			'0' + buf[i - 1] :
			'A' + buf[i - 1] - 10);
}
    2d7a:	a0 96       	adiw	r28, 0x20	; 32
    2d7c:	cd bf       	out	0x3d, r28	; 61
    2d7e:	de bf       	out	0x3e, r29	; 62
    2d80:	cf 91       	pop	r28
    2d82:	df 91       	pop	r29
    2d84:	1f 91       	pop	r17
    2d86:	0f 91       	pop	r16
    2d88:	ff 90       	pop	r15
    2d8a:	ef 90       	pop	r14
    2d8c:	df 90       	pop	r13
    2d8e:	cf 90       	pop	r12
    2d90:	bf 90       	pop	r11
    2d92:	af 90       	pop	r10
    2d94:	9f 90       	pop	r9
    2d96:	8f 90       	pop	r8
    2d98:	7f 90       	pop	r7
    2d9a:	6f 90       	pop	r6
    2d9c:	5f 90       	pop	r5
    2d9e:	4f 90       	pop	r4
    2da0:	3f 90       	pop	r3
    2da2:	2f 90       	pop	r2
    2da4:	08 95       	ret

00002da6 <printInteger>:

/* printInteger() */

void printInteger(long n)
{
    2da6:	9b 01       	movw	r18, r22
    2da8:	ac 01       	movw	r20, r24
	if (n < 0) {
    2daa:	97 ff       	sbrs	r25, 7
    2dac:	0e c0       	rjmp	.+28     	; 0x2dca <printInteger+0x24>

/* writeSerial() - write character to serial port */

void serialWrite(unsigned char c) 
{
	while(!(USARTC0.STATUS & USART_DREIF_bm)); 	// spin until TX data register is available
    2dae:	80 91 a1 08 	lds	r24, 0x08A1
    2db2:	85 ff       	sbrs	r24, 5
    2db4:	fc cf       	rjmp	.-8      	; 0x2dae <printInteger+0x8>
	USARTC0.DATA = c;							// write data register
    2db6:	8d e2       	ldi	r24, 0x2D	; 45
    2db8:	80 93 a0 08 	sts	0x08A0, r24

void printInteger(long n)
{
	if (n < 0) {
		printByte('-');
		n = -n;
    2dbc:	50 95       	com	r21
    2dbe:	40 95       	com	r20
    2dc0:	30 95       	com	r19
    2dc2:	21 95       	neg	r18
    2dc4:	3f 4f       	sbci	r19, 0xFF	; 255
    2dc6:	4f 4f       	sbci	r20, 0xFF	; 255
    2dc8:	5f 4f       	sbci	r21, 0xFF	; 255
	}
	printIntegerInBase(n, 10);
    2dca:	ca 01       	movw	r24, r20
    2dcc:	b9 01       	movw	r22, r18
    2dce:	2a e0       	ldi	r18, 0x0A	; 10
    2dd0:	30 e0       	ldi	r19, 0x00	; 0
    2dd2:	40 e0       	ldi	r20, 0x00	; 0
    2dd4:	50 e0       	ldi	r21, 0x00	; 0
    2dd6:	0e 94 4c 16 	call	0x2c98	; 0x2c98 <printIntegerInBase>
}
    2dda:	08 95       	ret

00002ddc <printHex>:

/* printHex() */

void printHex(unsigned long n)
{
	printIntegerInBase(n, 16);
    2ddc:	20 e1       	ldi	r18, 0x10	; 16
    2dde:	30 e0       	ldi	r19, 0x00	; 0
    2de0:	40 e0       	ldi	r20, 0x00	; 0
    2de2:	50 e0       	ldi	r21, 0x00	; 0
    2de4:	0e 94 4c 16 	call	0x2c98	; 0x2c98 <printIntegerInBase>
}
    2de8:	08 95       	ret

00002dea <printFloat>:
}

/* printFloat() */

void printFloat(double n)
{
    2dea:	ef 92       	push	r14
    2dec:	ff 92       	push	r15
    2dee:	0f 93       	push	r16
    2df0:	1f 93       	push	r17
    2df2:	df 93       	push	r29
    2df4:	cf 93       	push	r28
    2df6:	00 d0       	rcall	.+0      	; 0x2df8 <printFloat+0xe>
    2df8:	0f 92       	push	r0
    2dfa:	cd b7       	in	r28, 0x3d	; 61
    2dfc:	de b7       	in	r29, 0x3e	; 62
	double integer_part, fractional_part;
	fractional_part = modf(n, &integer_part);
    2dfe:	ae 01       	movw	r20, r28
    2e00:	4f 5f       	subi	r20, 0xFF	; 255
    2e02:	5f 4f       	sbci	r21, 0xFF	; 255
    2e04:	0e 94 0d 1c 	call	0x381a	; 0x381a <modf>
    2e08:	7b 01       	movw	r14, r22
    2e0a:	8c 01       	movw	r16, r24
	printInteger(integer_part);
    2e0c:	69 81       	ldd	r22, Y+1	; 0x01
    2e0e:	7a 81       	ldd	r23, Y+2	; 0x02
    2e10:	8b 81       	ldd	r24, Y+3	; 0x03
    2e12:	9c 81       	ldd	r25, Y+4	; 0x04
    2e14:	0e 94 ba 19 	call	0x3374	; 0x3374 <__fixsfsi>
    2e18:	0e 94 d3 16 	call	0x2da6	; 0x2da6 <printInteger>

/* writeSerial() - write character to serial port */

void serialWrite(unsigned char c) 
{
	while(!(USARTC0.STATUS & USART_DREIF_bm)); 	// spin until TX data register is available
    2e1c:	80 91 a1 08 	lds	r24, 0x08A1
    2e20:	85 ff       	sbrs	r24, 5
    2e22:	fc cf       	rjmp	.-8      	; 0x2e1c <printFloat+0x32>
	USARTC0.DATA = c;							// write data register
    2e24:	8e e2       	ldi	r24, 0x2E	; 46
    2e26:	80 93 a0 08 	sts	0x08A0, r24
{
	double integer_part, fractional_part;
	fractional_part = modf(n, &integer_part);
	printInteger(integer_part);
	printByte('.');
	printInteger(round(fractional_part*1000));
    2e2a:	c8 01       	movw	r24, r16
    2e2c:	b7 01       	movw	r22, r14
    2e2e:	20 e0       	ldi	r18, 0x00	; 0
    2e30:	30 e0       	ldi	r19, 0x00	; 0
    2e32:	4a e7       	ldi	r20, 0x7A	; 122
    2e34:	54 e4       	ldi	r21, 0x44	; 68
    2e36:	0e 94 40 1c 	call	0x3880	; 0x3880 <__mulsf3>
    2e3a:	0e 94 a3 1c 	call	0x3946	; 0x3946 <round>
    2e3e:	0e 94 ba 19 	call	0x3374	; 0x3374 <__fixsfsi>
    2e42:	0e 94 d3 16 	call	0x2da6	; 0x2da6 <printInteger>
}
    2e46:	24 96       	adiw	r28, 0x04	; 4
    2e48:	cd bf       	out	0x3d, r28	; 61
    2e4a:	de bf       	out	0x3e, r29	; 62
    2e4c:	cf 91       	pop	r28
    2e4e:	df 91       	pop	r29
    2e50:	1f 91       	pop	r17
    2e52:	0f 91       	pop	r16
    2e54:	ff 90       	pop	r15
    2e56:	ef 90       	pop	r14
    2e58:	08 95       	ret

00002e5a <st_print_active>:
{
	printPgmString(PSTR(" Done["));		printString(axis);	
 	printPgmString(PSTR("]"));
}

void st_print_active(struct Axes *ax) {
    2e5a:	0f 93       	push	r16
    2e5c:	1f 93       	push	r17
    2e5e:	8c 01       	movw	r16, r24
	printPgmString(PSTR("ACTIVE= "));	printHex(ax->active_axes);
    2e60:	8d ee       	ldi	r24, 0xED	; 237
    2e62:	93 e0       	ldi	r25, 0x03	; 3
    2e64:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
    2e68:	0c 58       	subi	r16, 0x8C	; 140
    2e6a:	1f 4f       	sbci	r17, 0xFF	; 255
    2e6c:	f8 01       	movw	r30, r16
    2e6e:	60 81       	ld	r22, Z
    2e70:	70 e0       	ldi	r23, 0x00	; 0
    2e72:	80 e0       	ldi	r24, 0x00	; 0
    2e74:	90 e0       	ldi	r25, 0x00	; 0
    2e76:	0e 94 ee 16 	call	0x2ddc	; 0x2ddc <printHex>
	printPgmString(PSTR("\r\n"));
    2e7a:	8a ee       	ldi	r24, 0xEA	; 234
    2e7c:	93 e0       	ldi	r25, 0x03	; 3
    2e7e:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
}
    2e82:	1f 91       	pop	r17
    2e84:	0f 91       	pop	r16
    2e86:	08 95       	ret

00002e88 <st_print_done_line>:
	printPgmString(PSTR(", Z="));		printInteger(line.steps_z);
	printPgmString(PSTR(" uS="));		printInteger(line.microseconds);
}

void st_print_done_line(char *axis) \
{
    2e88:	0f 93       	push	r16
    2e8a:	1f 93       	push	r17
    2e8c:	8c 01       	movw	r16, r24
	printPgmString(PSTR(" Done["));		printString(axis);	
    2e8e:	88 ef       	ldi	r24, 0xF8	; 248
    2e90:	93 e0       	ldi	r25, 0x03	; 3
    2e92:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
    2e96:	c8 01       	movw	r24, r16
    2e98:	0e 94 30 16 	call	0x2c60	; 0x2c60 <printString>
 	printPgmString(PSTR("]"));
    2e9c:	86 ef       	ldi	r24, 0xF6	; 246
    2e9e:	93 e0       	ldi	r25, 0x03	; 3
    2ea0:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
}
    2ea4:	1f 91       	pop	r17
    2ea6:	0f 91       	pop	r16
    2ea8:	08 95       	ret

00002eaa <st_print_exec_line>:
	printPgmString(PSTR(", Z="));		printInteger(line.steps_z);
	printPgmString(PSTR(" uS="));		printInteger(line.microseconds);
}

void st_print_exec_line(struct Line line) \
{
    2eaa:	2f 92       	push	r2
    2eac:	3f 92       	push	r3
    2eae:	4f 92       	push	r4
    2eb0:	5f 92       	push	r5
    2eb2:	6f 92       	push	r6
    2eb4:	7f 92       	push	r7
    2eb6:	8f 92       	push	r8
    2eb8:	9f 92       	push	r9
    2eba:	af 92       	push	r10
    2ebc:	bf 92       	push	r11
    2ebe:	cf 92       	push	r12
    2ec0:	df 92       	push	r13
    2ec2:	ef 92       	push	r14
    2ec4:	ff 92       	push	r15
    2ec6:	0f 93       	push	r16
    2ec8:	1f 93       	push	r17
    2eca:	df 93       	push	r29
    2ecc:	cf 93       	push	r28
    2ece:	cd b7       	in	r28, 0x3d	; 61
    2ed0:	de b7       	in	r29, 0x3e	; 62
    2ed2:	60 97       	sbiw	r28, 0x10	; 16
    2ed4:	cd bf       	out	0x3d, r28	; 61
    2ed6:	de bf       	out	0x3e, r29	; 62
    2ed8:	a9 82       	std	Y+1, r10	; 0x01
    2eda:	ba 82       	std	Y+2, r11	; 0x02
    2edc:	cb 82       	std	Y+3, r12	; 0x03
    2ede:	dc 82       	std	Y+4, r13	; 0x04
    2ee0:	ed 82       	std	Y+5, r14	; 0x05
    2ee2:	fe 82       	std	Y+6, r15	; 0x06
    2ee4:	0f 83       	std	Y+7, r16	; 0x07
    2ee6:	18 87       	std	Y+8, r17	; 0x08
    2ee8:	29 87       	std	Y+9, r18	; 0x09
    2eea:	3a 87       	std	Y+10, r19	; 0x0a
    2eec:	4b 87       	std	Y+11, r20	; 0x0b
    2eee:	5c 87       	std	Y+12, r21	; 0x0c
    2ef0:	6d 87       	std	Y+13, r22	; 0x0d
    2ef2:	7e 87       	std	Y+14, r23	; 0x0e
    2ef4:	8f 87       	std	Y+15, r24	; 0x0f
    2ef6:	98 8b       	std	Y+16, r25	; 0x10
    2ef8:	e9 80       	ldd	r14, Y+1	; 0x01
    2efa:	fa 80       	ldd	r15, Y+2	; 0x02
    2efc:	0b 81       	ldd	r16, Y+3	; 0x03
    2efe:	1c 81       	ldd	r17, Y+4	; 0x04
    2f00:	ad 80       	ldd	r10, Y+5	; 0x05
    2f02:	be 80       	ldd	r11, Y+6	; 0x06
    2f04:	cf 80       	ldd	r12, Y+7	; 0x07
    2f06:	d8 84       	ldd	r13, Y+8	; 0x08
    2f08:	69 84       	ldd	r6, Y+9	; 0x09
    2f0a:	7a 84       	ldd	r7, Y+10	; 0x0a
    2f0c:	8b 84       	ldd	r8, Y+11	; 0x0b
    2f0e:	9c 84       	ldd	r9, Y+12	; 0x0c
    2f10:	2d 84       	ldd	r2, Y+13	; 0x0d
    2f12:	3e 84       	ldd	r3, Y+14	; 0x0e
    2f14:	4f 84       	ldd	r4, Y+15	; 0x0f
    2f16:	58 88       	ldd	r5, Y+16	; 0x10
 	printPgmString(PSTR("\r\n"));
    2f18:	86 e1       	ldi	r24, 0x16	; 22
    2f1a:	94 e0       	ldi	r25, 0x04	; 4
    2f1c:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
	printPgmString(PSTR("Exec X="));	printInteger(line.steps_x);
    2f20:	8e e0       	ldi	r24, 0x0E	; 14
    2f22:	94 e0       	ldi	r25, 0x04	; 4
    2f24:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
    2f28:	c8 01       	movw	r24, r16
    2f2a:	b7 01       	movw	r22, r14
    2f2c:	0e 94 d3 16 	call	0x2da6	; 0x2da6 <printInteger>
	printPgmString(PSTR(", Y="));		printInteger(line.steps_y);
    2f30:	89 e0       	ldi	r24, 0x09	; 9
    2f32:	94 e0       	ldi	r25, 0x04	; 4
    2f34:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
    2f38:	c6 01       	movw	r24, r12
    2f3a:	b5 01       	movw	r22, r10
    2f3c:	0e 94 d3 16 	call	0x2da6	; 0x2da6 <printInteger>
	printPgmString(PSTR(", Z="));		printInteger(line.steps_z);
    2f40:	84 e0       	ldi	r24, 0x04	; 4
    2f42:	94 e0       	ldi	r25, 0x04	; 4
    2f44:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
    2f48:	c4 01       	movw	r24, r8
    2f4a:	b3 01       	movw	r22, r6
    2f4c:	0e 94 d3 16 	call	0x2da6	; 0x2da6 <printInteger>
	printPgmString(PSTR(" uS="));		printInteger(line.microseconds);
    2f50:	8f ef       	ldi	r24, 0xFF	; 255
    2f52:	93 e0       	ldi	r25, 0x03	; 3
    2f54:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
    2f58:	c2 01       	movw	r24, r4
    2f5a:	b1 01       	movw	r22, r2
    2f5c:	0e 94 d3 16 	call	0x2da6	; 0x2da6 <printInteger>
}
    2f60:	60 96       	adiw	r28, 0x10	; 16
    2f62:	cd bf       	out	0x3d, r28	; 61
    2f64:	de bf       	out	0x3e, r29	; 62
    2f66:	cf 91       	pop	r28
    2f68:	df 91       	pop	r29
    2f6a:	1f 91       	pop	r17
    2f6c:	0f 91       	pop	r16
    2f6e:	ff 90       	pop	r15
    2f70:	ef 90       	pop	r14
    2f72:	df 90       	pop	r13
    2f74:	cf 90       	pop	r12
    2f76:	bf 90       	pop	r11
    2f78:	af 90       	pop	r10
    2f7a:	9f 90       	pop	r9
    2f7c:	8f 90       	pop	r8
    2f7e:	7f 90       	pop	r7
    2f80:	6f 90       	pop	r6
    2f82:	5f 90       	pop	r5
    2f84:	4f 90       	pop	r4
    2f86:	3f 90       	pop	r3
    2f88:	2f 90       	pop	r2
    2f8a:	08 95       	ret

00002f8c <st_print_line>:
	printPgmString(PSTR(" uS="));		printInteger(u);
	printPgmString(PSTR("\r\n"));
}

void st_print_line(struct Line line) \
{
    2f8c:	2f 92       	push	r2
    2f8e:	3f 92       	push	r3
    2f90:	4f 92       	push	r4
    2f92:	5f 92       	push	r5
    2f94:	6f 92       	push	r6
    2f96:	7f 92       	push	r7
    2f98:	8f 92       	push	r8
    2f9a:	9f 92       	push	r9
    2f9c:	af 92       	push	r10
    2f9e:	bf 92       	push	r11
    2fa0:	cf 92       	push	r12
    2fa2:	df 92       	push	r13
    2fa4:	ef 92       	push	r14
    2fa6:	ff 92       	push	r15
    2fa8:	0f 93       	push	r16
    2faa:	1f 93       	push	r17
    2fac:	df 93       	push	r29
    2fae:	cf 93       	push	r28
    2fb0:	cd b7       	in	r28, 0x3d	; 61
    2fb2:	de b7       	in	r29, 0x3e	; 62
    2fb4:	60 97       	sbiw	r28, 0x10	; 16
    2fb6:	cd bf       	out	0x3d, r28	; 61
    2fb8:	de bf       	out	0x3e, r29	; 62
    2fba:	a9 82       	std	Y+1, r10	; 0x01
    2fbc:	ba 82       	std	Y+2, r11	; 0x02
    2fbe:	cb 82       	std	Y+3, r12	; 0x03
    2fc0:	dc 82       	std	Y+4, r13	; 0x04
    2fc2:	ed 82       	std	Y+5, r14	; 0x05
    2fc4:	fe 82       	std	Y+6, r15	; 0x06
    2fc6:	0f 83       	std	Y+7, r16	; 0x07
    2fc8:	18 87       	std	Y+8, r17	; 0x08
    2fca:	29 87       	std	Y+9, r18	; 0x09
    2fcc:	3a 87       	std	Y+10, r19	; 0x0a
    2fce:	4b 87       	std	Y+11, r20	; 0x0b
    2fd0:	5c 87       	std	Y+12, r21	; 0x0c
    2fd2:	6d 87       	std	Y+13, r22	; 0x0d
    2fd4:	7e 87       	std	Y+14, r23	; 0x0e
    2fd6:	8f 87       	std	Y+15, r24	; 0x0f
    2fd8:	98 8b       	std	Y+16, r25	; 0x10
    2fda:	e9 80       	ldd	r14, Y+1	; 0x01
    2fdc:	fa 80       	ldd	r15, Y+2	; 0x02
    2fde:	0b 81       	ldd	r16, Y+3	; 0x03
    2fe0:	1c 81       	ldd	r17, Y+4	; 0x04
    2fe2:	ad 80       	ldd	r10, Y+5	; 0x05
    2fe4:	be 80       	ldd	r11, Y+6	; 0x06
    2fe6:	cf 80       	ldd	r12, Y+7	; 0x07
    2fe8:	d8 84       	ldd	r13, Y+8	; 0x08
    2fea:	69 84       	ldd	r6, Y+9	; 0x09
    2fec:	7a 84       	ldd	r7, Y+10	; 0x0a
    2fee:	8b 84       	ldd	r8, Y+11	; 0x0b
    2ff0:	9c 84       	ldd	r9, Y+12	; 0x0c
    2ff2:	2d 84       	ldd	r2, Y+13	; 0x0d
    2ff4:	3e 84       	ldd	r3, Y+14	; 0x0e
    2ff6:	4f 84       	ldd	r4, Y+15	; 0x0f
    2ff8:	58 88       	ldd	r5, Y+16	; 0x10
 	printPgmString(PSTR("\r\n"));
    2ffa:	80 e3       	ldi	r24, 0x30	; 48
    2ffc:	94 e0       	ldi	r25, 0x04	; 4
    2ffe:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
	printPgmString(PSTR("Line X="));	printInteger(line.steps_x);
    3002:	88 e2       	ldi	r24, 0x28	; 40
    3004:	94 e0       	ldi	r25, 0x04	; 4
    3006:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
    300a:	c8 01       	movw	r24, r16
    300c:	b7 01       	movw	r22, r14
    300e:	0e 94 d3 16 	call	0x2da6	; 0x2da6 <printInteger>
	printPgmString(PSTR(", Y="));		printInteger(line.steps_y);
    3012:	83 e2       	ldi	r24, 0x23	; 35
    3014:	94 e0       	ldi	r25, 0x04	; 4
    3016:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
    301a:	c6 01       	movw	r24, r12
    301c:	b5 01       	movw	r22, r10
    301e:	0e 94 d3 16 	call	0x2da6	; 0x2da6 <printInteger>
	printPgmString(PSTR(", Z="));		printInteger(line.steps_z);
    3022:	8e e1       	ldi	r24, 0x1E	; 30
    3024:	94 e0       	ldi	r25, 0x04	; 4
    3026:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
    302a:	c4 01       	movw	r24, r8
    302c:	b3 01       	movw	r22, r6
    302e:	0e 94 d3 16 	call	0x2da6	; 0x2da6 <printInteger>
	printPgmString(PSTR(" uS="));		printInteger(line.microseconds);
    3032:	89 e1       	ldi	r24, 0x19	; 25
    3034:	94 e0       	ldi	r25, 0x04	; 4
    3036:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
    303a:	c2 01       	movw	r24, r4
    303c:	b1 01       	movw	r22, r2
    303e:	0e 94 d3 16 	call	0x2da6	; 0x2da6 <printInteger>
}
    3042:	60 96       	adiw	r28, 0x10	; 16
    3044:	cd bf       	out	0x3d, r28	; 61
    3046:	de bf       	out	0x3e, r29	; 62
    3048:	cf 91       	pop	r28
    304a:	df 91       	pop	r29
    304c:	1f 91       	pop	r17
    304e:	0f 91       	pop	r16
    3050:	ff 90       	pop	r15
    3052:	ef 90       	pop	r14
    3054:	df 90       	pop	r13
    3056:	cf 90       	pop	r12
    3058:	bf 90       	pop	r11
    305a:	af 90       	pop	r10
    305c:	9f 90       	pop	r9
    305e:	8f 90       	pop	r8
    3060:	7f 90       	pop	r7
    3062:	6f 90       	pop	r6
    3064:	5f 90       	pop	r5
    3066:	4f 90       	pop	r4
    3068:	3f 90       	pop	r3
    306a:	2f 90       	pop	r2
    306c:	08 95       	ret

0000306e <st_print_four_ints>:
	printPgmString(PSTR(" Port="));		printInteger(A->port->IN);	// reading IN reports state
	printPgmString(PSTR("\r\n"));
}

void st_print_four_ints(long x, long y, long z, long u) 
{
    306e:	2f 92       	push	r2
    3070:	3f 92       	push	r3
    3072:	4f 92       	push	r4
    3074:	5f 92       	push	r5
    3076:	6f 92       	push	r6
    3078:	7f 92       	push	r7
    307a:	8f 92       	push	r8
    307c:	9f 92       	push	r9
    307e:	af 92       	push	r10
    3080:	bf 92       	push	r11
    3082:	cf 92       	push	r12
    3084:	df 92       	push	r13
    3086:	ef 92       	push	r14
    3088:	ff 92       	push	r15
    308a:	0f 93       	push	r16
    308c:	1f 93       	push	r17
    308e:	3b 01       	movw	r6, r22
    3090:	4c 01       	movw	r8, r24
    3092:	19 01       	movw	r2, r18
    3094:	2a 01       	movw	r4, r20
	printPgmString(PSTR("Line: X="));	printInteger(x);
    3096:	83 e4       	ldi	r24, 0x43	; 67
    3098:	94 e0       	ldi	r25, 0x04	; 4
    309a:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
    309e:	c4 01       	movw	r24, r8
    30a0:	b3 01       	movw	r22, r6
    30a2:	0e 94 d3 16 	call	0x2da6	; 0x2da6 <printInteger>
	printPgmString(PSTR(" Y="));		printInteger(y);
    30a6:	8f e3       	ldi	r24, 0x3F	; 63
    30a8:	94 e0       	ldi	r25, 0x04	; 4
    30aa:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
    30ae:	c2 01       	movw	r24, r4
    30b0:	b1 01       	movw	r22, r2
    30b2:	0e 94 d3 16 	call	0x2da6	; 0x2da6 <printInteger>
	printPgmString(PSTR(" Z="));		printInteger(z);
    30b6:	8b e3       	ldi	r24, 0x3B	; 59
    30b8:	94 e0       	ldi	r25, 0x04	; 4
    30ba:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
    30be:	c8 01       	movw	r24, r16
    30c0:	b7 01       	movw	r22, r14
    30c2:	0e 94 d3 16 	call	0x2da6	; 0x2da6 <printInteger>
	printPgmString(PSTR(" uS="));		printInteger(u);
    30c6:	86 e3       	ldi	r24, 0x36	; 54
    30c8:	94 e0       	ldi	r25, 0x04	; 4
    30ca:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
    30ce:	c6 01       	movw	r24, r12
    30d0:	b5 01       	movw	r22, r10
    30d2:	0e 94 d3 16 	call	0x2da6	; 0x2da6 <printInteger>
	printPgmString(PSTR("\r\n"));
    30d6:	83 e3       	ldi	r24, 0x33	; 51
    30d8:	94 e0       	ldi	r25, 0x04	; 4
    30da:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
}
    30de:	1f 91       	pop	r17
    30e0:	0f 91       	pop	r16
    30e2:	ff 90       	pop	r15
    30e4:	ef 90       	pop	r14
    30e6:	df 90       	pop	r13
    30e8:	cf 90       	pop	r12
    30ea:	bf 90       	pop	r11
    30ec:	af 90       	pop	r10
    30ee:	9f 90       	pop	r9
    30f0:	8f 90       	pop	r8
    30f2:	7f 90       	pop	r7
    30f4:	6f 90       	pop	r6
    30f6:	5f 90       	pop	r5
    30f8:	4f 90       	pop	r4
    30fa:	3f 90       	pop	r3
    30fc:	2f 90       	pop	r2
    30fe:	08 95       	ret

00003100 <st_print_axis>:
#include "debug.h"

//		printPgmString(PSTR());

void st_print_axis(struct Axis *A, char *label)	// called as st_print_axis(&ax.x, "X");
{
    3100:	0f 93       	push	r16
    3102:	1f 93       	push	r17
    3104:	8c 01       	movw	r16, r24
    3106:	cb 01       	movw	r24, r22
	printString(label);					printPgmString(PSTR(" axis:"));
    3108:	0e 94 30 16 	call	0x2c60	; 0x2c60 <printString>
    310c:	8e e5       	ldi	r24, 0x5E	; 94
    310e:	94 e0       	ldi	r25, 0x04	; 4
    3110:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
	printPgmString(PSTR(" Count="));	printInteger(A->counter);
    3114:	86 e5       	ldi	r24, 0x56	; 86
    3116:	94 e0       	ldi	r25, 0x04	; 4
    3118:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
    311c:	d8 01       	movw	r26, r16
    311e:	6d 91       	ld	r22, X+
    3120:	7d 91       	ld	r23, X+
    3122:	8d 91       	ld	r24, X+
    3124:	9c 91       	ld	r25, X
    3126:	0e 94 d3 16 	call	0x2da6	; 0x2da6 <printInteger>
	printPgmString(PSTR(" Port="));		printInteger(A->port->IN);	// reading IN reports state
    312a:	8f e4       	ldi	r24, 0x4F	; 79
    312c:	94 e0       	ldi	r25, 0x04	; 4
    312e:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
    3132:	d8 01       	movw	r26, r16
    3134:	59 96       	adiw	r26, 0x19	; 25
    3136:	ed 91       	ld	r30, X+
    3138:	fc 91       	ld	r31, X
    313a:	5a 97       	sbiw	r26, 0x1a	; 26
    313c:	60 85       	ldd	r22, Z+8	; 0x08
    313e:	70 e0       	ldi	r23, 0x00	; 0
    3140:	80 e0       	ldi	r24, 0x00	; 0
    3142:	90 e0       	ldi	r25, 0x00	; 0
    3144:	0e 94 d3 16 	call	0x2da6	; 0x2da6 <printInteger>
	printPgmString(PSTR("\r\n"));
    3148:	8c e4       	ldi	r24, 0x4C	; 76
    314a:	94 e0       	ldi	r25, 0x04	; 4
    314c:	0e 94 3d 16 	call	0x2c7a	; 0x2c7a <printPgmString>
}
    3150:	1f 91       	pop	r17
    3152:	0f 91       	pop	r16
    3154:	08 95       	ret

00003156 <__subsf3>:
    3156:	50 58       	subi	r21, 0x80	; 128

00003158 <__addsf3>:
    3158:	bb 27       	eor	r27, r27
    315a:	aa 27       	eor	r26, r26
    315c:	0e d0       	rcall	.+28     	; 0x317a <__addsf3x>
    315e:	29 c2       	rjmp	.+1106   	; 0x35b2 <__fp_round>
    3160:	f2 d1       	rcall	.+996    	; 0x3546 <__fp_pscA>
    3162:	30 f0       	brcs	.+12     	; 0x3170 <__addsf3+0x18>
    3164:	f7 d1       	rcall	.+1006   	; 0x3554 <__fp_pscB>
    3166:	20 f0       	brcs	.+8      	; 0x3170 <__addsf3+0x18>
    3168:	31 f4       	brne	.+12     	; 0x3176 <__addsf3+0x1e>
    316a:	9f 3f       	cpi	r25, 0xFF	; 255
    316c:	11 f4       	brne	.+4      	; 0x3172 <__addsf3+0x1a>
    316e:	1e f4       	brtc	.+6      	; 0x3176 <__addsf3+0x1e>
    3170:	c2 c1       	rjmp	.+900    	; 0x34f6 <__fp_nan>
    3172:	0e f4       	brtc	.+2      	; 0x3176 <__addsf3+0x1e>
    3174:	e0 95       	com	r30
    3176:	e7 fb       	bst	r30, 7
    3178:	8f c1       	rjmp	.+798    	; 0x3498 <__fp_inf>

0000317a <__addsf3x>:
    317a:	e9 2f       	mov	r30, r25
    317c:	3c d2       	rcall	.+1144   	; 0x35f6 <__fp_split3>
    317e:	80 f3       	brcs	.-32     	; 0x3160 <__addsf3+0x8>
    3180:	ba 17       	cp	r27, r26
    3182:	62 07       	cpc	r22, r18
    3184:	73 07       	cpc	r23, r19
    3186:	84 07       	cpc	r24, r20
    3188:	95 07       	cpc	r25, r21
    318a:	18 f0       	brcs	.+6      	; 0x3192 <__addsf3x+0x18>
    318c:	71 f4       	brne	.+28     	; 0x31aa <__addsf3x+0x30>
    318e:	9e f5       	brtc	.+102    	; 0x31f6 <__addsf3x+0x7c>
    3190:	6b c2       	rjmp	.+1238   	; 0x3668 <__fp_zero>
    3192:	0e f4       	brtc	.+2      	; 0x3196 <__addsf3x+0x1c>
    3194:	e0 95       	com	r30
    3196:	0b 2e       	mov	r0, r27
    3198:	ba 2f       	mov	r27, r26
    319a:	a0 2d       	mov	r26, r0
    319c:	0b 01       	movw	r0, r22
    319e:	b9 01       	movw	r22, r18
    31a0:	90 01       	movw	r18, r0
    31a2:	0c 01       	movw	r0, r24
    31a4:	ca 01       	movw	r24, r20
    31a6:	a0 01       	movw	r20, r0
    31a8:	11 24       	eor	r1, r1
    31aa:	ff 27       	eor	r31, r31
    31ac:	59 1b       	sub	r21, r25
    31ae:	99 f0       	breq	.+38     	; 0x31d6 <__addsf3x+0x5c>
    31b0:	59 3f       	cpi	r21, 0xF9	; 249
    31b2:	50 f4       	brcc	.+20     	; 0x31c8 <__addsf3x+0x4e>
    31b4:	50 3e       	cpi	r21, 0xE0	; 224
    31b6:	68 f1       	brcs	.+90     	; 0x3212 <__addsf3x+0x98>
    31b8:	1a 16       	cp	r1, r26
    31ba:	f0 40       	sbci	r31, 0x00	; 0
    31bc:	a2 2f       	mov	r26, r18
    31be:	23 2f       	mov	r18, r19
    31c0:	34 2f       	mov	r19, r20
    31c2:	44 27       	eor	r20, r20
    31c4:	58 5f       	subi	r21, 0xF8	; 248
    31c6:	f3 cf       	rjmp	.-26     	; 0x31ae <__addsf3x+0x34>
    31c8:	46 95       	lsr	r20
    31ca:	37 95       	ror	r19
    31cc:	27 95       	ror	r18
    31ce:	a7 95       	ror	r26
    31d0:	f0 40       	sbci	r31, 0x00	; 0
    31d2:	53 95       	inc	r21
    31d4:	c9 f7       	brne	.-14     	; 0x31c8 <__addsf3x+0x4e>
    31d6:	7e f4       	brtc	.+30     	; 0x31f6 <__addsf3x+0x7c>
    31d8:	1f 16       	cp	r1, r31
    31da:	ba 0b       	sbc	r27, r26
    31dc:	62 0b       	sbc	r22, r18
    31de:	73 0b       	sbc	r23, r19
    31e0:	84 0b       	sbc	r24, r20
    31e2:	ba f0       	brmi	.+46     	; 0x3212 <__addsf3x+0x98>
    31e4:	91 50       	subi	r25, 0x01	; 1
    31e6:	a1 f0       	breq	.+40     	; 0x3210 <__addsf3x+0x96>
    31e8:	ff 0f       	add	r31, r31
    31ea:	bb 1f       	adc	r27, r27
    31ec:	66 1f       	adc	r22, r22
    31ee:	77 1f       	adc	r23, r23
    31f0:	88 1f       	adc	r24, r24
    31f2:	c2 f7       	brpl	.-16     	; 0x31e4 <__addsf3x+0x6a>
    31f4:	0e c0       	rjmp	.+28     	; 0x3212 <__addsf3x+0x98>
    31f6:	ba 0f       	add	r27, r26
    31f8:	62 1f       	adc	r22, r18
    31fa:	73 1f       	adc	r23, r19
    31fc:	84 1f       	adc	r24, r20
    31fe:	48 f4       	brcc	.+18     	; 0x3212 <__addsf3x+0x98>
    3200:	87 95       	ror	r24
    3202:	77 95       	ror	r23
    3204:	67 95       	ror	r22
    3206:	b7 95       	ror	r27
    3208:	f7 95       	ror	r31
    320a:	9e 3f       	cpi	r25, 0xFE	; 254
    320c:	08 f0       	brcs	.+2      	; 0x3210 <__addsf3x+0x96>
    320e:	b3 cf       	rjmp	.-154    	; 0x3176 <__addsf3+0x1e>
    3210:	93 95       	inc	r25
    3212:	88 0f       	add	r24, r24
    3214:	08 f0       	brcs	.+2      	; 0x3218 <__addsf3x+0x9e>
    3216:	99 27       	eor	r25, r25
    3218:	ee 0f       	add	r30, r30
    321a:	97 95       	ror	r25
    321c:	87 95       	ror	r24
    321e:	08 95       	ret

00003220 <atan>:
    3220:	df 93       	push	r29
    3222:	dd 27       	eor	r29, r29
    3224:	b9 2f       	mov	r27, r25
    3226:	bf 77       	andi	r27, 0x7F	; 127
    3228:	40 e8       	ldi	r20, 0x80	; 128
    322a:	5f e3       	ldi	r21, 0x3F	; 63
    322c:	16 16       	cp	r1, r22
    322e:	17 06       	cpc	r1, r23
    3230:	48 07       	cpc	r20, r24
    3232:	5b 07       	cpc	r21, r27
    3234:	10 f4       	brcc	.+4      	; 0x323a <atan+0x1a>
    3236:	d9 2f       	mov	r29, r25
    3238:	83 d2       	rcall	.+1286   	; 0x3740 <inverse>
    323a:	9f 93       	push	r25
    323c:	8f 93       	push	r24
    323e:	7f 93       	push	r23
    3240:	6f 93       	push	r22
    3242:	e9 d3       	rcall	.+2002   	; 0x3a16 <square>
    3244:	e8 ee       	ldi	r30, 0xE8	; 232
    3246:	f1 e0       	ldi	r31, 0x01	; 1
    3248:	59 d1       	rcall	.+690    	; 0x34fc <__fp_powser>
    324a:	b3 d1       	rcall	.+870    	; 0x35b2 <__fp_round>
    324c:	2f 91       	pop	r18
    324e:	3f 91       	pop	r19
    3250:	4f 91       	pop	r20
    3252:	5f 91       	pop	r21
    3254:	21 d3       	rcall	.+1602   	; 0x3898 <__mulsf3x>
    3256:	dd 23       	and	r29, r29
    3258:	49 f0       	breq	.+18     	; 0x326c <atan+0x4c>
    325a:	90 58       	subi	r25, 0x80	; 128
    325c:	a2 ea       	ldi	r26, 0xA2	; 162
    325e:	2a ed       	ldi	r18, 0xDA	; 218
    3260:	3f e0       	ldi	r19, 0x0F	; 15
    3262:	49 ec       	ldi	r20, 0xC9	; 201
    3264:	5f e3       	ldi	r21, 0x3F	; 63
    3266:	d0 78       	andi	r29, 0x80	; 128
    3268:	5d 27       	eor	r21, r29
    326a:	87 df       	rcall	.-242    	; 0x317a <__addsf3x>
    326c:	df 91       	pop	r29
    326e:	a1 c1       	rjmp	.+834    	; 0x35b2 <__fp_round>

00003270 <ceil>:
    3270:	e4 d1       	rcall	.+968    	; 0x363a <__fp_trunc>
    3272:	80 f0       	brcs	.+32     	; 0x3294 <ceil+0x24>
    3274:	9f 37       	cpi	r25, 0x7F	; 127
    3276:	40 f4       	brcc	.+16     	; 0x3288 <ceil+0x18>
    3278:	91 11       	cpse	r25, r1
    327a:	0e f4       	brtc	.+2      	; 0x327e <ceil+0xe>
    327c:	f6 c1       	rjmp	.+1004   	; 0x366a <__fp_szero>
    327e:	60 e0       	ldi	r22, 0x00	; 0
    3280:	70 e0       	ldi	r23, 0x00	; 0
    3282:	80 e8       	ldi	r24, 0x80	; 128
    3284:	9f e3       	ldi	r25, 0x3F	; 63
    3286:	08 95       	ret
    3288:	26 f0       	brts	.+8      	; 0x3292 <ceil+0x22>
    328a:	1b 16       	cp	r1, r27
    328c:	61 1d       	adc	r22, r1
    328e:	71 1d       	adc	r23, r1
    3290:	81 1d       	adc	r24, r1
    3292:	08 c1       	rjmp	.+528    	; 0x34a4 <__fp_mintl>
    3294:	22 c1       	rjmp	.+580    	; 0x34da <__fp_mpack>

00003296 <__cmpsf2>:
    3296:	dc d0       	rcall	.+440    	; 0x3450 <__fp_cmp>
    3298:	08 f4       	brcc	.+2      	; 0x329c <__cmpsf2+0x6>
    329a:	81 e0       	ldi	r24, 0x01	; 1
    329c:	08 95       	ret

0000329e <cos>:
    329e:	62 d1       	rcall	.+708    	; 0x3564 <__fp_rempio2>
    32a0:	e3 95       	inc	r30
    32a2:	98 c1       	rjmp	.+816    	; 0x35d4 <__fp_sinus>

000032a4 <__divsf3>:
    32a4:	0c d0       	rcall	.+24     	; 0x32be <__divsf3x>
    32a6:	85 c1       	rjmp	.+778    	; 0x35b2 <__fp_round>
    32a8:	55 d1       	rcall	.+682    	; 0x3554 <__fp_pscB>
    32aa:	40 f0       	brcs	.+16     	; 0x32bc <__divsf3+0x18>
    32ac:	4c d1       	rcall	.+664    	; 0x3546 <__fp_pscA>
    32ae:	30 f0       	brcs	.+12     	; 0x32bc <__divsf3+0x18>
    32b0:	21 f4       	brne	.+8      	; 0x32ba <__divsf3+0x16>
    32b2:	5f 3f       	cpi	r21, 0xFF	; 255
    32b4:	19 f0       	breq	.+6      	; 0x32bc <__divsf3+0x18>
    32b6:	f0 c0       	rjmp	.+480    	; 0x3498 <__fp_inf>
    32b8:	51 11       	cpse	r21, r1
    32ba:	d7 c1       	rjmp	.+942    	; 0x366a <__fp_szero>
    32bc:	1c c1       	rjmp	.+568    	; 0x34f6 <__fp_nan>

000032be <__divsf3x>:
    32be:	9b d1       	rcall	.+822    	; 0x35f6 <__fp_split3>
    32c0:	98 f3       	brcs	.-26     	; 0x32a8 <__divsf3+0x4>

000032c2 <__divsf3_pse>:
    32c2:	99 23       	and	r25, r25
    32c4:	c9 f3       	breq	.-14     	; 0x32b8 <__divsf3+0x14>
    32c6:	55 23       	and	r21, r21
    32c8:	b1 f3       	breq	.-20     	; 0x32b6 <__divsf3+0x12>
    32ca:	95 1b       	sub	r25, r21
    32cc:	55 0b       	sbc	r21, r21
    32ce:	bb 27       	eor	r27, r27
    32d0:	aa 27       	eor	r26, r26
    32d2:	62 17       	cp	r22, r18
    32d4:	73 07       	cpc	r23, r19
    32d6:	84 07       	cpc	r24, r20
    32d8:	38 f0       	brcs	.+14     	; 0x32e8 <__divsf3_pse+0x26>
    32da:	9f 5f       	subi	r25, 0xFF	; 255
    32dc:	5f 4f       	sbci	r21, 0xFF	; 255
    32de:	22 0f       	add	r18, r18
    32e0:	33 1f       	adc	r19, r19
    32e2:	44 1f       	adc	r20, r20
    32e4:	aa 1f       	adc	r26, r26
    32e6:	a9 f3       	breq	.-22     	; 0x32d2 <__divsf3_pse+0x10>
    32e8:	33 d0       	rcall	.+102    	; 0x3350 <__divsf3_pse+0x8e>
    32ea:	0e 2e       	mov	r0, r30
    32ec:	3a f0       	brmi	.+14     	; 0x32fc <__divsf3_pse+0x3a>
    32ee:	e0 e8       	ldi	r30, 0x80	; 128
    32f0:	30 d0       	rcall	.+96     	; 0x3352 <__divsf3_pse+0x90>
    32f2:	91 50       	subi	r25, 0x01	; 1
    32f4:	50 40       	sbci	r21, 0x00	; 0
    32f6:	e6 95       	lsr	r30
    32f8:	00 1c       	adc	r0, r0
    32fa:	ca f7       	brpl	.-14     	; 0x32ee <__divsf3_pse+0x2c>
    32fc:	29 d0       	rcall	.+82     	; 0x3350 <__divsf3_pse+0x8e>
    32fe:	fe 2f       	mov	r31, r30
    3300:	27 d0       	rcall	.+78     	; 0x3350 <__divsf3_pse+0x8e>
    3302:	66 0f       	add	r22, r22
    3304:	77 1f       	adc	r23, r23
    3306:	88 1f       	adc	r24, r24
    3308:	bb 1f       	adc	r27, r27
    330a:	26 17       	cp	r18, r22
    330c:	37 07       	cpc	r19, r23
    330e:	48 07       	cpc	r20, r24
    3310:	ab 07       	cpc	r26, r27
    3312:	b0 e8       	ldi	r27, 0x80	; 128
    3314:	09 f0       	breq	.+2      	; 0x3318 <__divsf3_pse+0x56>
    3316:	bb 0b       	sbc	r27, r27
    3318:	80 2d       	mov	r24, r0
    331a:	bf 01       	movw	r22, r30
    331c:	ff 27       	eor	r31, r31
    331e:	93 58       	subi	r25, 0x83	; 131
    3320:	5f 4f       	sbci	r21, 0xFF	; 255
    3322:	2a f0       	brmi	.+10     	; 0x332e <__divsf3_pse+0x6c>
    3324:	9e 3f       	cpi	r25, 0xFE	; 254
    3326:	51 05       	cpc	r21, r1
    3328:	68 f0       	brcs	.+26     	; 0x3344 <__divsf3_pse+0x82>
    332a:	b6 c0       	rjmp	.+364    	; 0x3498 <__fp_inf>
    332c:	9e c1       	rjmp	.+828    	; 0x366a <__fp_szero>
    332e:	5f 3f       	cpi	r21, 0xFF	; 255
    3330:	ec f3       	brlt	.-6      	; 0x332c <__divsf3_pse+0x6a>
    3332:	98 3e       	cpi	r25, 0xE8	; 232
    3334:	dc f3       	brlt	.-10     	; 0x332c <__divsf3_pse+0x6a>
    3336:	86 95       	lsr	r24
    3338:	77 95       	ror	r23
    333a:	67 95       	ror	r22
    333c:	b7 95       	ror	r27
    333e:	f7 95       	ror	r31
    3340:	9f 5f       	subi	r25, 0xFF	; 255
    3342:	c9 f7       	brne	.-14     	; 0x3336 <__divsf3_pse+0x74>
    3344:	88 0f       	add	r24, r24
    3346:	91 1d       	adc	r25, r1
    3348:	96 95       	lsr	r25
    334a:	87 95       	ror	r24
    334c:	97 f9       	bld	r25, 7
    334e:	08 95       	ret
    3350:	e1 e0       	ldi	r30, 0x01	; 1
    3352:	66 0f       	add	r22, r22
    3354:	77 1f       	adc	r23, r23
    3356:	88 1f       	adc	r24, r24
    3358:	bb 1f       	adc	r27, r27
    335a:	62 17       	cp	r22, r18
    335c:	73 07       	cpc	r23, r19
    335e:	84 07       	cpc	r24, r20
    3360:	ba 07       	cpc	r27, r26
    3362:	20 f0       	brcs	.+8      	; 0x336c <__divsf3_pse+0xaa>
    3364:	62 1b       	sub	r22, r18
    3366:	73 0b       	sbc	r23, r19
    3368:	84 0b       	sbc	r24, r20
    336a:	ba 0b       	sbc	r27, r26
    336c:	ee 1f       	adc	r30, r30
    336e:	88 f7       	brcc	.-30     	; 0x3352 <__divsf3_pse+0x90>
    3370:	e0 95       	com	r30
    3372:	08 95       	ret

00003374 <__fixsfsi>:
    3374:	04 d0       	rcall	.+8      	; 0x337e <__fixunssfsi>
    3376:	68 94       	set
    3378:	b1 11       	cpse	r27, r1
    337a:	77 c1       	rjmp	.+750    	; 0x366a <__fp_szero>
    337c:	08 95       	ret

0000337e <__fixunssfsi>:
    337e:	43 d1       	rcall	.+646    	; 0x3606 <__fp_splitA>
    3380:	88 f0       	brcs	.+34     	; 0x33a4 <__fixunssfsi+0x26>
    3382:	9f 57       	subi	r25, 0x7F	; 127
    3384:	90 f0       	brcs	.+36     	; 0x33aa <__fixunssfsi+0x2c>
    3386:	b9 2f       	mov	r27, r25
    3388:	99 27       	eor	r25, r25
    338a:	b7 51       	subi	r27, 0x17	; 23
    338c:	a0 f0       	brcs	.+40     	; 0x33b6 <__fixunssfsi+0x38>
    338e:	d1 f0       	breq	.+52     	; 0x33c4 <__fixunssfsi+0x46>
    3390:	66 0f       	add	r22, r22
    3392:	77 1f       	adc	r23, r23
    3394:	88 1f       	adc	r24, r24
    3396:	99 1f       	adc	r25, r25
    3398:	1a f0       	brmi	.+6      	; 0x33a0 <__fixunssfsi+0x22>
    339a:	ba 95       	dec	r27
    339c:	c9 f7       	brne	.-14     	; 0x3390 <__fixunssfsi+0x12>
    339e:	12 c0       	rjmp	.+36     	; 0x33c4 <__fixunssfsi+0x46>
    33a0:	b1 30       	cpi	r27, 0x01	; 1
    33a2:	81 f0       	breq	.+32     	; 0x33c4 <__fixunssfsi+0x46>
    33a4:	61 d1       	rcall	.+706    	; 0x3668 <__fp_zero>
    33a6:	b1 e0       	ldi	r27, 0x01	; 1
    33a8:	08 95       	ret
    33aa:	5e c1       	rjmp	.+700    	; 0x3668 <__fp_zero>
    33ac:	67 2f       	mov	r22, r23
    33ae:	78 2f       	mov	r23, r24
    33b0:	88 27       	eor	r24, r24
    33b2:	b8 5f       	subi	r27, 0xF8	; 248
    33b4:	39 f0       	breq	.+14     	; 0x33c4 <__fixunssfsi+0x46>
    33b6:	b9 3f       	cpi	r27, 0xF9	; 249
    33b8:	cc f3       	brlt	.-14     	; 0x33ac <__fixunssfsi+0x2e>
    33ba:	86 95       	lsr	r24
    33bc:	77 95       	ror	r23
    33be:	67 95       	ror	r22
    33c0:	b3 95       	inc	r27
    33c2:	d9 f7       	brne	.-10     	; 0x33ba <__fixunssfsi+0x3c>
    33c4:	3e f4       	brtc	.+14     	; 0x33d4 <__fixunssfsi+0x56>
    33c6:	90 95       	com	r25
    33c8:	80 95       	com	r24
    33ca:	70 95       	com	r23
    33cc:	61 95       	neg	r22
    33ce:	7f 4f       	sbci	r23, 0xFF	; 255
    33d0:	8f 4f       	sbci	r24, 0xFF	; 255
    33d2:	9f 4f       	sbci	r25, 0xFF	; 255
    33d4:	08 95       	ret

000033d6 <__floatunsisf>:
    33d6:	e8 94       	clt
    33d8:	09 c0       	rjmp	.+18     	; 0x33ec <__floatsisf+0x12>

000033da <__floatsisf>:
    33da:	97 fb       	bst	r25, 7
    33dc:	3e f4       	brtc	.+14     	; 0x33ec <__floatsisf+0x12>
    33de:	90 95       	com	r25
    33e0:	80 95       	com	r24
    33e2:	70 95       	com	r23
    33e4:	61 95       	neg	r22
    33e6:	7f 4f       	sbci	r23, 0xFF	; 255
    33e8:	8f 4f       	sbci	r24, 0xFF	; 255
    33ea:	9f 4f       	sbci	r25, 0xFF	; 255
    33ec:	99 23       	and	r25, r25
    33ee:	a9 f0       	breq	.+42     	; 0x341a <__floatsisf+0x40>
    33f0:	f9 2f       	mov	r31, r25
    33f2:	96 e9       	ldi	r25, 0x96	; 150
    33f4:	bb 27       	eor	r27, r27
    33f6:	93 95       	inc	r25
    33f8:	f6 95       	lsr	r31
    33fa:	87 95       	ror	r24
    33fc:	77 95       	ror	r23
    33fe:	67 95       	ror	r22
    3400:	b7 95       	ror	r27
    3402:	f1 11       	cpse	r31, r1
    3404:	f8 cf       	rjmp	.-16     	; 0x33f6 <__floatsisf+0x1c>
    3406:	fa f4       	brpl	.+62     	; 0x3446 <__floatsisf+0x6c>
    3408:	bb 0f       	add	r27, r27
    340a:	11 f4       	brne	.+4      	; 0x3410 <__floatsisf+0x36>
    340c:	60 ff       	sbrs	r22, 0
    340e:	1b c0       	rjmp	.+54     	; 0x3446 <__floatsisf+0x6c>
    3410:	6f 5f       	subi	r22, 0xFF	; 255
    3412:	7f 4f       	sbci	r23, 0xFF	; 255
    3414:	8f 4f       	sbci	r24, 0xFF	; 255
    3416:	9f 4f       	sbci	r25, 0xFF	; 255
    3418:	16 c0       	rjmp	.+44     	; 0x3446 <__floatsisf+0x6c>
    341a:	88 23       	and	r24, r24
    341c:	11 f0       	breq	.+4      	; 0x3422 <__floatsisf+0x48>
    341e:	96 e9       	ldi	r25, 0x96	; 150
    3420:	11 c0       	rjmp	.+34     	; 0x3444 <__floatsisf+0x6a>
    3422:	77 23       	and	r23, r23
    3424:	21 f0       	breq	.+8      	; 0x342e <__floatsisf+0x54>
    3426:	9e e8       	ldi	r25, 0x8E	; 142
    3428:	87 2f       	mov	r24, r23
    342a:	76 2f       	mov	r23, r22
    342c:	05 c0       	rjmp	.+10     	; 0x3438 <__floatsisf+0x5e>
    342e:	66 23       	and	r22, r22
    3430:	71 f0       	breq	.+28     	; 0x344e <__floatsisf+0x74>
    3432:	96 e8       	ldi	r25, 0x86	; 134
    3434:	86 2f       	mov	r24, r22
    3436:	70 e0       	ldi	r23, 0x00	; 0
    3438:	60 e0       	ldi	r22, 0x00	; 0
    343a:	2a f0       	brmi	.+10     	; 0x3446 <__floatsisf+0x6c>
    343c:	9a 95       	dec	r25
    343e:	66 0f       	add	r22, r22
    3440:	77 1f       	adc	r23, r23
    3442:	88 1f       	adc	r24, r24
    3444:	da f7       	brpl	.-10     	; 0x343c <__floatsisf+0x62>
    3446:	88 0f       	add	r24, r24
    3448:	96 95       	lsr	r25
    344a:	87 95       	ror	r24
    344c:	97 f9       	bld	r25, 7
    344e:	08 95       	ret

00003450 <__fp_cmp>:
    3450:	99 0f       	add	r25, r25
    3452:	00 08       	sbc	r0, r0
    3454:	55 0f       	add	r21, r21
    3456:	aa 0b       	sbc	r26, r26
    3458:	e0 e8       	ldi	r30, 0x80	; 128
    345a:	fe ef       	ldi	r31, 0xFE	; 254
    345c:	16 16       	cp	r1, r22
    345e:	17 06       	cpc	r1, r23
    3460:	e8 07       	cpc	r30, r24
    3462:	f9 07       	cpc	r31, r25
    3464:	c0 f0       	brcs	.+48     	; 0x3496 <__fp_cmp+0x46>
    3466:	12 16       	cp	r1, r18
    3468:	13 06       	cpc	r1, r19
    346a:	e4 07       	cpc	r30, r20
    346c:	f5 07       	cpc	r31, r21
    346e:	98 f0       	brcs	.+38     	; 0x3496 <__fp_cmp+0x46>
    3470:	62 1b       	sub	r22, r18
    3472:	73 0b       	sbc	r23, r19
    3474:	84 0b       	sbc	r24, r20
    3476:	95 0b       	sbc	r25, r21
    3478:	39 f4       	brne	.+14     	; 0x3488 <__fp_cmp+0x38>
    347a:	0a 26       	eor	r0, r26
    347c:	61 f0       	breq	.+24     	; 0x3496 <__fp_cmp+0x46>
    347e:	23 2b       	or	r18, r19
    3480:	24 2b       	or	r18, r20
    3482:	25 2b       	or	r18, r21
    3484:	21 f4       	brne	.+8      	; 0x348e <__fp_cmp+0x3e>
    3486:	08 95       	ret
    3488:	0a 26       	eor	r0, r26
    348a:	09 f4       	brne	.+2      	; 0x348e <__fp_cmp+0x3e>
    348c:	a1 40       	sbci	r26, 0x01	; 1
    348e:	a6 95       	lsr	r26
    3490:	8f ef       	ldi	r24, 0xFF	; 255
    3492:	81 1d       	adc	r24, r1
    3494:	81 1d       	adc	r24, r1
    3496:	08 95       	ret

00003498 <__fp_inf>:
    3498:	97 f9       	bld	r25, 7
    349a:	9f 67       	ori	r25, 0x7F	; 127
    349c:	80 e8       	ldi	r24, 0x80	; 128
    349e:	70 e0       	ldi	r23, 0x00	; 0
    34a0:	60 e0       	ldi	r22, 0x00	; 0
    34a2:	08 95       	ret

000034a4 <__fp_mintl>:
    34a4:	88 23       	and	r24, r24
    34a6:	71 f4       	brne	.+28     	; 0x34c4 <__fp_mintl+0x20>
    34a8:	77 23       	and	r23, r23
    34aa:	21 f0       	breq	.+8      	; 0x34b4 <__fp_mintl+0x10>
    34ac:	98 50       	subi	r25, 0x08	; 8
    34ae:	87 2b       	or	r24, r23
    34b0:	76 2f       	mov	r23, r22
    34b2:	07 c0       	rjmp	.+14     	; 0x34c2 <__fp_mintl+0x1e>
    34b4:	66 23       	and	r22, r22
    34b6:	11 f4       	brne	.+4      	; 0x34bc <__fp_mintl+0x18>
    34b8:	99 27       	eor	r25, r25
    34ba:	0d c0       	rjmp	.+26     	; 0x34d6 <__fp_mintl+0x32>
    34bc:	90 51       	subi	r25, 0x10	; 16
    34be:	86 2b       	or	r24, r22
    34c0:	70 e0       	ldi	r23, 0x00	; 0
    34c2:	60 e0       	ldi	r22, 0x00	; 0
    34c4:	2a f0       	brmi	.+10     	; 0x34d0 <__fp_mintl+0x2c>
    34c6:	9a 95       	dec	r25
    34c8:	66 0f       	add	r22, r22
    34ca:	77 1f       	adc	r23, r23
    34cc:	88 1f       	adc	r24, r24
    34ce:	da f7       	brpl	.-10     	; 0x34c6 <__fp_mintl+0x22>
    34d0:	88 0f       	add	r24, r24
    34d2:	96 95       	lsr	r25
    34d4:	87 95       	ror	r24
    34d6:	97 f9       	bld	r25, 7
    34d8:	08 95       	ret

000034da <__fp_mpack>:
    34da:	9f 3f       	cpi	r25, 0xFF	; 255
    34dc:	31 f0       	breq	.+12     	; 0x34ea <__fp_mpack_finite+0xc>

000034de <__fp_mpack_finite>:
    34de:	91 50       	subi	r25, 0x01	; 1
    34e0:	20 f4       	brcc	.+8      	; 0x34ea <__fp_mpack_finite+0xc>
    34e2:	87 95       	ror	r24
    34e4:	77 95       	ror	r23
    34e6:	67 95       	ror	r22
    34e8:	b7 95       	ror	r27
    34ea:	88 0f       	add	r24, r24
    34ec:	91 1d       	adc	r25, r1
    34ee:	96 95       	lsr	r25
    34f0:	87 95       	ror	r24
    34f2:	97 f9       	bld	r25, 7
    34f4:	08 95       	ret

000034f6 <__fp_nan>:
    34f6:	9f ef       	ldi	r25, 0xFF	; 255
    34f8:	80 ec       	ldi	r24, 0xC0	; 192
    34fa:	08 95       	ret

000034fc <__fp_powser>:
    34fc:	df 93       	push	r29
    34fe:	cf 93       	push	r28
    3500:	1f 93       	push	r17
    3502:	0f 93       	push	r16
    3504:	ff 92       	push	r15
    3506:	ef 92       	push	r14
    3508:	df 92       	push	r13
    350a:	7b 01       	movw	r14, r22
    350c:	8c 01       	movw	r16, r24
    350e:	68 94       	set
    3510:	05 c0       	rjmp	.+10     	; 0x351c <__fp_powser+0x20>
    3512:	da 2e       	mov	r13, r26
    3514:	ef 01       	movw	r28, r30
    3516:	c0 d1       	rcall	.+896    	; 0x3898 <__mulsf3x>
    3518:	fe 01       	movw	r30, r28
    351a:	e8 94       	clt
    351c:	a5 91       	lpm	r26, Z+
    351e:	25 91       	lpm	r18, Z+
    3520:	35 91       	lpm	r19, Z+
    3522:	45 91       	lpm	r20, Z+
    3524:	55 91       	lpm	r21, Z+
    3526:	ae f3       	brts	.-22     	; 0x3512 <__fp_powser+0x16>
    3528:	ef 01       	movw	r28, r30
    352a:	27 de       	rcall	.-946    	; 0x317a <__addsf3x>
    352c:	fe 01       	movw	r30, r28
    352e:	97 01       	movw	r18, r14
    3530:	a8 01       	movw	r20, r16
    3532:	da 94       	dec	r13
    3534:	79 f7       	brne	.-34     	; 0x3514 <__fp_powser+0x18>
    3536:	df 90       	pop	r13
    3538:	ef 90       	pop	r14
    353a:	ff 90       	pop	r15
    353c:	0f 91       	pop	r16
    353e:	1f 91       	pop	r17
    3540:	cf 91       	pop	r28
    3542:	df 91       	pop	r29
    3544:	08 95       	ret

00003546 <__fp_pscA>:
    3546:	00 24       	eor	r0, r0
    3548:	0a 94       	dec	r0
    354a:	16 16       	cp	r1, r22
    354c:	17 06       	cpc	r1, r23
    354e:	18 06       	cpc	r1, r24
    3550:	09 06       	cpc	r0, r25
    3552:	08 95       	ret

00003554 <__fp_pscB>:
    3554:	00 24       	eor	r0, r0
    3556:	0a 94       	dec	r0
    3558:	12 16       	cp	r1, r18
    355a:	13 06       	cpc	r1, r19
    355c:	14 06       	cpc	r1, r20
    355e:	05 06       	cpc	r0, r21
    3560:	08 95       	ret
    3562:	c9 cf       	rjmp	.-110    	; 0x34f6 <__fp_nan>

00003564 <__fp_rempio2>:
    3564:	50 d0       	rcall	.+160    	; 0x3606 <__fp_splitA>
    3566:	e8 f3       	brcs	.-6      	; 0x3562 <__fp_pscB+0xe>
    3568:	e8 94       	clt
    356a:	e0 e0       	ldi	r30, 0x00	; 0
    356c:	bb 27       	eor	r27, r27
    356e:	9f 57       	subi	r25, 0x7F	; 127
    3570:	f0 f0       	brcs	.+60     	; 0x35ae <__fp_rempio2+0x4a>
    3572:	2a ed       	ldi	r18, 0xDA	; 218
    3574:	3f e0       	ldi	r19, 0x0F	; 15
    3576:	49 ec       	ldi	r20, 0xC9	; 201
    3578:	06 c0       	rjmp	.+12     	; 0x3586 <__fp_rempio2+0x22>
    357a:	ee 0f       	add	r30, r30
    357c:	bb 0f       	add	r27, r27
    357e:	66 1f       	adc	r22, r22
    3580:	77 1f       	adc	r23, r23
    3582:	88 1f       	adc	r24, r24
    3584:	28 f0       	brcs	.+10     	; 0x3590 <__fp_rempio2+0x2c>
    3586:	b2 3a       	cpi	r27, 0xA2	; 162
    3588:	62 07       	cpc	r22, r18
    358a:	73 07       	cpc	r23, r19
    358c:	84 07       	cpc	r24, r20
    358e:	28 f0       	brcs	.+10     	; 0x359a <__fp_rempio2+0x36>
    3590:	b2 5a       	subi	r27, 0xA2	; 162
    3592:	62 0b       	sbc	r22, r18
    3594:	73 0b       	sbc	r23, r19
    3596:	84 0b       	sbc	r24, r20
    3598:	e3 95       	inc	r30
    359a:	9a 95       	dec	r25
    359c:	72 f7       	brpl	.-36     	; 0x357a <__fp_rempio2+0x16>
    359e:	80 38       	cpi	r24, 0x80	; 128
    35a0:	30 f4       	brcc	.+12     	; 0x35ae <__fp_rempio2+0x4a>
    35a2:	9a 95       	dec	r25
    35a4:	bb 0f       	add	r27, r27
    35a6:	66 1f       	adc	r22, r22
    35a8:	77 1f       	adc	r23, r23
    35aa:	88 1f       	adc	r24, r24
    35ac:	d2 f7       	brpl	.-12     	; 0x35a2 <__fp_rempio2+0x3e>
    35ae:	90 48       	sbci	r25, 0x80	; 128
    35b0:	96 cf       	rjmp	.-212    	; 0x34de <__fp_mpack_finite>

000035b2 <__fp_round>:
    35b2:	09 2e       	mov	r0, r25
    35b4:	03 94       	inc	r0
    35b6:	00 0c       	add	r0, r0
    35b8:	11 f4       	brne	.+4      	; 0x35be <__fp_round+0xc>
    35ba:	88 23       	and	r24, r24
    35bc:	52 f0       	brmi	.+20     	; 0x35d2 <__fp_round+0x20>
    35be:	bb 0f       	add	r27, r27
    35c0:	40 f4       	brcc	.+16     	; 0x35d2 <__fp_round+0x20>
    35c2:	bf 2b       	or	r27, r31
    35c4:	11 f4       	brne	.+4      	; 0x35ca <__fp_round+0x18>
    35c6:	60 ff       	sbrs	r22, 0
    35c8:	04 c0       	rjmp	.+8      	; 0x35d2 <__fp_round+0x20>
    35ca:	6f 5f       	subi	r22, 0xFF	; 255
    35cc:	7f 4f       	sbci	r23, 0xFF	; 255
    35ce:	8f 4f       	sbci	r24, 0xFF	; 255
    35d0:	9f 4f       	sbci	r25, 0xFF	; 255
    35d2:	08 95       	ret

000035d4 <__fp_sinus>:
    35d4:	ef 93       	push	r30
    35d6:	e0 ff       	sbrs	r30, 0
    35d8:	06 c0       	rjmp	.+12     	; 0x35e6 <__fp_sinus+0x12>
    35da:	a2 ea       	ldi	r26, 0xA2	; 162
    35dc:	2a ed       	ldi	r18, 0xDA	; 218
    35de:	3f e0       	ldi	r19, 0x0F	; 15
    35e0:	49 ec       	ldi	r20, 0xC9	; 201
    35e2:	5f eb       	ldi	r21, 0xBF	; 191
    35e4:	ca dd       	rcall	.-1132   	; 0x317a <__addsf3x>
    35e6:	e5 df       	rcall	.-54     	; 0x35b2 <__fp_round>
    35e8:	0f 90       	pop	r0
    35ea:	03 94       	inc	r0
    35ec:	01 fc       	sbrc	r0, 1
    35ee:	90 58       	subi	r25, 0x80	; 128
    35f0:	e5 e1       	ldi	r30, 0x15	; 21
    35f2:	f2 e0       	ldi	r31, 0x02	; 2
    35f4:	25 c2       	rjmp	.+1098   	; 0x3a40 <__fp_powsodd>

000035f6 <__fp_split3>:
    35f6:	57 fd       	sbrc	r21, 7
    35f8:	90 58       	subi	r25, 0x80	; 128
    35fa:	44 0f       	add	r20, r20
    35fc:	55 1f       	adc	r21, r21
    35fe:	59 f0       	breq	.+22     	; 0x3616 <__fp_splitA+0x10>
    3600:	5f 3f       	cpi	r21, 0xFF	; 255
    3602:	71 f0       	breq	.+28     	; 0x3620 <__fp_splitA+0x1a>
    3604:	47 95       	ror	r20

00003606 <__fp_splitA>:
    3606:	88 0f       	add	r24, r24
    3608:	97 fb       	bst	r25, 7
    360a:	99 1f       	adc	r25, r25
    360c:	61 f0       	breq	.+24     	; 0x3626 <__fp_splitA+0x20>
    360e:	9f 3f       	cpi	r25, 0xFF	; 255
    3610:	79 f0       	breq	.+30     	; 0x3630 <__fp_splitA+0x2a>
    3612:	87 95       	ror	r24
    3614:	08 95       	ret
    3616:	12 16       	cp	r1, r18
    3618:	13 06       	cpc	r1, r19
    361a:	14 06       	cpc	r1, r20
    361c:	55 1f       	adc	r21, r21
    361e:	f2 cf       	rjmp	.-28     	; 0x3604 <__fp_split3+0xe>
    3620:	46 95       	lsr	r20
    3622:	f1 df       	rcall	.-30     	; 0x3606 <__fp_splitA>
    3624:	08 c0       	rjmp	.+16     	; 0x3636 <__fp_splitA+0x30>
    3626:	16 16       	cp	r1, r22
    3628:	17 06       	cpc	r1, r23
    362a:	18 06       	cpc	r1, r24
    362c:	99 1f       	adc	r25, r25
    362e:	f1 cf       	rjmp	.-30     	; 0x3612 <__fp_splitA+0xc>
    3630:	86 95       	lsr	r24
    3632:	71 05       	cpc	r23, r1
    3634:	61 05       	cpc	r22, r1
    3636:	08 94       	sec
    3638:	08 95       	ret

0000363a <__fp_trunc>:
    363a:	e5 df       	rcall	.-54     	; 0x3606 <__fp_splitA>
    363c:	a0 f0       	brcs	.+40     	; 0x3666 <__fp_trunc+0x2c>
    363e:	be e7       	ldi	r27, 0x7E	; 126
    3640:	b9 17       	cp	r27, r25
    3642:	88 f4       	brcc	.+34     	; 0x3666 <__fp_trunc+0x2c>
    3644:	bb 27       	eor	r27, r27
    3646:	9f 38       	cpi	r25, 0x8F	; 143
    3648:	60 f4       	brcc	.+24     	; 0x3662 <__fp_trunc+0x28>
    364a:	16 16       	cp	r1, r22
    364c:	b1 1d       	adc	r27, r1
    364e:	67 2f       	mov	r22, r23
    3650:	78 2f       	mov	r23, r24
    3652:	88 27       	eor	r24, r24
    3654:	98 5f       	subi	r25, 0xF8	; 248
    3656:	f7 cf       	rjmp	.-18     	; 0x3646 <__fp_trunc+0xc>
    3658:	86 95       	lsr	r24
    365a:	77 95       	ror	r23
    365c:	67 95       	ror	r22
    365e:	b1 1d       	adc	r27, r1
    3660:	93 95       	inc	r25
    3662:	96 39       	cpi	r25, 0x96	; 150
    3664:	c8 f3       	brcs	.-14     	; 0x3658 <__fp_trunc+0x1e>
    3666:	08 95       	ret

00003668 <__fp_zero>:
    3668:	e8 94       	clt

0000366a <__fp_szero>:
    366a:	bb 27       	eor	r27, r27
    366c:	66 27       	eor	r22, r22
    366e:	77 27       	eor	r23, r23
    3670:	cb 01       	movw	r24, r22
    3672:	97 f9       	bld	r25, 7
    3674:	08 95       	ret

00003676 <__gesf2>:
    3676:	ec de       	rcall	.-552    	; 0x3450 <__fp_cmp>
    3678:	08 f4       	brcc	.+2      	; 0x367c <__gesf2+0x6>
    367a:	8f ef       	ldi	r24, 0xFF	; 255
    367c:	08 95       	ret
    367e:	63 df       	rcall	.-314    	; 0x3546 <__fp_pscA>
    3680:	19 f0       	breq	.+6      	; 0x3688 <__gesf2+0x12>
    3682:	68 df       	rcall	.-304    	; 0x3554 <__fp_pscB>
    3684:	09 f0       	breq	.+2      	; 0x3688 <__gesf2+0x12>
    3686:	37 cf       	rjmp	.-402    	; 0x34f6 <__fp_nan>
    3688:	07 cf       	rjmp	.-498    	; 0x3498 <__fp_inf>
    368a:	b9 01       	movw	r22, r18
    368c:	ca 01       	movw	r24, r20
    368e:	25 cf       	rjmp	.-438    	; 0x34da <__fp_mpack>

00003690 <hypot>:
    3690:	9f 77       	andi	r25, 0x7F	; 127
    3692:	5f 77       	andi	r21, 0x7F	; 127
    3694:	b0 df       	rcall	.-160    	; 0x35f6 <__fp_split3>
    3696:	98 f3       	brcs	.-26     	; 0x367e <__gesf2+0x8>
    3698:	99 23       	and	r25, r25
    369a:	b9 f3       	breq	.-18     	; 0x368a <__gesf2+0x14>
    369c:	55 23       	and	r21, r21
    369e:	b9 f3       	breq	.-18     	; 0x368e <__gesf2+0x18>
    36a0:	ff 27       	eor	r31, r31
    36a2:	95 17       	cp	r25, r21
    36a4:	58 f4       	brcc	.+22     	; 0x36bc <hypot+0x2c>
    36a6:	e5 2f       	mov	r30, r21
    36a8:	e9 1b       	sub	r30, r25
    36aa:	ed 30       	cpi	r30, 0x0D	; 13
    36ac:	70 f7       	brcc	.-36     	; 0x368a <__gesf2+0x14>
    36ae:	5e 3b       	cpi	r21, 0xBE	; 190
    36b0:	10 f0       	brcs	.+4      	; 0x36b6 <hypot+0x26>
    36b2:	f1 e4       	ldi	r31, 0x41	; 65
    36b4:	1c c0       	rjmp	.+56     	; 0x36ee <hypot+0x5e>
    36b6:	90 34       	cpi	r25, 0x40	; 64
    36b8:	e0 f4       	brcc	.+56     	; 0x36f2 <hypot+0x62>
    36ba:	0a c0       	rjmp	.+20     	; 0x36d0 <hypot+0x40>
    36bc:	e9 2f       	mov	r30, r25
    36be:	e5 1b       	sub	r30, r21
    36c0:	ed 30       	cpi	r30, 0x0D	; 13
    36c2:	28 f7       	brcc	.-54     	; 0x368e <__gesf2+0x18>
    36c4:	9e 3b       	cpi	r25, 0xBE	; 190
    36c6:	10 f0       	brcs	.+4      	; 0x36cc <hypot+0x3c>
    36c8:	f1 e4       	ldi	r31, 0x41	; 65
    36ca:	11 c0       	rjmp	.+34     	; 0x36ee <hypot+0x5e>
    36cc:	50 34       	cpi	r21, 0x40	; 64
    36ce:	88 f4       	brcc	.+34     	; 0x36f2 <hypot+0x62>
    36d0:	f9 ea       	ldi	r31, 0xA9	; 169
    36d2:	88 23       	and	r24, r24
    36d4:	2a f0       	brmi	.+10     	; 0x36e0 <hypot+0x50>
    36d6:	9a 95       	dec	r25
    36d8:	66 0f       	add	r22, r22
    36da:	77 1f       	adc	r23, r23
    36dc:	88 1f       	adc	r24, r24
    36de:	da f7       	brpl	.-10     	; 0x36d6 <hypot+0x46>
    36e0:	44 23       	and	r20, r20
    36e2:	2a f0       	brmi	.+10     	; 0x36ee <hypot+0x5e>
    36e4:	5a 95       	dec	r21
    36e6:	22 0f       	add	r18, r18
    36e8:	33 1f       	adc	r19, r19
    36ea:	44 1f       	adc	r20, r20
    36ec:	da f7       	brpl	.-10     	; 0x36e4 <hypot+0x54>
    36ee:	9f 1b       	sub	r25, r31
    36f0:	5f 1b       	sub	r21, r31
    36f2:	ff 93       	push	r31
    36f4:	1f 93       	push	r17
    36f6:	0f 93       	push	r16
    36f8:	ff 92       	push	r15
    36fa:	ef 92       	push	r14
    36fc:	79 01       	movw	r14, r18
    36fe:	8a 01       	movw	r16, r20
    3700:	bb 27       	eor	r27, r27
    3702:	ab 2f       	mov	r26, r27
    3704:	9b 01       	movw	r18, r22
    3706:	ac 01       	movw	r20, r24
    3708:	c9 d0       	rcall	.+402    	; 0x389c <__mulsf3_pse>
    370a:	97 01       	movw	r18, r14
    370c:	a8 01       	movw	r20, r16
    370e:	bf 93       	push	r27
    3710:	7b 01       	movw	r14, r22
    3712:	8c 01       	movw	r16, r24
    3714:	aa 27       	eor	r26, r26
    3716:	ba 2f       	mov	r27, r26
    3718:	b9 01       	movw	r22, r18
    371a:	ca 01       	movw	r24, r20
    371c:	bf d0       	rcall	.+382    	; 0x389c <__mulsf3_pse>
    371e:	af 91       	pop	r26
    3720:	97 01       	movw	r18, r14
    3722:	a8 01       	movw	r20, r16
    3724:	ef 90       	pop	r14
    3726:	ff 90       	pop	r15
    3728:	0f 91       	pop	r16
    372a:	1f 91       	pop	r17
    372c:	26 dd       	rcall	.-1460   	; 0x317a <__addsf3x>
    372e:	41 df       	rcall	.-382    	; 0x35b2 <__fp_round>
    3730:	34 d1       	rcall	.+616    	; 0x399a <sqrt>
    3732:	4f 91       	pop	r20
    3734:	40 ff       	sbrs	r20, 0
    3736:	08 95       	ret
    3738:	55 27       	eor	r21, r21
    373a:	47 fd       	sbrc	r20, 7
    373c:	50 95       	com	r21
    373e:	09 c0       	rjmp	.+18     	; 0x3752 <ldexp>

00003740 <inverse>:
    3740:	9b 01       	movw	r18, r22
    3742:	ac 01       	movw	r20, r24
    3744:	60 e0       	ldi	r22, 0x00	; 0
    3746:	70 e0       	ldi	r23, 0x00	; 0
    3748:	80 e8       	ldi	r24, 0x80	; 128
    374a:	9f e3       	ldi	r25, 0x3F	; 63
    374c:	ab cd       	rjmp	.-1194   	; 0x32a4 <__divsf3>
    374e:	a4 ce       	rjmp	.-696    	; 0x3498 <__fp_inf>
    3750:	c4 ce       	rjmp	.-632    	; 0x34da <__fp_mpack>

00003752 <ldexp>:
    3752:	59 df       	rcall	.-334    	; 0x3606 <__fp_splitA>
    3754:	e8 f3       	brcs	.-6      	; 0x3750 <inverse+0x10>
    3756:	99 23       	and	r25, r25
    3758:	d9 f3       	breq	.-10     	; 0x3750 <inverse+0x10>
    375a:	94 0f       	add	r25, r20
    375c:	51 1d       	adc	r21, r1
    375e:	bb f3       	brvs	.-18     	; 0x374e <inverse+0xe>
    3760:	91 50       	subi	r25, 0x01	; 1
    3762:	50 40       	sbci	r21, 0x00	; 0
    3764:	94 f0       	brlt	.+36     	; 0x378a <ldexp+0x38>
    3766:	59 f0       	breq	.+22     	; 0x377e <ldexp+0x2c>
    3768:	88 23       	and	r24, r24
    376a:	32 f0       	brmi	.+12     	; 0x3778 <ldexp+0x26>
    376c:	66 0f       	add	r22, r22
    376e:	77 1f       	adc	r23, r23
    3770:	88 1f       	adc	r24, r24
    3772:	91 50       	subi	r25, 0x01	; 1
    3774:	50 40       	sbci	r21, 0x00	; 0
    3776:	c1 f7       	brne	.-16     	; 0x3768 <ldexp+0x16>
    3778:	9e 3f       	cpi	r25, 0xFE	; 254
    377a:	51 05       	cpc	r21, r1
    377c:	44 f7       	brge	.-48     	; 0x374e <inverse+0xe>
    377e:	88 0f       	add	r24, r24
    3780:	91 1d       	adc	r25, r1
    3782:	96 95       	lsr	r25
    3784:	87 95       	ror	r24
    3786:	97 f9       	bld	r25, 7
    3788:	08 95       	ret
    378a:	5f 3f       	cpi	r21, 0xFF	; 255
    378c:	ac f0       	brlt	.+42     	; 0x37b8 <ldexp+0x66>
    378e:	98 3e       	cpi	r25, 0xE8	; 232
    3790:	9c f0       	brlt	.+38     	; 0x37b8 <ldexp+0x66>
    3792:	bb 27       	eor	r27, r27
    3794:	86 95       	lsr	r24
    3796:	77 95       	ror	r23
    3798:	67 95       	ror	r22
    379a:	b7 95       	ror	r27
    379c:	08 f4       	brcc	.+2      	; 0x37a0 <ldexp+0x4e>
    379e:	b1 60       	ori	r27, 0x01	; 1
    37a0:	93 95       	inc	r25
    37a2:	c1 f7       	brne	.-16     	; 0x3794 <ldexp+0x42>
    37a4:	bb 0f       	add	r27, r27
    37a6:	58 f7       	brcc	.-42     	; 0x377e <ldexp+0x2c>
    37a8:	11 f4       	brne	.+4      	; 0x37ae <ldexp+0x5c>
    37aa:	60 ff       	sbrs	r22, 0
    37ac:	e8 cf       	rjmp	.-48     	; 0x377e <ldexp+0x2c>
    37ae:	6f 5f       	subi	r22, 0xFF	; 255
    37b0:	7f 4f       	sbci	r23, 0xFF	; 255
    37b2:	8f 4f       	sbci	r24, 0xFF	; 255
    37b4:	9f 4f       	sbci	r25, 0xFF	; 255
    37b6:	e3 cf       	rjmp	.-58     	; 0x377e <ldexp+0x2c>
    37b8:	58 cf       	rjmp	.-336    	; 0x366a <__fp_szero>

000037ba <lround>:
    37ba:	25 df       	rcall	.-438    	; 0x3606 <__fp_splitA>
    37bc:	58 f1       	brcs	.+86     	; 0x3814 <lround+0x5a>
    37be:	9e 57       	subi	r25, 0x7E	; 126
    37c0:	58 f1       	brcs	.+86     	; 0x3818 <lround+0x5e>
    37c2:	98 51       	subi	r25, 0x18	; 24
    37c4:	a0 f0       	brcs	.+40     	; 0x37ee <lround+0x34>
    37c6:	e9 f0       	breq	.+58     	; 0x3802 <lround+0x48>
    37c8:	98 30       	cpi	r25, 0x08	; 8
    37ca:	20 f5       	brcc	.+72     	; 0x3814 <lround+0x5a>
    37cc:	09 2e       	mov	r0, r25
    37ce:	99 27       	eor	r25, r25
    37d0:	66 0f       	add	r22, r22
    37d2:	77 1f       	adc	r23, r23
    37d4:	88 1f       	adc	r24, r24
    37d6:	99 1f       	adc	r25, r25
    37d8:	0a 94       	dec	r0
    37da:	d1 f7       	brne	.-12     	; 0x37d0 <lround+0x16>
    37dc:	12 c0       	rjmp	.+36     	; 0x3802 <lround+0x48>
    37de:	06 2e       	mov	r0, r22
    37e0:	67 2f       	mov	r22, r23
    37e2:	78 2f       	mov	r23, r24
    37e4:	88 27       	eor	r24, r24
    37e6:	98 5f       	subi	r25, 0xF8	; 248
    37e8:	11 f4       	brne	.+4      	; 0x37ee <lround+0x34>
    37ea:	00 0c       	add	r0, r0
    37ec:	07 c0       	rjmp	.+14     	; 0x37fc <lround+0x42>
    37ee:	99 3f       	cpi	r25, 0xF9	; 249
    37f0:	b4 f3       	brlt	.-20     	; 0x37de <lround+0x24>
    37f2:	86 95       	lsr	r24
    37f4:	77 95       	ror	r23
    37f6:	67 95       	ror	r22
    37f8:	93 95       	inc	r25
    37fa:	d9 f7       	brne	.-10     	; 0x37f2 <lround+0x38>
    37fc:	61 1d       	adc	r22, r1
    37fe:	71 1d       	adc	r23, r1
    3800:	81 1d       	adc	r24, r1
    3802:	3e f4       	brtc	.+14     	; 0x3812 <lround+0x58>
    3804:	90 95       	com	r25
    3806:	80 95       	com	r24
    3808:	70 95       	com	r23
    380a:	61 95       	neg	r22
    380c:	7f 4f       	sbci	r23, 0xFF	; 255
    380e:	8f 4f       	sbci	r24, 0xFF	; 255
    3810:	9f 4f       	sbci	r25, 0xFF	; 255
    3812:	08 95       	ret
    3814:	68 94       	set
    3816:	29 cf       	rjmp	.-430    	; 0x366a <__fp_szero>
    3818:	27 cf       	rjmp	.-434    	; 0x3668 <__fp_zero>

0000381a <modf>:
    381a:	fa 01       	movw	r30, r20
    381c:	dc 01       	movw	r26, r24
    381e:	aa 0f       	add	r26, r26
    3820:	bb 1f       	adc	r27, r27
    3822:	9b 01       	movw	r18, r22
    3824:	ac 01       	movw	r20, r24
    3826:	bf 57       	subi	r27, 0x7F	; 127
    3828:	28 f4       	brcc	.+10     	; 0x3834 <modf+0x1a>
    382a:	22 27       	eor	r18, r18
    382c:	33 27       	eor	r19, r19
    382e:	44 27       	eor	r20, r20
    3830:	50 78       	andi	r21, 0x80	; 128
    3832:	1f c0       	rjmp	.+62     	; 0x3872 <modf+0x58>
    3834:	b7 51       	subi	r27, 0x17	; 23
    3836:	88 f4       	brcc	.+34     	; 0x385a <modf+0x40>
    3838:	ab 2f       	mov	r26, r27
    383a:	00 24       	eor	r0, r0
    383c:	46 95       	lsr	r20
    383e:	37 95       	ror	r19
    3840:	27 95       	ror	r18
    3842:	01 1c       	adc	r0, r1
    3844:	a3 95       	inc	r26
    3846:	d2 f3       	brmi	.-12     	; 0x383c <modf+0x22>
    3848:	00 20       	and	r0, r0
    384a:	69 f0       	breq	.+26     	; 0x3866 <modf+0x4c>
    384c:	22 0f       	add	r18, r18
    384e:	33 1f       	adc	r19, r19
    3850:	44 1f       	adc	r20, r20
    3852:	b3 95       	inc	r27
    3854:	da f3       	brmi	.-10     	; 0x384c <modf+0x32>
    3856:	0d d0       	rcall	.+26     	; 0x3872 <modf+0x58>
    3858:	7e cc       	rjmp	.-1796   	; 0x3156 <__subsf3>
    385a:	61 30       	cpi	r22, 0x01	; 1
    385c:	71 05       	cpc	r23, r1
    385e:	a0 e8       	ldi	r26, 0x80	; 128
    3860:	8a 07       	cpc	r24, r26
    3862:	b9 46       	sbci	r27, 0x69	; 105
    3864:	30 f4       	brcc	.+12     	; 0x3872 <modf+0x58>
    3866:	9b 01       	movw	r18, r22
    3868:	ac 01       	movw	r20, r24
    386a:	66 27       	eor	r22, r22
    386c:	77 27       	eor	r23, r23
    386e:	88 27       	eor	r24, r24
    3870:	90 78       	andi	r25, 0x80	; 128
    3872:	30 96       	adiw	r30, 0x00	; 0
    3874:	21 f0       	breq	.+8      	; 0x387e <modf+0x64>
    3876:	20 83       	st	Z, r18
    3878:	31 83       	std	Z+1, r19	; 0x01
    387a:	42 83       	std	Z+2, r20	; 0x02
    387c:	53 83       	std	Z+3, r21	; 0x03
    387e:	08 95       	ret

00003880 <__mulsf3>:
    3880:	0b d0       	rcall	.+22     	; 0x3898 <__mulsf3x>
    3882:	97 ce       	rjmp	.-722    	; 0x35b2 <__fp_round>
    3884:	60 de       	rcall	.-832    	; 0x3546 <__fp_pscA>
    3886:	28 f0       	brcs	.+10     	; 0x3892 <__mulsf3+0x12>
    3888:	65 de       	rcall	.-822    	; 0x3554 <__fp_pscB>
    388a:	18 f0       	brcs	.+6      	; 0x3892 <__mulsf3+0x12>
    388c:	95 23       	and	r25, r21
    388e:	09 f0       	breq	.+2      	; 0x3892 <__mulsf3+0x12>
    3890:	03 ce       	rjmp	.-1018   	; 0x3498 <__fp_inf>
    3892:	31 ce       	rjmp	.-926    	; 0x34f6 <__fp_nan>
    3894:	11 24       	eor	r1, r1
    3896:	e9 ce       	rjmp	.-558    	; 0x366a <__fp_szero>

00003898 <__mulsf3x>:
    3898:	ae de       	rcall	.-676    	; 0x35f6 <__fp_split3>
    389a:	a0 f3       	brcs	.-24     	; 0x3884 <__mulsf3+0x4>

0000389c <__mulsf3_pse>:
    389c:	95 9f       	mul	r25, r21
    389e:	d1 f3       	breq	.-12     	; 0x3894 <__mulsf3+0x14>
    38a0:	95 0f       	add	r25, r21
    38a2:	50 e0       	ldi	r21, 0x00	; 0
    38a4:	55 1f       	adc	r21, r21
    38a6:	62 9f       	mul	r22, r18
    38a8:	f0 01       	movw	r30, r0
    38aa:	72 9f       	mul	r23, r18
    38ac:	bb 27       	eor	r27, r27
    38ae:	f0 0d       	add	r31, r0
    38b0:	b1 1d       	adc	r27, r1
    38b2:	63 9f       	mul	r22, r19
    38b4:	aa 27       	eor	r26, r26
    38b6:	f0 0d       	add	r31, r0
    38b8:	b1 1d       	adc	r27, r1
    38ba:	aa 1f       	adc	r26, r26
    38bc:	64 9f       	mul	r22, r20
    38be:	66 27       	eor	r22, r22
    38c0:	b0 0d       	add	r27, r0
    38c2:	a1 1d       	adc	r26, r1
    38c4:	66 1f       	adc	r22, r22
    38c6:	82 9f       	mul	r24, r18
    38c8:	22 27       	eor	r18, r18
    38ca:	b0 0d       	add	r27, r0
    38cc:	a1 1d       	adc	r26, r1
    38ce:	62 1f       	adc	r22, r18
    38d0:	73 9f       	mul	r23, r19
    38d2:	b0 0d       	add	r27, r0
    38d4:	a1 1d       	adc	r26, r1
    38d6:	62 1f       	adc	r22, r18
    38d8:	83 9f       	mul	r24, r19
    38da:	a0 0d       	add	r26, r0
    38dc:	61 1d       	adc	r22, r1
    38de:	22 1f       	adc	r18, r18
    38e0:	74 9f       	mul	r23, r20
    38e2:	33 27       	eor	r19, r19
    38e4:	a0 0d       	add	r26, r0
    38e6:	61 1d       	adc	r22, r1
    38e8:	23 1f       	adc	r18, r19
    38ea:	84 9f       	mul	r24, r20
    38ec:	60 0d       	add	r22, r0
    38ee:	21 1d       	adc	r18, r1
    38f0:	82 2f       	mov	r24, r18
    38f2:	76 2f       	mov	r23, r22
    38f4:	6a 2f       	mov	r22, r26
    38f6:	11 24       	eor	r1, r1
    38f8:	9f 57       	subi	r25, 0x7F	; 127
    38fa:	50 40       	sbci	r21, 0x00	; 0
    38fc:	8a f0       	brmi	.+34     	; 0x3920 <__mulsf3_pse+0x84>
    38fe:	e1 f0       	breq	.+56     	; 0x3938 <__mulsf3_pse+0x9c>
    3900:	88 23       	and	r24, r24
    3902:	4a f0       	brmi	.+18     	; 0x3916 <__mulsf3_pse+0x7a>
    3904:	ee 0f       	add	r30, r30
    3906:	ff 1f       	adc	r31, r31
    3908:	bb 1f       	adc	r27, r27
    390a:	66 1f       	adc	r22, r22
    390c:	77 1f       	adc	r23, r23
    390e:	88 1f       	adc	r24, r24
    3910:	91 50       	subi	r25, 0x01	; 1
    3912:	50 40       	sbci	r21, 0x00	; 0
    3914:	a9 f7       	brne	.-22     	; 0x3900 <__mulsf3_pse+0x64>
    3916:	9e 3f       	cpi	r25, 0xFE	; 254
    3918:	51 05       	cpc	r21, r1
    391a:	70 f0       	brcs	.+28     	; 0x3938 <__mulsf3_pse+0x9c>
    391c:	bd cd       	rjmp	.-1158   	; 0x3498 <__fp_inf>
    391e:	a5 ce       	rjmp	.-694    	; 0x366a <__fp_szero>
    3920:	5f 3f       	cpi	r21, 0xFF	; 255
    3922:	ec f3       	brlt	.-6      	; 0x391e <__mulsf3_pse+0x82>
    3924:	98 3e       	cpi	r25, 0xE8	; 232
    3926:	dc f3       	brlt	.-10     	; 0x391e <__mulsf3_pse+0x82>
    3928:	86 95       	lsr	r24
    392a:	77 95       	ror	r23
    392c:	67 95       	ror	r22
    392e:	b7 95       	ror	r27
    3930:	f7 95       	ror	r31
    3932:	e7 95       	ror	r30
    3934:	9f 5f       	subi	r25, 0xFF	; 255
    3936:	c1 f7       	brne	.-16     	; 0x3928 <__mulsf3_pse+0x8c>
    3938:	fe 2b       	or	r31, r30
    393a:	88 0f       	add	r24, r24
    393c:	91 1d       	adc	r25, r1
    393e:	96 95       	lsr	r25
    3940:	87 95       	ror	r24
    3942:	97 f9       	bld	r25, 7
    3944:	08 95       	ret

00003946 <round>:
    3946:	5f de       	rcall	.-834    	; 0x3606 <__fp_splitA>
    3948:	e0 f0       	brcs	.+56     	; 0x3982 <round+0x3c>
    394a:	9e 37       	cpi	r25, 0x7E	; 126
    394c:	d8 f0       	brcs	.+54     	; 0x3984 <round+0x3e>
    394e:	96 39       	cpi	r25, 0x96	; 150
    3950:	b8 f4       	brcc	.+46     	; 0x3980 <round+0x3a>
    3952:	9e 38       	cpi	r25, 0x8E	; 142
    3954:	48 f4       	brcc	.+18     	; 0x3968 <round+0x22>
    3956:	67 2f       	mov	r22, r23
    3958:	78 2f       	mov	r23, r24
    395a:	88 27       	eor	r24, r24
    395c:	98 5f       	subi	r25, 0xF8	; 248
    395e:	f9 cf       	rjmp	.-14     	; 0x3952 <round+0xc>
    3960:	86 95       	lsr	r24
    3962:	77 95       	ror	r23
    3964:	67 95       	ror	r22
    3966:	93 95       	inc	r25
    3968:	95 39       	cpi	r25, 0x95	; 149
    396a:	d0 f3       	brcs	.-12     	; 0x3960 <round+0x1a>
    396c:	b6 2f       	mov	r27, r22
    396e:	b1 70       	andi	r27, 0x01	; 1
    3970:	6b 0f       	add	r22, r27
    3972:	71 1d       	adc	r23, r1
    3974:	81 1d       	adc	r24, r1
    3976:	20 f4       	brcc	.+8      	; 0x3980 <round+0x3a>
    3978:	87 95       	ror	r24
    397a:	77 95       	ror	r23
    397c:	67 95       	ror	r22
    397e:	93 95       	inc	r25
    3980:	91 cd       	rjmp	.-1246   	; 0x34a4 <__fp_mintl>
    3982:	ab cd       	rjmp	.-1194   	; 0x34da <__fp_mpack>
    3984:	72 ce       	rjmp	.-796    	; 0x366a <__fp_szero>

00003986 <sin>:
    3986:	9f 93       	push	r25
    3988:	ed dd       	rcall	.-1062   	; 0x3564 <__fp_rempio2>
    398a:	0f 90       	pop	r0
    398c:	07 fc       	sbrc	r0, 7
    398e:	ee 5f       	subi	r30, 0xFE	; 254
    3990:	21 ce       	rjmp	.-958    	; 0x35d4 <__fp_sinus>
    3992:	11 f4       	brne	.+4      	; 0x3998 <sin+0x12>
    3994:	0e f4       	brtc	.+2      	; 0x3998 <sin+0x12>
    3996:	af cd       	rjmp	.-1186   	; 0x34f6 <__fp_nan>
    3998:	a0 cd       	rjmp	.-1216   	; 0x34da <__fp_mpack>

0000399a <sqrt>:
    399a:	35 de       	rcall	.-918    	; 0x3606 <__fp_splitA>
    399c:	d0 f3       	brcs	.-12     	; 0x3992 <sin+0xc>
    399e:	99 23       	and	r25, r25
    39a0:	d9 f3       	breq	.-10     	; 0x3998 <sin+0x12>
    39a2:	ce f3       	brts	.-14     	; 0x3996 <sin+0x10>
    39a4:	9f 57       	subi	r25, 0x7F	; 127
    39a6:	55 0b       	sbc	r21, r21
    39a8:	87 ff       	sbrs	r24, 7
    39aa:	43 d0       	rcall	.+134    	; 0x3a32 <__fp_norm2>
    39ac:	00 24       	eor	r0, r0
    39ae:	a0 e6       	ldi	r26, 0x60	; 96
    39b0:	40 ea       	ldi	r20, 0xA0	; 160
    39b2:	90 01       	movw	r18, r0
    39b4:	80 58       	subi	r24, 0x80	; 128
    39b6:	56 95       	lsr	r21
    39b8:	97 95       	ror	r25
    39ba:	28 f4       	brcc	.+10     	; 0x39c6 <sqrt+0x2c>
    39bc:	80 5c       	subi	r24, 0xC0	; 192
    39be:	66 0f       	add	r22, r22
    39c0:	77 1f       	adc	r23, r23
    39c2:	88 1f       	adc	r24, r24
    39c4:	20 f0       	brcs	.+8      	; 0x39ce <sqrt+0x34>
    39c6:	26 17       	cp	r18, r22
    39c8:	37 07       	cpc	r19, r23
    39ca:	48 07       	cpc	r20, r24
    39cc:	30 f4       	brcc	.+12     	; 0x39da <sqrt+0x40>
    39ce:	62 1b       	sub	r22, r18
    39d0:	73 0b       	sbc	r23, r19
    39d2:	84 0b       	sbc	r24, r20
    39d4:	20 29       	or	r18, r0
    39d6:	31 29       	or	r19, r1
    39d8:	4a 2b       	or	r20, r26
    39da:	a6 95       	lsr	r26
    39dc:	17 94       	ror	r1
    39de:	07 94       	ror	r0
    39e0:	20 25       	eor	r18, r0
    39e2:	31 25       	eor	r19, r1
    39e4:	4a 27       	eor	r20, r26
    39e6:	58 f7       	brcc	.-42     	; 0x39be <sqrt+0x24>
    39e8:	66 0f       	add	r22, r22
    39ea:	77 1f       	adc	r23, r23
    39ec:	88 1f       	adc	r24, r24
    39ee:	20 f0       	brcs	.+8      	; 0x39f8 <sqrt+0x5e>
    39f0:	26 17       	cp	r18, r22
    39f2:	37 07       	cpc	r19, r23
    39f4:	48 07       	cpc	r20, r24
    39f6:	30 f4       	brcc	.+12     	; 0x3a04 <sqrt+0x6a>
    39f8:	62 0b       	sbc	r22, r18
    39fa:	73 0b       	sbc	r23, r19
    39fc:	84 0b       	sbc	r24, r20
    39fe:	20 0d       	add	r18, r0
    3a00:	31 1d       	adc	r19, r1
    3a02:	41 1d       	adc	r20, r1
    3a04:	a0 95       	com	r26
    3a06:	81 f7       	brne	.-32     	; 0x39e8 <sqrt+0x4e>
    3a08:	b9 01       	movw	r22, r18
    3a0a:	84 2f       	mov	r24, r20
    3a0c:	91 58       	subi	r25, 0x81	; 129
    3a0e:	88 0f       	add	r24, r24
    3a10:	96 95       	lsr	r25
    3a12:	87 95       	ror	r24
    3a14:	08 95       	ret

00003a16 <square>:
    3a16:	9b 01       	movw	r18, r22
    3a18:	ac 01       	movw	r20, r24
    3a1a:	32 cf       	rjmp	.-412    	; 0x3880 <__mulsf3>

00003a1c <trunc>:
    3a1c:	0e de       	rcall	.-996    	; 0x363a <__fp_trunc>
    3a1e:	20 f0       	brcs	.+8      	; 0x3a28 <trunc+0xc>
    3a20:	9f 37       	cpi	r25, 0x7F	; 127
    3a22:	08 f4       	brcc	.+2      	; 0x3a26 <trunc+0xa>
    3a24:	22 ce       	rjmp	.-956    	; 0x366a <__fp_szero>
    3a26:	3e cd       	rjmp	.-1412   	; 0x34a4 <__fp_mintl>
    3a28:	58 cd       	rjmp	.-1360   	; 0x34da <__fp_mpack>

00003a2a <__unordsf2>:
    3a2a:	12 dd       	rcall	.-1500   	; 0x3450 <__fp_cmp>
    3a2c:	88 0b       	sbc	r24, r24
    3a2e:	99 0b       	sbc	r25, r25
    3a30:	08 95       	ret

00003a32 <__fp_norm2>:
    3a32:	91 50       	subi	r25, 0x01	; 1
    3a34:	50 40       	sbci	r21, 0x00	; 0
    3a36:	66 0f       	add	r22, r22
    3a38:	77 1f       	adc	r23, r23
    3a3a:	88 1f       	adc	r24, r24
    3a3c:	d2 f7       	brpl	.-12     	; 0x3a32 <__fp_norm2>
    3a3e:	08 95       	ret

00003a40 <__fp_powsodd>:
    3a40:	9f 93       	push	r25
    3a42:	8f 93       	push	r24
    3a44:	7f 93       	push	r23
    3a46:	6f 93       	push	r22
    3a48:	ff 93       	push	r31
    3a4a:	ef 93       	push	r30
    3a4c:	9b 01       	movw	r18, r22
    3a4e:	ac 01       	movw	r20, r24
    3a50:	17 df       	rcall	.-466    	; 0x3880 <__mulsf3>
    3a52:	ef 91       	pop	r30
    3a54:	ff 91       	pop	r31
    3a56:	52 dd       	rcall	.-1372   	; 0x34fc <__fp_powser>
    3a58:	2f 91       	pop	r18
    3a5a:	3f 91       	pop	r19
    3a5c:	4f 91       	pop	r20
    3a5e:	5f 91       	pop	r21
    3a60:	0f cf       	rjmp	.-482    	; 0x3880 <__mulsf3>

00003a62 <__udivmodsi4>:
    3a62:	a1 e2       	ldi	r26, 0x21	; 33
    3a64:	1a 2e       	mov	r1, r26
    3a66:	aa 1b       	sub	r26, r26
    3a68:	bb 1b       	sub	r27, r27
    3a6a:	fd 01       	movw	r30, r26
    3a6c:	0d c0       	rjmp	.+26     	; 0x3a88 <__udivmodsi4_ep>

00003a6e <__udivmodsi4_loop>:
    3a6e:	aa 1f       	adc	r26, r26
    3a70:	bb 1f       	adc	r27, r27
    3a72:	ee 1f       	adc	r30, r30
    3a74:	ff 1f       	adc	r31, r31
    3a76:	a2 17       	cp	r26, r18
    3a78:	b3 07       	cpc	r27, r19
    3a7a:	e4 07       	cpc	r30, r20
    3a7c:	f5 07       	cpc	r31, r21
    3a7e:	20 f0       	brcs	.+8      	; 0x3a88 <__udivmodsi4_ep>
    3a80:	a2 1b       	sub	r26, r18
    3a82:	b3 0b       	sbc	r27, r19
    3a84:	e4 0b       	sbc	r30, r20
    3a86:	f5 0b       	sbc	r31, r21

00003a88 <__udivmodsi4_ep>:
    3a88:	66 1f       	adc	r22, r22
    3a8a:	77 1f       	adc	r23, r23
    3a8c:	88 1f       	adc	r24, r24
    3a8e:	99 1f       	adc	r25, r25
    3a90:	1a 94       	dec	r1
    3a92:	69 f7       	brne	.-38     	; 0x3a6e <__udivmodsi4_loop>
    3a94:	60 95       	com	r22
    3a96:	70 95       	com	r23
    3a98:	80 95       	com	r24
    3a9a:	90 95       	com	r25
    3a9c:	9b 01       	movw	r18, r22
    3a9e:	ac 01       	movw	r20, r24
    3aa0:	bd 01       	movw	r22, r26
    3aa2:	cf 01       	movw	r24, r30
    3aa4:	08 95       	ret

00003aa6 <strtod>:
    3aa6:	8f 92       	push	r8
    3aa8:	9f 92       	push	r9
    3aaa:	af 92       	push	r10
    3aac:	bf 92       	push	r11
    3aae:	cf 92       	push	r12
    3ab0:	df 92       	push	r13
    3ab2:	ef 92       	push	r14
    3ab4:	ff 92       	push	r15
    3ab6:	0f 93       	push	r16
    3ab8:	1f 93       	push	r17
    3aba:	cf 93       	push	r28
    3abc:	df 93       	push	r29
    3abe:	ec 01       	movw	r28, r24
    3ac0:	5b 01       	movw	r10, r22
    3ac2:	61 15       	cp	r22, r1
    3ac4:	71 05       	cpc	r23, r1
    3ac6:	19 f0       	breq	.+6      	; 0x3ace <strtod+0x28>
    3ac8:	fb 01       	movw	r30, r22
    3aca:	80 83       	st	Z, r24
    3acc:	91 83       	std	Z+1, r25	; 0x01
    3ace:	f9 90       	ld	r15, Y+
    3ad0:	8f 2d       	mov	r24, r15
    3ad2:	90 e0       	ldi	r25, 0x00	; 0
    3ad4:	0e 94 c1 1e 	call	0x3d82	; 0x3d82 <isspace>
    3ad8:	89 2b       	or	r24, r25
    3ada:	c9 f7       	brne	.-14     	; 0x3ace <strtod+0x28>
    3adc:	fd e2       	ldi	r31, 0x2D	; 45
    3ade:	ff 16       	cp	r15, r31
    3ae0:	21 f4       	brne	.+8      	; 0x3aea <strtod+0x44>
    3ae2:	f9 90       	ld	r15, Y+
    3ae4:	ee 24       	eor	r14, r14
    3ae6:	e3 94       	inc	r14
    3ae8:	05 c0       	rjmp	.+10     	; 0x3af4 <strtod+0x4e>
    3aea:	2b e2       	ldi	r18, 0x2B	; 43
    3aec:	f2 16       	cp	r15, r18
    3aee:	09 f4       	brne	.+2      	; 0x3af2 <strtod+0x4c>
    3af0:	f9 90       	ld	r15, Y+
    3af2:	ee 24       	eor	r14, r14
    3af4:	8e 01       	movw	r16, r28
    3af6:	01 50       	subi	r16, 0x01	; 1
    3af8:	10 40       	sbci	r17, 0x00	; 0
    3afa:	c8 01       	movw	r24, r16
    3afc:	65 e6       	ldi	r22, 0x65	; 101
    3afe:	74 e0       	ldi	r23, 0x04	; 4
    3b00:	43 e0       	ldi	r20, 0x03	; 3
    3b02:	50 e0       	ldi	r21, 0x00	; 0
    3b04:	0e 94 c9 1e 	call	0x3d92	; 0x3d92 <strncasecmp_P>
    3b08:	89 2b       	or	r24, r25
    3b0a:	01 f5       	brne	.+64     	; 0x3b4c <strtod+0xa6>
    3b0c:	8e 01       	movw	r16, r28
    3b0e:	0e 5f       	subi	r16, 0xFE	; 254
    3b10:	1f 4f       	sbci	r17, 0xFF	; 255
    3b12:	c8 01       	movw	r24, r16
    3b14:	68 e6       	ldi	r22, 0x68	; 104
    3b16:	74 e0       	ldi	r23, 0x04	; 4
    3b18:	45 e0       	ldi	r20, 0x05	; 5
    3b1a:	50 e0       	ldi	r21, 0x00	; 0
    3b1c:	0e 94 c9 1e 	call	0x3d92	; 0x3d92 <strncasecmp_P>
    3b20:	89 2b       	or	r24, r25
    3b22:	19 f4       	brne	.+6      	; 0x3b2a <strtod+0x84>
    3b24:	8e 01       	movw	r16, r28
    3b26:	09 5f       	subi	r16, 0xF9	; 249
    3b28:	1f 4f       	sbci	r17, 0xFF	; 255
    3b2a:	a1 14       	cp	r10, r1
    3b2c:	b1 04       	cpc	r11, r1
    3b2e:	19 f0       	breq	.+6      	; 0x3b36 <strtod+0x90>
    3b30:	f5 01       	movw	r30, r10
    3b32:	00 83       	st	Z, r16
    3b34:	11 83       	std	Z+1, r17	; 0x01
    3b36:	e0 fc       	sbrc	r14, 0
    3b38:	04 c0       	rjmp	.+8      	; 0x3b42 <strtod+0x9c>
    3b3a:	70 e0       	ldi	r23, 0x00	; 0
    3b3c:	90 e0       	ldi	r25, 0x00	; 0
    3b3e:	80 e8       	ldi	r24, 0x80	; 128
    3b40:	14 c0       	rjmp	.+40     	; 0x3b6a <strtod+0xc4>
    3b42:	70 e0       	ldi	r23, 0x00	; 0
    3b44:	90 e0       	ldi	r25, 0x00	; 0
    3b46:	80 e8       	ldi	r24, 0x80	; 128
    3b48:	6f ef       	ldi	r22, 0xFF	; 255
    3b4a:	08 c1       	rjmp	.+528    	; 0x3d5c <strtod+0x2b6>
    3b4c:	c8 01       	movw	r24, r16
    3b4e:	6d e6       	ldi	r22, 0x6D	; 109
    3b50:	74 e0       	ldi	r23, 0x04	; 4
    3b52:	43 e0       	ldi	r20, 0x03	; 3
    3b54:	50 e0       	ldi	r21, 0x00	; 0
    3b56:	0e 94 c9 1e 	call	0x3d92	; 0x3d92 <strncasecmp_P>
    3b5a:	89 2b       	or	r24, r25
    3b5c:	69 f4       	brne	.+26     	; 0x3b78 <strtod+0xd2>
    3b5e:	a1 14       	cp	r10, r1
    3b60:	b1 04       	cpc	r11, r1
    3b62:	29 f4       	brne	.+10     	; 0x3b6e <strtod+0xc8>
    3b64:	70 e0       	ldi	r23, 0x00	; 0
    3b66:	90 e0       	ldi	r25, 0x00	; 0
    3b68:	80 ec       	ldi	r24, 0xC0	; 192
    3b6a:	6f e7       	ldi	r22, 0x7F	; 127
    3b6c:	f7 c0       	rjmp	.+494    	; 0x3d5c <strtod+0x2b6>
    3b6e:	22 96       	adiw	r28, 0x02	; 2
    3b70:	f5 01       	movw	r30, r10
    3b72:	c0 83       	st	Z, r28
    3b74:	d1 83       	std	Z+1, r29	; 0x01
    3b76:	f6 cf       	rjmp	.-20     	; 0x3b64 <strtod+0xbe>
    3b78:	88 24       	eor	r8, r8
    3b7a:	99 24       	eor	r9, r9
    3b7c:	40 e0       	ldi	r20, 0x00	; 0
    3b7e:	50 e0       	ldi	r21, 0x00	; 0
    3b80:	60 e0       	ldi	r22, 0x00	; 0
    3b82:	70 e0       	ldi	r23, 0x00	; 0
    3b84:	ef 2d       	mov	r30, r15
    3b86:	e0 53       	subi	r30, 0x30	; 48
    3b88:	ea 30       	cpi	r30, 0x0A	; 10
    3b8a:	a0 f5       	brcc	.+104    	; 0x3bf4 <strtod+0x14e>
    3b8c:	f2 e0       	ldi	r31, 0x02	; 2
    3b8e:	ef 2a       	or	r14, r31
    3b90:	8e 2d       	mov	r24, r14
    3b92:	90 e0       	ldi	r25, 0x00	; 0
    3b94:	9c 01       	movw	r18, r24
    3b96:	28 70       	andi	r18, 0x08	; 8
    3b98:	30 70       	andi	r19, 0x00	; 0
    3b9a:	e2 fe       	sbrs	r14, 2
    3b9c:	06 c0       	rjmp	.+12     	; 0x3baa <strtod+0x104>
    3b9e:	23 2b       	or	r18, r19
    3ba0:	79 f5       	brne	.+94     	; 0x3c00 <strtod+0x15a>
    3ba2:	08 94       	sec
    3ba4:	81 1c       	adc	r8, r1
    3ba6:	91 1c       	adc	r9, r1
    3ba8:	2b c0       	rjmp	.+86     	; 0x3c00 <strtod+0x15a>
    3baa:	23 2b       	or	r18, r19
    3bac:	19 f0       	breq	.+6      	; 0x3bb4 <strtod+0x10e>
    3bae:	08 94       	sec
    3bb0:	81 08       	sbc	r8, r1
    3bb2:	91 08       	sbc	r9, r1
    3bb4:	db 01       	movw	r26, r22
    3bb6:	ca 01       	movw	r24, r20
    3bb8:	12 e0       	ldi	r17, 0x02	; 2
    3bba:	88 0f       	add	r24, r24
    3bbc:	99 1f       	adc	r25, r25
    3bbe:	aa 1f       	adc	r26, r26
    3bc0:	bb 1f       	adc	r27, r27
    3bc2:	1a 95       	dec	r17
    3bc4:	d1 f7       	brne	.-12     	; 0x3bba <strtod+0x114>
    3bc6:	48 0f       	add	r20, r24
    3bc8:	59 1f       	adc	r21, r25
    3bca:	6a 1f       	adc	r22, r26
    3bcc:	7b 1f       	adc	r23, r27
    3bce:	44 0f       	add	r20, r20
    3bd0:	55 1f       	adc	r21, r21
    3bd2:	66 1f       	adc	r22, r22
    3bd4:	77 1f       	adc	r23, r23
    3bd6:	4e 0f       	add	r20, r30
    3bd8:	51 1d       	adc	r21, r1
    3bda:	61 1d       	adc	r22, r1
    3bdc:	71 1d       	adc	r23, r1
    3bde:	48 39       	cpi	r20, 0x98	; 152
    3be0:	29 e9       	ldi	r18, 0x99	; 153
    3be2:	52 07       	cpc	r21, r18
    3be4:	29 e9       	ldi	r18, 0x99	; 153
    3be6:	62 07       	cpc	r22, r18
    3be8:	29 e1       	ldi	r18, 0x19	; 25
    3bea:	72 07       	cpc	r23, r18
    3bec:	48 f0       	brcs	.+18     	; 0x3c00 <strtod+0x15a>
    3bee:	84 e0       	ldi	r24, 0x04	; 4
    3bf0:	e8 2a       	or	r14, r24
    3bf2:	06 c0       	rjmp	.+12     	; 0x3c00 <strtod+0x15a>
    3bf4:	ee 3f       	cpi	r30, 0xFE	; 254
    3bf6:	31 f4       	brne	.+12     	; 0x3c04 <strtod+0x15e>
    3bf8:	e3 fc       	sbrc	r14, 3
    3bfa:	39 c0       	rjmp	.+114    	; 0x3c6e <strtod+0x1c8>
    3bfc:	98 e0       	ldi	r25, 0x08	; 8
    3bfe:	e9 2a       	or	r14, r25
    3c00:	f9 90       	ld	r15, Y+
    3c02:	c0 cf       	rjmp	.-128    	; 0x3b84 <strtod+0xde>
    3c04:	e5 33       	cpi	r30, 0x35	; 53
    3c06:	11 f0       	breq	.+4      	; 0x3c0c <strtod+0x166>
    3c08:	e5 31       	cpi	r30, 0x15	; 21
    3c0a:	89 f5       	brne	.+98     	; 0x3c6e <strtod+0x1c8>
    3c0c:	29 91       	ld	r18, Y+
    3c0e:	2d 32       	cpi	r18, 0x2D	; 45
    3c10:	19 f4       	brne	.+6      	; 0x3c18 <strtod+0x172>
    3c12:	e0 e1       	ldi	r30, 0x10	; 16
    3c14:	ee 2a       	or	r14, r30
    3c16:	05 c0       	rjmp	.+10     	; 0x3c22 <strtod+0x17c>
    3c18:	2b 32       	cpi	r18, 0x2B	; 43
    3c1a:	19 f0       	breq	.+6      	; 0x3c22 <strtod+0x17c>
    3c1c:	81 e0       	ldi	r24, 0x01	; 1
    3c1e:	90 e0       	ldi	r25, 0x00	; 0
    3c20:	03 c0       	rjmp	.+6      	; 0x3c28 <strtod+0x182>
    3c22:	29 91       	ld	r18, Y+
    3c24:	82 e0       	ldi	r24, 0x02	; 2
    3c26:	90 e0       	ldi	r25, 0x00	; 0
    3c28:	e2 2f       	mov	r30, r18
    3c2a:	e0 53       	subi	r30, 0x30	; 48
    3c2c:	ea 30       	cpi	r30, 0x0A	; 10
    3c2e:	18 f0       	brcs	.+6      	; 0x3c36 <strtod+0x190>
    3c30:	c8 1b       	sub	r28, r24
    3c32:	d9 0b       	sbc	r29, r25
    3c34:	1c c0       	rjmp	.+56     	; 0x3c6e <strtod+0x1c8>
    3c36:	20 e0       	ldi	r18, 0x00	; 0
    3c38:	30 e0       	ldi	r19, 0x00	; 0
    3c3a:	fc e0       	ldi	r31, 0x0C	; 12
    3c3c:	20 38       	cpi	r18, 0x80	; 128
    3c3e:	3f 07       	cpc	r19, r31
    3c40:	5c f4       	brge	.+22     	; 0x3c58 <strtod+0x1b2>
    3c42:	c9 01       	movw	r24, r18
    3c44:	88 0f       	add	r24, r24
    3c46:	99 1f       	adc	r25, r25
    3c48:	88 0f       	add	r24, r24
    3c4a:	99 1f       	adc	r25, r25
    3c4c:	28 0f       	add	r18, r24
    3c4e:	39 1f       	adc	r19, r25
    3c50:	22 0f       	add	r18, r18
    3c52:	33 1f       	adc	r19, r19
    3c54:	2e 0f       	add	r18, r30
    3c56:	31 1d       	adc	r19, r1
    3c58:	e9 91       	ld	r30, Y+
    3c5a:	e0 53       	subi	r30, 0x30	; 48
    3c5c:	ea 30       	cpi	r30, 0x0A	; 10
    3c5e:	68 f3       	brcs	.-38     	; 0x3c3a <strtod+0x194>
    3c60:	e4 fe       	sbrs	r14, 4
    3c62:	03 c0       	rjmp	.+6      	; 0x3c6a <strtod+0x1c4>
    3c64:	30 95       	com	r19
    3c66:	21 95       	neg	r18
    3c68:	3f 4f       	sbci	r19, 0xFF	; 255
    3c6a:	82 0e       	add	r8, r18
    3c6c:	93 1e       	adc	r9, r19
    3c6e:	ce 2c       	mov	r12, r14
    3c70:	dd 24       	eor	r13, r13
    3c72:	e1 fe       	sbrs	r14, 1
    3c74:	07 c0       	rjmp	.+14     	; 0x3c84 <strtod+0x1de>
    3c76:	a1 14       	cp	r10, r1
    3c78:	b1 04       	cpc	r11, r1
    3c7a:	21 f0       	breq	.+8      	; 0x3c84 <strtod+0x1de>
    3c7c:	21 97       	sbiw	r28, 0x01	; 1
    3c7e:	f5 01       	movw	r30, r10
    3c80:	c0 83       	st	Z, r28
    3c82:	d1 83       	std	Z+1, r29	; 0x01
    3c84:	cb 01       	movw	r24, r22
    3c86:	ba 01       	movw	r22, r20
    3c88:	0e 94 eb 19 	call	0x33d6	; 0x33d6 <__floatunsisf>
    3c8c:	7b 01       	movw	r14, r22
    3c8e:	8c 01       	movw	r16, r24
    3c90:	f3 e0       	ldi	r31, 0x03	; 3
    3c92:	cf 22       	and	r12, r31
    3c94:	dd 24       	eor	r13, r13
    3c96:	23 e0       	ldi	r18, 0x03	; 3
    3c98:	c2 16       	cp	r12, r18
    3c9a:	d1 04       	cpc	r13, r1
    3c9c:	21 f4       	brne	.+8      	; 0x3ca6 <strtod+0x200>
    3c9e:	17 fb       	bst	r17, 7
    3ca0:	10 95       	com	r17
    3ca2:	17 f9       	bld	r17, 7
    3ca4:	10 95       	com	r17
    3ca6:	57 01       	movw	r10, r14
    3ca8:	68 01       	movw	r12, r16
    3caa:	c8 01       	movw	r24, r16
    3cac:	b7 01       	movw	r22, r14
    3cae:	20 e0       	ldi	r18, 0x00	; 0
    3cb0:	30 e0       	ldi	r19, 0x00	; 0
    3cb2:	40 e0       	ldi	r20, 0x00	; 0
    3cb4:	50 e0       	ldi	r21, 0x00	; 0
    3cb6:	0e 94 4b 19 	call	0x3296	; 0x3296 <__cmpsf2>
    3cba:	88 23       	and	r24, r24
    3cbc:	09 f4       	brne	.+2      	; 0x3cc0 <strtod+0x21a>
    3cbe:	4a c0       	rjmp	.+148    	; 0x3d54 <strtod+0x2ae>
    3cc0:	97 fe       	sbrs	r9, 7
    3cc2:	0d c0       	rjmp	.+26     	; 0x3cde <strtod+0x238>
    3cc4:	24 e8       	ldi	r18, 0x84	; 132
    3cc6:	e2 2e       	mov	r14, r18
    3cc8:	24 e0       	ldi	r18, 0x04	; 4
    3cca:	f2 2e       	mov	r15, r18
    3ccc:	90 94       	com	r9
    3cce:	81 94       	neg	r8
    3cd0:	91 08       	sbc	r9, r1
    3cd2:	93 94       	inc	r9
    3cd4:	c0 e2       	ldi	r28, 0x20	; 32
    3cd6:	d0 e0       	ldi	r29, 0x00	; 0
    3cd8:	00 e0       	ldi	r16, 0x00	; 0
    3cda:	10 e0       	ldi	r17, 0x00	; 0
    3cdc:	12 c0       	rjmp	.+36     	; 0x3d02 <strtod+0x25c>
    3cde:	9c e9       	ldi	r25, 0x9C	; 156
    3ce0:	e9 2e       	mov	r14, r25
    3ce2:	94 e0       	ldi	r25, 0x04	; 4
    3ce4:	f9 2e       	mov	r15, r25
    3ce6:	f6 cf       	rjmp	.-20     	; 0x3cd4 <strtod+0x22e>
    3ce8:	f7 01       	movw	r30, r14
    3cea:	25 91       	lpm	r18, Z+
    3cec:	35 91       	lpm	r19, Z+
    3cee:	45 91       	lpm	r20, Z+
    3cf0:	54 91       	lpm	r21, Z+
    3cf2:	c6 01       	movw	r24, r12
    3cf4:	b5 01       	movw	r22, r10
    3cf6:	0e 94 40 1c 	call	0x3880	; 0x3880 <__mulsf3>
    3cfa:	5b 01       	movw	r10, r22
    3cfc:	6c 01       	movw	r12, r24
    3cfe:	8c 1a       	sub	r8, r28
    3d00:	9d 0a       	sbc	r9, r29
    3d02:	8c 16       	cp	r8, r28
    3d04:	9d 06       	cpc	r9, r29
    3d06:	84 f7       	brge	.-32     	; 0x3ce8 <strtod+0x242>
    3d08:	d5 95       	asr	r29
    3d0a:	c7 95       	ror	r28
    3d0c:	0f 5f       	subi	r16, 0xFF	; 255
    3d0e:	1f 4f       	sbci	r17, 0xFF	; 255
    3d10:	06 30       	cpi	r16, 0x06	; 6
    3d12:	11 05       	cpc	r17, r1
    3d14:	29 f0       	breq	.+10     	; 0x3d20 <strtod+0x27a>
    3d16:	8c ef       	ldi	r24, 0xFC	; 252
    3d18:	9f ef       	ldi	r25, 0xFF	; 255
    3d1a:	e8 0e       	add	r14, r24
    3d1c:	f9 1e       	adc	r15, r25
    3d1e:	f1 cf       	rjmp	.-30     	; 0x3d02 <strtod+0x25c>
    3d20:	c5 01       	movw	r24, r10
    3d22:	d6 01       	movw	r26, r12
    3d24:	7c 01       	movw	r14, r24
    3d26:	8d 01       	movw	r16, r26
    3d28:	8c 2d       	mov	r24, r12
    3d2a:	88 0f       	add	r24, r24
    3d2c:	8d 2d       	mov	r24, r13
    3d2e:	88 1f       	adc	r24, r24
    3d30:	8f 3f       	cpi	r24, 0xFF	; 255
    3d32:	51 f0       	breq	.+20     	; 0x3d48 <strtod+0x2a2>
    3d34:	c6 01       	movw	r24, r12
    3d36:	b5 01       	movw	r22, r10
    3d38:	20 e0       	ldi	r18, 0x00	; 0
    3d3a:	30 e0       	ldi	r19, 0x00	; 0
    3d3c:	40 e0       	ldi	r20, 0x00	; 0
    3d3e:	50 e0       	ldi	r21, 0x00	; 0
    3d40:	0e 94 4b 19 	call	0x3296	; 0x3296 <__cmpsf2>
    3d44:	88 23       	and	r24, r24
    3d46:	31 f4       	brne	.+12     	; 0x3d54 <strtod+0x2ae>
    3d48:	82 e2       	ldi	r24, 0x22	; 34
    3d4a:	90 e0       	ldi	r25, 0x00	; 0
    3d4c:	80 93 9c 22 	sts	0x229C, r24
    3d50:	90 93 9d 22 	sts	0x229D, r25
    3d54:	7e 2d       	mov	r23, r14
    3d56:	9f 2d       	mov	r25, r15
    3d58:	80 2f       	mov	r24, r16
    3d5a:	61 2f       	mov	r22, r17
    3d5c:	27 2f       	mov	r18, r23
    3d5e:	39 2f       	mov	r19, r25
    3d60:	48 2f       	mov	r20, r24
    3d62:	56 2f       	mov	r21, r22
    3d64:	b9 01       	movw	r22, r18
    3d66:	ca 01       	movw	r24, r20
    3d68:	df 91       	pop	r29
    3d6a:	cf 91       	pop	r28
    3d6c:	1f 91       	pop	r17
    3d6e:	0f 91       	pop	r16
    3d70:	ff 90       	pop	r15
    3d72:	ef 90       	pop	r14
    3d74:	df 90       	pop	r13
    3d76:	cf 90       	pop	r12
    3d78:	bf 90       	pop	r11
    3d7a:	af 90       	pop	r10
    3d7c:	9f 90       	pop	r9
    3d7e:	8f 90       	pop	r8
    3d80:	08 95       	ret

00003d82 <isspace>:
    3d82:	91 11       	cpse	r25, r1
    3d84:	1e c0       	rjmp	.+60     	; 0x3dc2 <__ctype_isfalse>
    3d86:	80 32       	cpi	r24, 0x20	; 32
    3d88:	19 f0       	breq	.+6      	; 0x3d90 <isspace+0xe>
    3d8a:	89 50       	subi	r24, 0x09	; 9
    3d8c:	85 50       	subi	r24, 0x05	; 5
    3d8e:	d0 f7       	brcc	.-12     	; 0x3d84 <isspace+0x2>
    3d90:	08 95       	ret

00003d92 <strncasecmp_P>:
    3d92:	fb 01       	movw	r30, r22
    3d94:	dc 01       	movw	r26, r24
    3d96:	41 50       	subi	r20, 0x01	; 1
    3d98:	50 40       	sbci	r21, 0x00	; 0
    3d9a:	88 f0       	brcs	.+34     	; 0x3dbe <strncasecmp_P+0x2c>
    3d9c:	8d 91       	ld	r24, X+
    3d9e:	81 34       	cpi	r24, 0x41	; 65
    3da0:	1c f0       	brlt	.+6      	; 0x3da8 <strncasecmp_P+0x16>
    3da2:	8b 35       	cpi	r24, 0x5B	; 91
    3da4:	0c f4       	brge	.+2      	; 0x3da8 <strncasecmp_P+0x16>
    3da6:	80 5e       	subi	r24, 0xE0	; 224
    3da8:	65 91       	lpm	r22, Z+
    3daa:	61 34       	cpi	r22, 0x41	; 65
    3dac:	1c f0       	brlt	.+6      	; 0x3db4 <strncasecmp_P+0x22>
    3dae:	6b 35       	cpi	r22, 0x5B	; 91
    3db0:	0c f4       	brge	.+2      	; 0x3db4 <strncasecmp_P+0x22>
    3db2:	60 5e       	subi	r22, 0xE0	; 224
    3db4:	86 1b       	sub	r24, r22
    3db6:	61 11       	cpse	r22, r1
    3db8:	71 f3       	breq	.-36     	; 0x3d96 <strncasecmp_P+0x4>
    3dba:	99 0b       	sbc	r25, r25
    3dbc:	08 95       	ret
    3dbe:	88 1b       	sub	r24, r24
    3dc0:	fc cf       	rjmp	.-8      	; 0x3dba <strncasecmp_P+0x28>

00003dc2 <__ctype_isfalse>:
    3dc2:	99 27       	eor	r25, r25
    3dc4:	88 27       	eor	r24, r24

00003dc6 <__ctype_istrue>:
    3dc6:	08 95       	ret

00003dc8 <_exit>:
    3dc8:	f8 94       	cli

00003dca <__stop_program>:
    3dca:	ff cf       	rjmp	.-2      	; 0x3dca <__stop_program>
