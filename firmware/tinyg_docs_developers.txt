/* TINYG DOCUMENTATION - DEVELOPER INFORMATION 
   Copyright (c) 2010 - 2011 Alden S. Hart Jr.

  Related documents include:
        OVERVIEW 		- Basic understanding of the application (this document)
        USING TINYG	- Connecting to the board, configuration, flashing, etc.
  ----> DEVELOPERS  	- Discussion of program internals, Setup in AVRstudio

	This file contains information that is also be on the wiki at
	http://www.synthetos.com/wiki/index.php?title=Projects:TinyG-Developer-Info:
*/
/*---- Notes on structure of this code ----

  The firmware controller, interpreter and stepper layers are organized as so:

	main.c/tinyg.h			- initialization and main loop
	controller.c/.h			- scheduler and related functions
	gcode.c/.h				- gcode parser / interpreter
	canonical_machine.c/.h	- machine model and machining command excution
	planner.c/.h			- line planning
	kinematics.c.h			- kinematic transofrmations 
	stepper.c/.h			- stepper controls, DDA

  Additional inmportant modules are"

	plan_arc.c/.h			- planner for arc motion. Split with canonical machine
	cycle_homing.c			- homing cycle. Other machining cycles will be added

	util.c/.h				- general purpose utility fucntions, debug support
	gpio.c/.h				- parallel ports, LEDs and switch support
	help.c/.h				- help screens
	settings.h				- default settings and machine selection
	  settings_lumenlabMicRoV3.h ... various machine specific default files
	  ...
	config.c/.h				- configuration sub-system
	xio....c/.h				- Xmega serial IO configuration sub-system
	xmega..c/.h				- Xmega hardware support files

  Summary:

	main.c/tinyg.h runs initialization. Global defines and the few 
	global variables are in tinyg.h

	controller.c.h accepts commands from the serial IO subsystem and 
	runs the scheduler - which is the "operating system". Of sorts.

	gcode.c/.h is the gcode parser. It reads and executes gcode blocks. 
	Gcode is executed by calling the underlying canonical machine 
	functions in canonical_machine.c/.h. The parser is stateless and 
	starts "from scratch" for each new gcode block (some state is 
	retrieved from the gcode model kept by the canonical machine).

	canonical_machine.c/.h implements the NIST RS274NGC canonical 
	machining functions (more or less). Some functions have been added,
	some not implemented, and some of the calling conventions are 
	different. The canonical machine normalizes all coordinates and 
	parameters to internal representation, keeps the Gcode model state,
	and makes calls to the planning and cycle layers for actual movement.

	The canonical machine is extensible to handle canned cycles like 
	homing cycles, tool changes, probe cycles, and other complex cycles 
	using motion primitives.(I'm not sure if this is exactly how Kramer 
	planned it - particularly when it comes to state management, but 
	it's how it's implemented).

	planner.c/.h does line acceleration / deceleration management to plan
	and execute lines. Additionally, it handles dwells, stop/start. 

	kinematics.c/.h implements the actual robot kinematics. A cartesian 
	robot for X,Y,Z, A, B and C axes is supported. Other types of robot 
	kinematics would extend or this layer. Also converts floats to integer
	steps

	stepper.c/.h runs the stepper motors using a fractional DDA. 
	Also invokes segment execution from planner putput, and loads 
	steppers as new segments are needed.


  	A note about efficiency: Having all these layers doesn't mean that 
	there are an excessive number of stack operations. Much of the code is 
	run as inlines and static scoped variables (i.e. not passed on the 
	stack). And even if there were a lot of function calls, most of the 
	code  doesn't need optimization anyway (with the exception of the 
	inner loops of the planner, steppers and some of the comm drivers)

  This file is organized around these modules - summary below:

*/

/* ---- Controller Operation ----
 *
 *	The controller provides a simple process control scheme to manage 
 *	blocking of multiple "threads" in the application. The controller 
 *	is an event-driven hierarchical state machine (HSM) using inverted
 *	control to manage a set of cooperative run-to-completion kernel tasks.
 * 	(same basic concepts as in: http://www.state-machine.com/)
 *
 *	More simply, it works as a set of aborting "superloops", one superloop
 *	per hierarchical state machine (or thread - sort of). Within each HSM
 *	the highest priority tasks are run first and progressively lower 
 *	priority tasks are run only if the higher priority tasks are not 
 *	blocked. No task ever actually blocks, but instead returns "busy" 
 *	(TG_EAGAIN) when it would ordinarily block. It must also provide a 
 *	re-entry point to resume the task once the blocking condition has 
 *	been removed.
 *
 *	For this scheme to work tasks must be written to run-to-completion 
 *	(non-blocking), and must offer re-entry points (continuations) to 
 *	resume operations that would have blocked 
 *
 *	All tasks are in a single dispatch loop, with the lowest-level tasks 
 *	ordered first. A task returns TG_OK or an error if it's complete, or 
 *	returns TG_EAGAIN to indicate that its blocked on a lower-level task.
 *	If TG_EAGAIN is received the controller aborts the dispatch loop and 
 *	starts over again at the top, ensuring that no higher level routines 
 *	(those further down in the dispatcher) will run until the routine 
 *	either returns successfully (TG_OK), or returns an error.
 *
 *	Interrupts run at the highest priority levels; kernel tasks are 
 *	organized into priority groups below the interrupt levels. The 
 *	priority of operations is:
 *
 *	- High priority ISRs
 *		- issue steps to motors / count dwell timings
 *		- dequeue and load next stepper move
 *
 *	- Medium priority ISRs
 *		- receive serial input (RX)
 *		- execute signals received by serial input
 *		- detect and flag limit switch closures
 *
 *	- Low priority ISRs
 *		- send serial output (TX)
 *
 *	- Main loop tasks
 *		These are divided up into layers depending on priority and blocking
 *		hierarchy. See tg_controller() for details.
 *
 *	See tinyg_docs.txt for how to write a continuation or see see 
 *	mp_line() for an example. 
 *
 *	Futures: Using a super loop instead of an event system is a design 
 *	tradoff - or more to the point - a hack. If the flow of control gets 
 *	much more complicated it will make sense to replace this section 
 *	with an event driven dispatcher.
 */
/* ---- Modedness (sort of - it's mostly hidden from the user) ----
 *
 *	TinyG appears to the command-line user as being non-moded. 
 *	However, this is not entirely true. Separate modes exist for 
 *	entering test modes, and for reserved modes such as dumb mode 
 *	(direct drive) and other parsers that are planned.
 *
 *	To exit any mode hit Q as the first character of the command line.
 *	Once you have hit Q, the following chars select the operating mode:
 *
 *		G,M,N,F,%,(	enter GCODE_MODE and perform that action
 *		T			execute primary test   (whatever you link into it)
 *		U			execute secondary test (whatever you link into it)
 *		H			help screen (returns to TEST mode)
 *		R			soft reset
 *		D			<reserved for dumb mode>
 *		I			<reserved>
 *		V			<reserved>
 *
 *	Once in the selected mode these characters are not active as mode 
 *	selects. 
 */

/* ---- Controller Design notes ----

  Some design goals for the controller:

	- Be able to interpret (and mix) various types of inputs, including:
		- Control commands from stdio - e.g. ^c, ^q/^p, ^n/^o...
		- Configuration commands for various sub-systems
		- Gcode blocks
		- Arbitrary commands that bypass the Gcode layer
		- Multi-DOF protocols TBD

	- Accept and mix inputs from multiple sources:
		- USB
		- RS-485
		- Arduino serial port (Aux)
		- strings in program memory
		- EEPROM data
		- SD card data

  Implemented by:

	- XIO is a set of character and line drivers underneath GCC stdio. 
	  XIO line readers are the lowest level (above single character read)
		From serial inputs: read single characters to assemble a string
		From in-memory strings: read characters from a string in program memory
		Either mode: read string to next terminator and return NULL terminated string 
		Do not otherwise process or normalize the string
	    See XIO Notes for details.

	- tg_parser is the top-level parser / dispatcher
		Examine the head of the string to determine how to dispatch
		Supported dispatches:
		- Gcode blocks
		- Gcode configuration lines
		- Direct drive (motion control) command
		- Network command / config (not implemented)

	- Individual parsers/interpreters are called from tg_parser
		These can assume:
		- They will only receive a single line (multi-line inputs have been split)
		- Tyey perform line normalization required for that dispatch type
		- Can run the current command to completion before receiving another command

	- There are two types of flow control to avoid overrning the inputs:

		APPLICATION_LEVEL FLOW CONTROL - The appication will return a prompt 
		with the characters "ok" in it when it is ready for the next block.
		It's possible to edit the code so only "ok" is returned if you want
		it to work exactly like grbl.
 
		SERIAL FLOW CONTROL - XON/XOFF flow control can also be enabled at 
		the serial level. In this case the serial RX buffer is kept full by a 
		certain percentage set by the XOFF_HI_WATER_MARK / XOFF_LO_WATER_MARK
		settings (compile time).
*/

/*---- How To Code Continuations ----

	Continuations are used to manage points where the application would 
	ordinarily block. Call it application managed threading by way of an 
	inverted control loop. By coding using continuations the application 
	does not need an RTOS and is extremely responsive (there are no "ticks")

	Rules for writing a continuation task:
	  - A continuation is a pair of routines. The first is the main routine,
		the second the continuation. See mc_line() and mc_line_continue().

	  - The main routine is called first and should never block. It may 
	    have function arguments. It performs all initial actions and sets 
		up a static structure to hold data that is needed by the 
		continuation routine. The main routine should end by returning a 
		uint8_t TG_OK or an error code.

	  - The continuation task is a callback that is permanemtly registered 
	  	at the right level of the blocking heirarchy in the tg_controller 
		loop; where it will be called repeatedly by the controller. The 
		continuation cannot have input args - all necessary data must be 
		available in the static struct (or by some other means).

	  - Continuations should be coded as state machines. See the homing 
	  	cycle as an example. Common states used by most machines include: 
		OFF, NEW, or RUNNING. OFF means take no action (return NOOP). 
		The state on initial entry after the main routine should be NEW.
		RUNNING is a catch-all for simple routines. More complex state
		machines may have numerous other states.

	  - The continuation must return the following codes and may return 
	  	additional codes to indicate various exception conditions:

	 	TG_NOOP: No operation ocurred. This is the usual return from an 
			OFF state. All continuations must be callable with no effect 
			when they are OFF (as they are called repeatedly by the 
			controller whether or not they are active).

		TG_EAGAIN: The continuation is blocked or still processing. This one 
			is really important. As long as the continuation still has work 
			to do it must return TG_EAGAIN. Returning eagain causes the 
			tg_controller dispatcher to restart the controller loop from 
			the beginning, skipping all later routines. This enables 
			heirarchical blocking to be performed. The later routines will 
			not be run until the blocking conditions at the lower-level are
			removed.

		TG_OK; The continuation task  has just is completed - i.e. it has 
			just transitioned to OFF. TG_OK should only be returned only once. 
			The next state will be OFF, which will return NOOP.

		TG_COMPLETE: This additional state is used for nesting state 
			machines such as the homing cycle or other cycles (see the 
			homing cycle as an example of a nested state machine). 
			The lower-level routines called by a parent will return 
			TG_EAGAIN until they are done, then they return TG_OK. 
			The return codes from the continuation should be trapped by 
			a wrapper routine that manages the parent and child returns 
			When the parent REALLY wants to return it sends its wrapper 
			TG_COMPLETE, which is translated to an OK for the parent routine.
*/


/**** xio subsystem ****/

XIO is a set of drivers for AVRgcc stdio. See xio.h for starters

XIO provides common access to native and derived xmega devices 
XIO devices are compatible with avr-gcc stdio and also provide some special 
functions that extend stdio.

Stdio support:
	- http://www.nongnu.org/avr-libc/user-manual/group__avr__stdio.html
 	- Stdio compatible putc() and getc() functions provided for each device
	- This enables fgets, printf, scanf, and other stdio functions
 	- Full support for formatted printing is provided (including floats)
 	- Assignment of a default device to stdin, stdout & stderr is provided 
	- printf() and printf_P() send to stdout, so use fprintf() to stderr
		for things that should't go over RS485 in SLAVE mode 

 Facilities provided beyond stdio:
	- Devices are managed as an enumerated array of derived devices
	- Supported devices include:
		- USB (derived from USART)
		- RS485 (derived from USART)
		- Arduino connection (derived from USART)
		- Program memory "files" (read only)
		- EEPROM "files" (limited read/write capabilities)
		- GPIO ports
		- (other devices will be added as needed)
	- Stdio FILE streams are managed as bindings to the above devices
	- Additional functions provided include:
		- open file (initialize address and other parameters)
		- gets (non-blocking input line reader - extends fgets)
		- ctl (ioctl-like knockoff for setting device parameters)
		- signal handling - captures ^c, pause, resume, etc. as interrupts
		- interrupt buffered RX and TX functions 
		- XON/XOFF software flow control implemented
*/
/*---- Notes on the circular buffers ----

  An attempt has beeen made to make the circular buffers used by low-level 
  putc/getc as efficient as possible. This enables high-speed serial IO 
  operating between 100K and 1Mbaud.

  The circular buffers are unsigned char arrays that fill down from the 
  top element and wrap back to the top when index zero is reached. This 
  allows pre-decrement operations, zero tests, and eliminates modulus, 
  masks, substractions and other less efficient array bounds checking. 
  Buffer indexes are all uint_fast8_t which limits these buffers to 254 
  usable locations. (one location is lost to head/tail collision detection 
  and one is lost to the zero position) All this enables the compiler to 
  do better optimization.

  Chars are written to the *head* and read from the *tail*. 

  The head is left "pointing to" the character that was previously 
  written - meaning that on write the head is pre-decremented (and 
  wrapped, if necessary), then the new character is written.

  The tail is left "pointing to" the character that was previouly read - 
  meaning that on read the tail is pre-decremented (and wrapped, if 
  necessary), then the new character is read.

  The head is only allowed to equal the tail if there are no characters 
  to read.

  On read: If the head = the tail there is nothing to read, so the 
  function either exits with TG_EAGAIN or blocks (depending on the 
  blocking mode selected).

  On write: If the head pre-decrement causes the head to equal the tail 
  the buffer is full. The head is left at its original value and the 
  device should go into flow control (and the byte in the USART device is 
  not read, and therefore remains in the USART (VERIFY THAT I DIDN'T BREAK 
  THIS BEHAVIOR!)). Reading a character from a buffer that is in flow 
  control should clear flow control.

  (Note: More sophisticated flow control would detect the full condition 
   earlier, say at a high water mark of 95% full, and may go out of flow 
   control at some low water mark like 33% full).
*/
/*---- Notes on control characters and signals ----

  The underlying USART RX ISRs (used by getc() and gets()) trap control 
  characters and treat them as signals. 
  
  On receipt of a signal the signal value (see enum xioSignals) is written 
  to xioDEVICE.sig and a signal handler specific to that signal is invoked 
  (see signals.c). The signal character is not written into the RX buffer.
  
  The signal handler runs at the ISR level, so it might be run, set some 
  flag somewhere, or just return, relying on the application to detect the 
  sig value being set. It's up to the app to reset sig. If a new signal 
  arrives before the previous sig is handled or cleared the new sig will 
  overwrite the previous sig value.

  For now, the control chars and their mapping to signals are hard-coded 
  into the ISR for simplicity and speed. A more flexible system of 
  bindings and callbacks could be written at some sacrifice to execution 
  speed. 

  IMPORTANT--> Since signals are trapped at the ISR level it is not 
  necessaryto be actively reading a device for it to receive signals. 
  Any configured IO device will process signals. This allows input lines 
  to come from one source (e.g. a file device), while pause, resume and 
  kill are still active from another device (e.g. the USB port being used 
  as a console).
*/

/*---- Notes on signal callbacks ----
  An earlier version of the code had signals implemented as callbacks. 
  Here's how it worked.

The struct had sig_func and line_func callback addresses:

struct xioUSART {
	// PUBLIC VARIABLES - must be the same in every device type
	uint16_t flags;				 // control flags
	uint8_t sig;				 // signal or error value
	char c;						 // line buffer character temp
	uint8_t i;					 // line buffer pointer
	uint8_t len;				 // line buffer maximum length (zero based)
	char *buf;					 // pointer to input line buffer
	int (*sig_func)(uint8_t sig);// pointer to signal handler function
	int (*line_func)(char * buf);// pointer to line handler function

	// PRIVATE VARIABLES - in this case for USART. Can be different by device type
	volatile uint8_t rx_buf_tail; // RX buffer read index
	volatile uint8_t rx_buf_head; // RX buffer write index (written by ISR)
	volatile uint8_t tx_buf_tail; // TX buffer read index (written by ISR)
	volatile uint=8_t tx_buf_head; // TX buffer write index
	uint8_t next_tx_buf_head;	  // next TX buffer write index
	volatile unsigned char rx_buf[RX_BUFFER_SIZE];  // (written by ISR)
	volatile unsigned char tx_buf[TX_BUFFER_SIZE];

	// hardware bindings
	struct USART_struct *usart;	  // USART structure
	struct PORT_struct *port;	  // corresponding port
};

Bindings occurred during init in xio_usb_init():

	// bind signal and line handlers to struct
	f.sig_func = &xio_null_signal;		// bind null signal handler
	f.line_func = &xio_null_line;		// bind null line handler

...and as controls in xio_usb_control():

	// commands with args - only do one flag if there's an arg
	if (control & XIO_SIG_FUNC) {
		f.sig_func = (fptr_int_uint8)arg;
		return (0);	
	}
	if (control & XIO_LINE_FUNC) {
		f.line_func = (fptr_int_char_p)arg;
		return (0);
	}

  Using these defines:

#define XIO_SIG_FUNC	(1<<4)			// signal handler function 
#define XIO_LINE_FUNC	(1<<5)			// line handler function 

Applications may call the control functions to bind signal handlers:

	xio_control(XIO_DEV_USB, XIO_SIG_FUNC, (int)&tg_signal); // bind sig handler
	xio_control(XIO_DEV_RS485, XIO_SIG_FUNC, (int)&tg_signal);
	xio_control(XIO_DEV_AUX, XIO_SIG_FUNC, (int)&tg_signal);

*/

/**************************************************************************
 * mp_aline() - plan a line with acceleration / deceleration
 *
 *	This function uses constant jerk motion equations to plan acceleration 
 *	and deceleration. The jerk is the rate of change of acceleration; it's
 *	the 1st derivative of acceleration, and the 3rd derivative of position. 
 *	Jerk is a measure of impact to the machine can take. Controlling jerk 
 *	smoothes transitions between moves and allows for faster feeds while 
 *	controlling machine oscillations and other undesirable side-effects.
 *
 *	The controlled jerk makes an "S curve" move known as a 5 segment move. 
 *	The accel and decel segments are divided into concave and convex 
 *	halves, plus a cruise segment makes 5 segments.
 *
 *	A 5 segment S curve "block" takes exactly the same time to execute as a 
 *	simpler constant acceleration trapezoidal block - it's just the endpoint
 *	transitions are smoother. The time lost in smoothing the endpoint 
 *	transitions is made up by a higher midpoint acceleration.
 *
 *	(It is possible to achieve further time optimization by inserting a 
 *	 constant acceleration segment in between the two accel/decel segments.
 *	 (7 seg block) For more background and the motion equations see Ed Red's 
 *	 BYU robotics course: http://www.et.byu.edu/~ered/ME537/Notes/Ch5.pdf.)
 */
/*	Aline() plans a 5 segment block as 3 regions:
 *	  - head	acceleration to target velocity (2 acceleration segments)
 *	  - body	bulk of move at target speed 	(1 cruise segment)
 *	  - tail	deceleration to exit velocity 	(2 deceleration segments)
 *
 *	The initial velocity of the head is dependent on the path control mode
 *	in effect and the transition jerk. Vi is always zero for EXACT STOP mode. 
 *	For EXACT PATH and CONTINUOUS modes Vi is computed based on the requested 
 *	cruise velocity and the magnitude of the linear and tangential (cornering) 
 *	jerk. (It gets complicated. See "Backplanning, below")
 *
 *	The body is the cruise segment where the block is running at its requested 
 *	velocity - or lower if this cannot be achieved. The tail of each block 
 *	is always intially planned to decelerate to zero. This may change to a 
 *	non-zero value as new blocks are added and the block chain is re-planned.
 *
 *	As mentioned above, sufficient length is reserved in the tail to allow 
 *	deceleration from the cruise velocity to zero (braking). If the next 
 *	block has a non-zero entry velocity the previous blocks are 
 *	recomputed (backplanned) to attain the maximum velocity while still 
 *	supporting braking to zero. 
 */
/*	Aline() is separated into a line planner routine and a runtime execution 
 *	routine that is executed by mp_move_dispatcher()
 *
 *  Line planner:
 *
 *	  The aline() trajectory planner main routine is called to compute and 
 *	  queue a new block. It computes the initial parameters for the new block 
 *	  (trapezoid), then recomputes the planner buffer queue to optimize the
 *	  existing blocks relative to the new block.
 * 
 *  Line Execution (runtime)
 *
 *	  The aline continuation routine (run routine) executes the planned block.
 *	  Head and tail acceleration / deceleration segments are run as a set of 
 *	  constant-time very-short-line-segments that implement the stepwise-linear 
 *	  accel/decel transition. The segment time constant is chosen (~10 ms) to 
 *	  allow sufficiently fine accel/decel resolution and enough steps to occur 
 *	  in a segment so that low velocity moves are not jerky. 
 */
/*
 * Backplanning
 *
 *	Backplanning recomputes segments and velocities of previous blocks to fit 
 *	the acceleration and distance constraints & optimize target velocities.
 *
 *	Backplanning occurs as a two-pass operation. The first pass is a 
 *	backwards pass that starts at the head of the block currently being 
 *	added and continues back to the tail of the earliest block that cannot 
 *	be replanned (first non-replannable block). 
 *
 *	Planning a block is driven by these constraints: 
 *
 *	(1) Cannot exceed the maximum entry velocity of the block. This is the 
 *		minimum of the block's cruise velocity or the cornering velocity 
 *		(junction velocity).
 *
 *	(2)	The maximum exit velocity of the block must allow the remaining
 *		blocks in the chain to decelerate to zero - or to decelerate to the 
 *		max entry velocity of a subsequent block if that's the dominant term.
 *
 *	(3) The change in velocity between the entry and exit (the delta V) 
 *		cannot exceed the maximum allowable velocity change supported by the 
 *		length of the block and jerk maximum.
 *
 *	(4)	The exit and entry velocities of adjacent blocks must be equal. 
 *
 *	Variables used in planning are: 
 *
 *	velocity terms: These are the velocity terms adjusted to meet the above
 *		constraints. They are then passed to the trapezoid calculator where 
 *		they may be further modified.
 *
 *		entry_velocity
 *		cruise_velocity - max block velocity whether or not there is a cruise region
 *		exit_velocity
 *
 *	_vmax terms: These are computed once and may be used repeatedly during
 *		backplanning. They will not change.
 *
 *		cruise_vmax is the requested cruise velocity of the block 
 *
 *		entry_vmax is the maximum velocity at which the move can be entered. 
 *		It is the minimum of the maximum junction velocity between it and the 
 *		previous block and cruise_vmax. It is set to zero for an EXACT STOP.
 *
 *		delta_vmax is the maximum change in velocity possible for the block 
 *		based on the length and the jerk term (Note: the starting velocity Vi
 *		is irrelevant to the computation in this case).
 *
 *		exit_vmax is the maximum velocity that the move can exit.It is set to 
 *		zero for an EXACT STOP.
 *
 *	braking_velocity is the maximum entry velocity for the block that will 
 *		allow the subsequent replan chain to brake to zero. Braking velocities 
 *		are recomputed for each new block added. 
 *
 *	The number of blocks in the replan chain is determined by the first 
 *	"non-replannable" block. A block becomes non-replannable when:
 *
 *	  (1) The move is already executing. 
 *	  (2) It's an exact stop move (always runs to zero)
 *	  (3) The block has been optimized, i.e. hits all it's max velocities
 *			of cannot otherwise be improved. This can be detected if the 
 *			exit velocity has achieved exit_vmax during forward planning
 */
/*
 * Notes:
 *	(1)	All math is done in absolute coordinates using "double precision" 
 *		floating point (even though AVRgcc does this as single precision)
 */


/*---- Line planning and execution ----
 *
 *	Move generation and execution takes place at 3 levels:
 *
 *	Move planning occurs at the main-loop level. The canonical machine calls
 *	the planner to generate lines, arcs, dwells and synchronous  stop/starts.
 *	The planner module generates blocks (bf's) that hold parameters for lines
 *	and the other move types. The blocks are backplanned to join lines, and to
 *	take dwells and stops into account. ("plan" stage).
 *
 *	Arc movement is planned above the above the line planner. It generates 
 *	short lines to the line planner.
 *
 *	Move execution and load prep takes place at the MED interrupt level. Move
 *	execution generates the next acceleration, cruise, or deceleration segments 
 *	for planned lines, or just transfers parameters needed for dwells and stops.
 *	This layer also prepares moves for loading by converting the executed move
 *	into parameters that can be directly loaded into the steppers. 
 *	("exec" and "prep" stages)
 *
 *	Pulse train generation takes place at the HI interrupt level. The stepper 
 *	DDA fires timer interrupts that generate the stepper pulses. This level also 
 *	transfers the new stepper parameters once each segment is complete ("load" 
 *	and "run" stages)
 */
/*	As long as the steppers are running the sequence of events is:
 *	  - The stepper interrupt (HI) runs the DDA to generate a pulse train
 *	  	  for the current move.
 *	  - When the move is finished the stepper interrupt loads the next move
 *		  from the move buffer, reloads the timers, and starts the next move.
 *		  At the end of the load the stepper interrupt routine requests an 
 *		  "exec" of the next move in order to prepare for the next load 
 *		  operation. It does this by calling the exec using a "software 
 *		  interrupt" (actually a timer).
 *	  - As a result of the above, the exec handler fires at the MED interrupt 
 *		  level. It executes the next segment in the running plan buffer 
 *		  [using the callback registered in the plan buffer right] or gets 
 *		  and runs the next buffer in the planning queue - depending on the 
 *		  move_type and state. Then the exec handler runs the prep routine 
 *		  needed to get the segment or move into the move buffer.
 *	  - The main loop runs in background to receive gcode blocks, parse them,
 *		  and send them to the planner in order to keep the planner queue 
 *		  full. 
 *
 *	If the steppers are not running the above is similar, except that the exec
 * 	is invoked from the main loop by the software interrupt, and the stepper 
 *	load is invoked from the exec by another software interrupt.
 *
 *	Control flow can be a bit confusing. This is a typical sequence for planning 
 *	generating (executing) and running an acceleration planned line:
 *	 1  planner.mp_aline() is called, which populates a planning buffer (bf) 
 *		and back-plans pre-existing buffers.
 *	 2  When a new buffer is added the planner calls stepper.st_request_exec()
 *		to attempt to execute the first segment in the buffer. 
 *	 3a If the steppers are not busy this will set a timer to cause a 
 *		"software interrupt" that will ultimately call st_exec_move(). 
 *	 3b If the steppers are already busy this request is ignored, as it will be 
 *		performed later once the steppers are ready.
 *	 4  The request triggers a software interrupt (timer) that calls 
 *		_st_exec_move() at the MED interupt level
 *	  5 _st_exec_move() calls back to planner.mp_exec_move() which generates 
 *		the next segment using the mr singleton.
 *	  6 When this operation is complete mp_exec_move() calls the appropriate
 *		prep routine in stepper.c to derive the stepper parameters that will 
 *		be needed to run the move - in this case st_prep_line().
 *	  7 st_prep_line() generates the timer and DDA values and stages these into 
 *		the sp structure - ready for load.
 *	  8 st_prep_line() returns back to mp_exec_move(), which may decide to free
 *		the bf buffer back to the planner buffer pool if the move is complete. 
 *		At this point the MED interrupt is complete (Note: I may have to return 
 *		the buffer at the main-loop level if there are data conflicts).
 *	  9 At some point in the future when the current stepper move is done the
 *		stepper inner-loop (interrupt level HI) will load the next move by calling
 *		_st_load_move().
 *	  10 The final step in the sequence is _st_load_move() requesting the next 
 *		 segment to be executed and prepared by calling st_request_exec() 
 *		 - control goes back to step 4.
 *
 *	Note: For this to work you have to be really careful about what structures
 *	are modified at what level, and use volatiles where necessary.
 */

/*---- Notes on the operation of the DDA ----
	Coordinated motion (line drawing) is performed using a classic 
	Bresenham DDA as per reprap and grbl. A number of additional steps 
	are taken to optimize interpolation and pulse train accuracy.

	- The DDA accepts and processes fractional motor steps. Steps are 
	  passed to the move queue as doubles, and may have fractional values
	  for the steps (e.g. 234.934 steps is OK). The DDA implements 
	  fractional steps and interpolation by extending the counter range 
	  downward and using a varaiab;le fixed-point binary. It uses the 
	  DDA_SUBSTEPS setting to control fixed-point precision.

	- The DDA is not used as a 'ramp' for acceleration management. Accel
	  is computed as 3rd order (maximum jerk) equations that generate 
	  piecewise linear accel/decel segments to the DDA in much the same 
	  way arc drawing is approximated. The DDA runs at a constant rate 
	  for each segment up to a maximum of 50 Khz step rate. The segment
	  update rate (time length of segments) is set by the MIN_SEGMENT_USEC
	  setting in planner.h - which is typically 10 ms segment times.

	- The DDA rate for a segment is set to an integer multiple of the 
	  step freqency of the fastest motor (major axis). This amount of 
	  overclocking is controlled by the DDA_OVERCLOCK value, typically 16x.
	  A minimum DDA rate is enforced that prevents overflowing the 16 bit 
	  DDA timer PERIOD value. The DDA timer always runs at 32 Mhz. The 
	  prescaler is not used. Various methods are used to keep the numbers 
	  in range for long lines. See _mq_set_f_dda() for details.

	- Pulse phasing is preserved between segments if possible. This makes
	  for smoother motion, particularly at very low speeds and short 
	  segment lengths (avoids pulse jitter). Phase continuity is achieved 
	  by simply not resetting the DDA counters across segments. In some 
	  cases the differences between timer values across segments are too 
	  large for this to work, and you risk motor stalls due to pulse 
	  starvation. These cases are detected and the counters are reset 
	  to prevent stalling.

	- Pulse phasing is also helped by minimizing the time spent loading 
	  the next move segment. To this end as much as possible about that 
	  move is pre-computed during the queuing phase. Also, all moves are 
	  loaded from the interrupt level, avoiding the need for mutual 
	  exclusion locking or volatiles (which slow things down).
 */



/*---- Starting, Stopping and Program State ----
  
  NIST RS274NGC_3 defines program run state semantics as so:

 	(Program) Start Program starts when if begins receiving blocks.
  					Corresponds to pressing the "cycle start" button.
					Program preserves state from previously run program, or
					defaults to persisted state (defaults, currently) upon power-on

 	(Program) Stop {M0} Program stops running temporarily (also M1)

 	(Program) End {M2} Program ends without the ability to resume
  					Also corresponds to trailing '%' sign in a g-code file

 	Reset 	  Resets machine parameters to defaults (NIST pg 38):
					- zero is reset
					- plane is set to xy
					- distance mode is set to absolute mode
					- feed rate mode is set to units per minute
					- spindle stopped
					- current motion mode set to G1
					- (others may be added)

*/

/*--- AVRstudio4 compile and link instructions and help ----

	Install WinAVR and AVRStudio 4 (if not already installed):
		run WinAVR-20100110-install.exe
		run AvrStudio4Setup.exe
		run AVRStudio4.18SP1.exe (last one before they went to Studio 5)

	Device should have already been selected to be atxmega192a3 or 
		atxmega256a3. If not:
		In AVRstudio select Project / Configuration Options
		In main window select device atxmega256a3

	Configure clock frequency (optional, but recommended)
		In Project / Configuration Options main window:
		Frequency should be 32000000 		(32 Mhz)
	  also may want set 32.0000 Mhz in Simulator2 configs:
		Go into debug mode
		In Debug / AVR Simulator 2 Options
		Set clock frequency to 32 Mhz.

	Add libm.a (math lib) otherwise the floating point will fail.
		In AVRstudio select Project / Configuration Options
		Select Libraries
		Move libm.a from the left pane to the right pane
		ref: http://www.avrfreaks.net/index.php?name=PNphpBB2&file=printview&t=80040&start=0

	AVRstudio Custom Compilations Options
		In AVRstudio select Project / Configuration Options
		Select Custom Options
		The right pane should read:
			-Wall
			-gdwarf-2
			-std=gnu99
			-DF_CPU=32000000UL
			-O0		(or typically Os)
			-funsigned-char
			-funsigned-bitfields
			-fpack-struct
			-fshort-enums

	Add floating point formatting code to the linker string (for printf %f to work)
		In AVRstudio select Project / Configuration Options
		Select Custom Options
		In the left pane (Custom Compilation Options) Select [Linker Options] 
		Add the following lines to the right pane (is now linker options)
			-Wl,-u,vfprintf				(Wl --->thats: W"lower-case ell" not W"one")
			-lprintf_flt
			-lm
		ref: http://www.avrfreaks.net/index.php?name=PNphpBB2&file=printview&t=92299&start=0
		ref: http://www.cs.mun.ca/~paul/cs4723/material/atmel/avr-libc-user-manual-1.6.5/group__avr__stdio.html#ga3b98c0d17b35642c0f3e4649092b9f1

  	An annoying avr20100110 bug: 
  		If you are running WinAVR-20100110 you may be asked to locate 
		libraries or include files that were known to a previous avr-gcc 
		version. 

		When asked to browse for stdlib files, go to: 	 
			C:\WinAVR-20100110\avr\lib\avrxmega6
			(or is it: C:\WinAVR-20100110\lib\gcc\avr\4.3.3\avrxmega6

		When asked to browse for include files go to: 
			C:\WinAVR-20100110\avr\include
*/
/* ---- AVRstudio5 compile and link instructions and help ----

	Note: I gave up on AVRStudio5 until it's more stable. These notes were
		  compiled using the beta releases and may be dated.

	Settings in Project / TinyG Properties
		Build: generate .hex files (others are useful)

		Toolchain:
			General: unsigned defaults
			Symbols: -DF_CPU=32000000UL						  [see Note 1]
			Optimization: -Os, -fpack-struct, -fshort-enums
			Warnings: -Wall
			Miscellaneous: -gdwarf-2 -std=gnu99

		  Linker: -Wl,-lm -Wl,-u,vfprintf -mmcu=atxmega256a3 [see Note 2]
			Libraries:	libm.a
						libprintf_flt.a
			Miscellaneous: -Wl,-u,vfprintf 
			
		  Assembler (should set automatically) [see Note 2]
			-Wa,-gdwarf2 -x assembler-with-cpp -c -Wall -gdwarf-2 -std=gnu99
			-DF_CPU=32000000UL -O0 -funsigned-char -funsigned-bitfields 
			-fpack-struct -fshort-enums  -mmcu=atxmega256a3 

		Device: atxmega192a3 or atxmega256a3
		
		Debugging: AVR Simulator

	Note 1: You may also want to set the clock F to 32 Mhz in the 
			Processor window when you first start the Simulator (debugger)
			
	Note 2: You must add floating point formatting code to the linker string
			for printf %f to work.
			 -Wl,-u,vfprintf  (Wl ->thats: W"lower-case ell" not W"one")
			 -lprintf_flt	  (or add libprintf_flt.a to the libs)
			 -lm
 ref: http://www.avrfreaks.net/index.php?name=PNphpBB2&file=printview&t=92299&start=0
 ref: http://www.cs.mun.ca/~paul/cs4723/material/atmel/avr-libc-user-manual-1.6.5/group__avr__stdio.html#ga3b98c0d17b35642c0f3e4649092b9f1
*/

