// The formatting of this file is a little weird as it's actually source text for the wiki.

/**** APPLICATION NOTES ****/

/*---- Introduction ----


*/
/*---- Supported GCode commands ----
 	G0				Rapid linear motion
	G1				Linear motion at feed rate
	G2, G3			Clockwise / counterclockwise arc at feed rate
	G4				Dwell
	G17, G18, G19	Select plane: XY plane {G17}, XZ plane {G18}, YZ plane {G19}
	G20, G21		Length units: inches {G20}, millimeters {G21}
	G53				Move in absolute coordinates
	G61, G61.1, G64 Set path control mode (group 13)
	G80				Cancel motion mode
	G90, G91		Set distance mode; absolute {G90}, incremental {G91}
	G92				Coordinate System Offsets - limited support provided
	G93, G94		Set feed rate mode: inverse time mode {G93}, 
										units per minute mode {G94}
	M0				Program stop
	M1				Optional program stop
	M2				Program end
	M3, M4			Turn spindle clockwise / counterclockwise
	M5				Stop spindle turning
	M30				Program end (pallet shuttle and reset)
	M60				Program stop (and pallet shuttle)

  Commands omitted for the time being:
	G10	  			Coordinate system data
	G14, G15		Spiral motion
	G28, G30		Return to home (requires parameters)
	G38.2 			Straight probe
	G40, G41, G42	Cutter radius compensation
	G43, G49		Tool length offsets
	G54 - G59.3		Select coordinate system (group 12)
	G81 - G89		Canned cycles
	G92	- G92.3		Coordinate system offsets
	G98, G99		Set canned cycle return level

	M6				Tool change
	M7, M8, M9		Coolant (group8)
	M48, M49		Enable/disable feed and speed override switches (group 9)
	
  Other commands and features intentionally not supported:
	- Multiple coordinate systems
	- Evaluation of expressions
	- Variables (Parameters)
	- Multiple home locations
	- Probing
	- Override control

  FYI: GCode modal groups (from NIST RS274NGC_3 Table 4)

   The modal groups for G codes are:
	group 1 = {G0, G1, G2, G3, G38.2, G80, G81, G82, G83, G84, G85, G86, G87, G88, G89} motion
	group 2 = {G17, G18, G19} plane selection 
	group 3 = {G90, G91} distance mode 
	group 5 = {G93, G94} feed rate mode
	group 6 = {G20, G21} units 
	group 7 = {G40, G41, G42} cutter radius compensation 
	group 8 = {G43, G49} tool length offset 
	group 10 = {G98, G99} return mode in canned cycles 
	group 12 = {G54, G55, G56, G57, G58, G59, G59.1, G59.2, G59.3} coordinate system selection 
	group 13 = {G61, G61.1, G64} path control mode

   The modal groups for M codes are:
	group 4 = {M0, M1, M2, M30, M60} stopping 
	group 6 = {M6} tool change 
	group 7 = {M3, M4, M5} spindle turning 
	group 8 = {M7, M8, M9} coolant (special case: M7 and M8 may be active at the same time) 
	group 9 = {M48, M49} enable/disable feed and speed override switches

   In addition to the above modal groups, there is a group for non-modal G codes:
	group 0 = {G4, G10, G28, G30, G53, G92, G92.1, G92.2, G92.3}	
*/
/*---- Gcode defaults ----

	The following configurations are supported to set the power-on defaults
	for the Gcode interpreter.

	$G20 $G21			units mode 		(inches, mm; respectively)
	$G17 $G18 $G19		arc plane		(XY, XZ, YZ)
	$G61 $G61.1 $G64	path control	(exact stop, exact path, continuous)
	$G90 $G91			distance mode	(absolute, relative)

	Entering "$G21" is not the same as entering "G21". Both will set the 
	gcode model to that state, but the $ command will also cause the 
	controller to default to the selected state on power-up or reset.
 */
/*---- Coordinate Systems ----

  TinyG runs a reduced functionality coordinate system from full NIST.
	NIST defines these commands that affect the coordinate system:

  	G10				Coordinate system origin setting
	G54 - G59.3		Select coordinate system (group 12)
	G92	- G92.3		Coordinate system offsets
	G43				Tool offset

	NIST also defines 9 coordinate systems (P1 - P9), plus the machine 
	coordinate system which also defines the machine zero. Our challenge 
	is that we don't know the machine zero unless we go through a 
	lengthy homing cycle - which is not even necessarily supported on 
	all machines. 

  So TinyG implements the following:

	On power up the Gcode interpreter is set to zero (X,Y,Z), which makes 
	the machine zero the current (random) position of the tool. A single 
	coordinate system is provided. G10, G43, and G54 - G59 are not 
	implemented.

	A reduced functionality G92 is available that does the following:
		G92 accepts axis-value pairs for all axes. The value will set that
		axis to the value. For example, to zero a robot you can enter:

			G92 x0 y0 z0 a0 b0 c0	(or any variant of this)

		One or more axes must be provided. Axes that are not provided are 
		not changed.

	A homing cycle is implemented. The homing cycle finds the home switch 
	for each confgured axis, then offsets that axis relative to the 
	location of the switch.
*/
/*---- Length Units ----

	TinyG runs natively in mm units - i.e. the internal system is all done
	in metric. It accepts G21 / G21 to change between inches and mm mode.
	When in inches mode (G20) all inputs are translated to mm internally -
	the machine operator does not see this. Also, all displays are performed
	in inches.

	Configuration settings are interpreted in the active units mode. 

	For example, if the machine is in inches mode (G20) and you set the max 
	feed rate using the command $xfr30 the feed rate will be set to 30 in/min.
	If the machine were in mm mode (G21) it would have been 30 mm/min. 
	It's a good idea to include a G20 or G21 in any script that changes 
	settings.

	The rotary axes (ABC) run natively in degrees mode. See notes on 
	rotary axes for lots more detail.
 */
/*---- Background on Feed and Seek Rates ----

	Feed rates (and seek rates) are done according to NIST RS274NGCv3 
	section 2.1.2.5, "Feed Rate", which reads:

   "A.	For motion involving one or more of the X, Y, and Z axes (with or 
		without simultaneous rotational axis motion), the feed rate means
		length units per minute along the programmed XYZ path, as if the 
		rotational axes were not moving.

	B.	For motion of one rotational axis with X, Y, and Z axes not moving, 
		the feed rate means degrees per minute rotation of the rotational axis.

	C.	For motion of two or three rotational axes with X, Y, and Z axes not 
		moving, the rate is applied as follows. Let dA, dB, and dC be the 
		angles in degrees through which the A, B, and C axes, respectively, 
		must move. Let D = sqrt(dA^2 + dB^2 + dC^2). Conceptually, D is a 
		measure of total angular motion, using the usual Euclidean metric. 

		Let T be the amount of time required to move through D degrees at 
		the current feed rate in degrees per minute. The rotational axes 
		should be moved in coordinated linear motion so that the elapsed 
		time from the start to the end of the motion is T plus any time 
		required for acceleration or deceleration."

	TinyG interprets this to mean that for a combined linear / rotational 
	move (A + 2nd paragraph of C) the feed rate is set as the linear feed 
	rate in prevailing linear units (mm or inch).

	For B and C moves (rotational only) the feed rate is in degrees per minute.

	The above behaviors apply to axes on STANDARD mode. Rotational axes 
	can behave differently in other modes.
 */
/*---- Starting, Stopping and Program State ----
  
  NIST RS274NGC_3 defines program run state semantics as so:

 	(Program) Start Program starts when if begins receiving blocks.
  					Corresponds to pressing the "cycle start" button.
					Program preserves state from previously run program, or
					defaults to persisted state (defaults, currently) upon power-on

 	(Program) Stop {M0} Program stops running temporarily (also M1)

 	(Program) End {M2} Program ends without the ability to resume
  					Also corresponds to trailing '%' sign in a g-code file

 	Reset 	  Resets machine parameters to defaults (NIST pg 38):
					- zero is reset
					- plane is set to xy
					- distance mode is set to absolute mode
					- feed rate mode is set to units per minute
					- spindle stopped
					- current motion mode set to G1
					- (others may be added)

*/
/*---- Configuration and Settings ----

  Background

  "Everything should be made as simple as possible, but not simpler." - Albert Einstein

  TinyG configuration is an attempt to adhere to Einstein's advice.
  The following assumptions are made:
	- TinyG can be used for cartesian or non-cartesian kinematics
	- TinyG supports 6 gcode axes (not 3, or 9)
	- Multiple TinyG boards can be networks to drive more than 4 motors
	- Various application-specific modes exist and will continue to be added (e.g. extruder mode)

  TinyG configuration is organized into the following groups of related settings:

	- Motor groups:		There are 4 motor groups, numbered 1.2,3,4 as labeled on the TinyG board
	- Axis groups:		There are 6 axis groups, one for each of X,Y,Z,A,B,C
	- General group:	A single group contains general machine and communication settings:
							Gcode defaults
							Machine and software parameters
							Communications settings

  The motor groups (technically "joints") contains parameters that don't change if the 
	machine is simple cartesian (e.g. XYZ table), complex cartesian - e.g. dual X axis, 
	or non-cartesian, e.g. scara or hexapod robots - to provide a serial and a parallel robot example.
  
  Motor settings include:
	- Motor mapping (to axis)
	- Step angle
	- Microsteps
	- Polarity
	- Power management mode
	- Travel per motor revolution 

  The axis groups contain parameters that describe "task space" - the XYZ space the robot is operating in.
  These include:
	- Axis mode
	- Maximum velocity (e.g. seek rate or traverse rate)
	- Maximum feed rate
	- Travel hard limit
	- Travel soft limit
	- Radius setting (rotational axes only)
	- Limit switch settings
	- Homing settings; homing enable and other homing parameters

  The general group does the following:

	- Gcode defaults are the initial values that machine will power up with, or revert to during
		reset or ESTOP. Setting these does NOT change the current machine mode, only the initial mode.
		(++++CONFIRM OR FIX)
	- Machine and software parameters include a variety of general machine settings
	- Communications settings configure the serial port behaviors


  Configuring TinyG

  Machine configuration is displayed and set by lines starting with '$'
  The $ must be the first character of the line.
  Each configuration parameter is a "setting". 
  Related settings are organized into settings "groups", such as general settings, an axis, or a motor. 
  Configuration is non-moded; that is, configuration lines and Gcode blocks can be freely intermixed without changing modes

  Displaying Settings

  The following commands will display settings groups.
 	$    Show general settings
  	$1   Show motor 1 settings (or whatever motor you want 1,2,3,4)
	$x   Show X axis settings (or whatever axis you want x,y,z,a,b,c)
	$m   Show all motor settings
	$n   Show all axis settings
	$$   Show all settings
	$h   Show this help screen

  Input is case insensitive.

  Updating Settings

  To update settings enter a token and a value:
	$ <token> <value>

  Tokens are a 2 letter mnemonic, with a motor number or axis prefix. General settings have no prefix.

  For example, type the follogin the to set the Y max feed rate to 800 mm/minute.
	$yfr800 
	<++++screencap this line>

  This value taken is echoed, or an error message if there was a problem

  Input is forgiving of caps, extra characters and spaces. 
	The following are all valid ways to set the step angle for motor 2 to 0.9 degrees per step
	$2sa0.9
	$2 sa 0.900
	$2SA=0.9
	$2sa=+0.9
	$2SA=.9

+++ Verify all the above
+++ See how hard it is to enter axes to MA as characters (probably pretty hard)

  Motor Settings

	$nMA	MAp motor to axis. As you might expect, mapping motor 1 to X will cause movement in X to move motor 1.
			Axes must be input as numbers, with X=0, Y=1, Z=2, A=3, B=4 and C=5

				$1ma0	maps motor 1 to the X axis
				$2ma0	maps motor 2 to the X axis
				$3ma1	maps motor 3 to the Y axis
				$4ma2	maps motor 4 to the Z axis

			The above configuration is a way to run a dual-X gantry such as the LumenLabs micRo v3.
			Movement in X will drive both motor1 and motor2. In the case of the micRo v3, all other
			motor settings for motors 1 and 2 should be identical.

	$nSA	Step Angle for the motor. This is often 1.8 degrees per step, but should reflect the motors in use.

				$1sa1.8	This is a typical value for most motors. You might also fin 0.9, 3.6, 7.5 or other values


	$nTR	Travel per Revolution. This is the amount of travel in mm, or inches for X, Y or Z axes. 
			The value will be interpreted and echoed in the prevailing units; G20 sets inches, G21 sets mm.
			This value is usually the result of the lead screw pitch. A 10 TPI leadscrew moves 0.100" / rev.
			Belt drives are (roughly) the circumference of the pulley.

			A, B and C axes are entered in degrees. This value will be 360 degrees for an axis that is not geared down.
			The value for a geared rotary axis is 360 divided by the gear ratio. 
			For example, a rotray table with a gear ratio of 90:1 will be 4. 

			Note that travel per revolution is a motor parameter, not an axis parameter. 
			Consider the case of a dual X gantry with lead screws of different pitch (how weird).
			The travel per revolution would be different for each motor.

	$nMI	MIcrosteps. The following values are supported:
				1 = no microsteps (whole steps)
				2 = half stepping
				4 = quarter stepping
				8 = eighth stepping

			Please consider that while microstepping level has an effect on motion smoothness, the
			quality of the pulse train delivered to the stepper drivers actually matters more. Also, 
			that the total power delivered to the motor (and hence torque) goes up as you approach 
			whole steps. Don't just assume that 1/8 microstepping is the right setting for your
			application. Try out different settings to balance smoothness and power. 
			You might be surprised.

	$nPW	PoWer mode. Set to one of the following:
				0 = Leave motor powered on when stopped
				1 = Turn motor power off when stopped

			Stepper motors actually consume maximum power when idle. They hold torque and get hot. 
			If you shut off power the motor has (almost) no holding torque.
			Some motor configurations are OK if you shut off the power on idle (like most leadscrew machines),
			others are not (some belt/pully configs and some non-cartesian robots)

  Axis Settings
 
	$xMO	Axis MOde sets the function of the axis. The following modes are supported for all axes.

				0 = Disable. All input to that axis will be ignored, and the axis will not move.

				1 = Standard. Linear axes move in length units. Rotary axes move in degrees.

				2 = Inhibited. Axis values are taken into account when planning moves, but the 
					axis will not move. Use this to perform a Z kill.

			Example, $xmo0 will disable the X axis; $amo1 sets the A axis to standard mode

			Rotary axes can have these additional modes.

				3 = Radius.mode. In radius mode the gcode values for that axis are interpreted 
					as linear units; either inches or mm depending on the prevailing G20/G21 setting. 
					The conversion of linear units to degrees is accomplished using the radius
					setting for that axis. Setting the radius to 1" means that the Gcode block 
					G0 A6.283 (inches) will make A perform one revolution (1" * 2 * pi).

					In radius mode all configuration is still done in degrees. All the radius
					does is convert the incoming gcode value internally to degrees.


				4 = Slave X mode - rotary axis slaved to movement in X dimension
				5 = Slave Y mode - rotary axis slaved to movement in Y dimension
				6 = Slave Z mode - rotary axis slaved to movement in Z dimension
				7 = Slave XY mode - rotary axis slaved to movement in XY plane
				8 = Slave XZ mode - rotary axis slaved to movement in XZ plane
				9 = Slave YZ mode - rotary axis slaved to movement in YZ plane
				10 = Slave XYZ mode - rotary axis slaved to movement in XYZ space

					Slave modes use the distance traveled in one or more linear dimensions
					as the linear input to the rotational axis. They ignore any value that 
					might have been (erroneously) provided to the slaved axis via a Gcode word.

					How does this work? The linear distance traveled in one, two or three 
					of the XYZ dimensions is computed. The distance is then applied as a 
					linear distance value for the rotational axis. The linear value is 
					converted to degrees using the radius setting - similarly to operation
					in Radius mode.

	$aRA	Radius value. The radius value is used by a rotational axis when in radius mode or 
			in a slaved mode. See Axis Mode for details.

	$xSR	Seek Rate (also known as maximum velocity). Sets the maximum velocity the axis can move
			during a traverse (G0). This is set in length units per minute for linear axes, degrees per
			minute for rotary axes.

				$xsr1200	sets X to 1200 mm/min - assuming G21 is active
				$zsr30.0	sets Z to 30 inches per minute - assuming G20 is active
				$asr3600	sets A to 10 revolutions per minute (360 * 10)

	$xFR	Maximum Feed Rate. Sets the maximum velocity the axis can move during a feed (G1, G2, G3).
			Units work similarly to seek rate. Feed rate should be less than seek rate.

			See Setting Feed and Seek Rates for more details.

	$xTH	Travel Hard limit. Defines the maximum extent of travel in that axis. This is used
			during homing.

	$xTS	Travel Soft limit. Defines the safe work envelope in that axis, which is something 
			less than the hard limit. If this value is non-zero it is used for This is used for 

	$xLI	LImit switch mode

	$xHE	Homing Enable

	$xHR	Homing Rate

	$xHC	Homing Close rate

	$xHO	Homing Offset

	$xHB	Homing Backoff

/*---- Setting Feed and Seek Rates ----

	Seek rates are the upper limit of the machine under minimal load.
	The maximum feed rates are typically less than seek rates. Set seek 
	rates before feed rates. The following example discusses setting 
	the seek rate ($xsr) to the maximum speed of reliable travel, or 
	the "top speed" of the machine. 

	A good seek rate will drive the motor reliably at high speed and allow
	for a little headroom where the motor is still running well. Attempting
	to set the seek rate too much above this speed should cause the motor to 
	stall.

	Notes: 
		Values in this example are in inches [and mm]. MM values may be 
		approximate but accurate enough for these purposes. 

		Settings strings in this example, such as $xsr show the x axis.
		Other axes are similar, such as $ysr, or $asr for Y and A axes.

	Make sure motor setting such as step angle ($xsa), microsteps ($xmi), 
	and polarity ($xpo) are correct for the motor and the setup. Make sure 
	the travel per revolution ($xtr) is set correctly for your machine.
	Typical values are $xsa = 1.8 degrees per step, $xmi = 8 microsteps,
	$xpo = 0 (not inverted), and $xtr = 0.100 as the reciprocal of lead 
	screw pitch, e.g. 1/(10 TPI). [or 2.54 in mm].

	Set an acceleration value ($jl) where you can audibly hear the motor 
	come up to speed. A value of 2,000,000 [50,000,000] is good. 
	Note: commas are accepted but ignored by config.

	Test seek rate with a G0, such as G0 X5 [G0 X100]. The motor should 
	accelerate, cruise at speed, then decelerate to a stop. The motor should 
	not stall or fail to start. Lower the seek rate if this is the case.

	If the motor hums but doesn't start it's probably not getting enough 
	current. Alternately, if the motor stops and starts; or stutters; 
	and the driver chips are excessively hot the motor is getting too much 
	current. See Setting Motor Current.

	If the the motor more or less works but seems to be dropping steps it 
	could be any of the mechanical system (too much friction), the current
	setting, or the seek rate being too high. Probably some combination of 
	all three. Experimentation is required. It's best to try to fix them in 
	that order.

	It's worth noting that the mechanics of the axes may not be identical, 
	and the achieveable seek rates may differ.

	Set feed rates ($xfr) similarly. These often require adjustment for a 
	given job or material as the cutting loads may vary. The seek rates 
	should not require job-by-job adjustment.

 */
/*---- Rotational Axis Settings and Modes ----

	Rotational Axis Settings

	The rotational axes (ABC) run natively in degrees mode. All gcode 
	values for the ABC axes are in degrees. The configuration settings 
	of the rotational axes are also all in degrees (with the exception 
	of the Radius setting as described below).

	Seek and feed rates are in degrees per minute and behave as per 
	RS274NGCv3 feed rate defintions.

	Travel per revolution means the number of degrees the machine moves per
	motor revolution - it expresses gearing. For example a rotary table has
	a 90:1 gear ratio. The travel per revolution should be set to 4. 
	(360 / 90).
	
	Travel hard and soft limits are in degrees. Most of the time rotational
	axes are "wrapped" axes that have no limits. In this case the limits 
	should be set to -1.

	All homing cycle values (rates and distances) are also in degrees,
	although the meanings may vary depening on homing modes. 


	Slaved Extruder Example

	Take the case of a stepper controlled extruder for 3d printing. The
	stepper motor is configured on the A axis. 

	The A axis max feed rate is initially set to a degrees per minute that 
	is somewhat lower than the stepper can deliver. 1000 steps per second 
	for a 1.8 degree stepper equals 108,000 degrees per second. If this 
	rate is faster than the extruder and/or stepper can handle it should 
	be lowered - as it is used to limit the maximum rate an extrusion 
	move can be executed. 

	The travel_per_revolution setting accounts for the gearing of the 
	stepper to the extrusion mechanism. Let's say the gearing is 50:1.
	Travel per revolution is set to 360/50 = 7.2 

	Once these 2 settings are established they need not be changed.

	The A axis radius is used to set the extrusion rate. This is 
	experimental will probably change depending on the part being built,
	and can change dynamically during a build by issuing a $araNNN command
	(or MXXX command once we get that linked).

	Now when there is movement in the XY plane the extruder will feed
	at a rate proportional to the movement. The extrusion rate will also 
	obey the same acceleration/deceleration as the extruder head. 
	Movement in Z will not affect the extrusion rate.

	So why is there a separate EXTRUDER mode? Extruder mode works as above,
	but additionally it only extrudes for G1, G2 and G3. It does not extrude
	during seeks (G0).

*/


*/
/**** DEVELOPMENT NOTES ****/

/*---- Notes on structure of this code ----

  The Gcode interpreter and lower layers are organized as so:

	gcode.c/.h
	canonical_machine.c/.h
	planner.c/.h
	move_buffer.c/.h
	stepper.c/.h

	gcode.c/.h is the gcode parser. It reads and executes gcode blocks. 
	Gcode is executed by calling the underlying canonical machine 
	functions in canonical_machine.c/.h. The parser is stateless and 
	starts "from scratch" for each new gcode block (some state is 
	retrieved from the gcode model kept by the canonical machine).

	canonical_machine.c/.h implements the NIST RS274NGC canonical 
	machining functions (more or less). Some functions have been added,
	some not implemented, and some of the calling conventions are 
	different. The canonical machine normalizes all coordinates and 
	parameters to internal representation, keeps the Gcode model state,
	and makes calls to the motion control layer for actual movement.

	The canonical machine is extendsible to handle canned cycles, like 
	homing cycles, tool changes, probe cycles, and other complex cycles 
	using motion primitives.(I'm not sure if this is exactly how Kramer 
	planned it - particularly when it comes to state management, but 
	it's how it's implemented).

	planner.c/.h does acceleration / deceleration management to plan and 
	execute motion primitives (moves) for the desired robot type. 
	Primitives include lines, arcs, dwells, stop/start. The planner 
	layer implements the actual robot kinematics. A cartesian robot 
	for X,Y,Z, A, B and C axes is supported. Other types of robot 
	kinematics would extend or replace this layer. 

	move_buffer.c/.h queues axis moves from the motion control layer for 
	the steppers (or other motor control layer). It also pre-computes the 
	queued moves for the motors so the motor interrupts can just load
	values without having computational load during line segment 
	interstitials.

	stepper.c/.h runs the stepper motors. An optimized DDA has been 
	implemented. (See later in this file or stepper.h)

	Stop, start and dwell are also handled here.

  	A note about efficiency: Having all these layers doesn't mean that 
	there are an excessive number of stack operations - just that things 
	are easier to maintain and visualize. Much of the code is run as 
	inlines and static scoped variables (i.e. not passed on the stack). 
	And even if there were a lot of function calls, most of the code  
	doesn't need optimization anyway (with the exception of the steppers
	and some of the communications drivers)
*/
/*---- Notes on the operation of the DDA ----
	Coordinated motion (line drawing) is performed using a classic 
	Bresenham DDA as per reprap and grbl. A number of additional steps 
	are taken to optimize interpolation and pulse train accuracy.

	- The DDA accepts and processes fractional motor steps. Steps are 
	  passed to the move queue as doubles, which do not need to be integer
	  values. The DDA implements fractional steps and interpolation by 
	  extending the counter range downward using the DDA_SUBSTEPS setting.

	- The DDA is not used as a 'ramp' for acceleration management. Accel
	  is computed as 3rd order (maximum jerk) equations that generate 
	  accel/decel segments to the DDA in much the same way arc drawing
	  is approximated. The DDA runs at a constant rate for each segment,
	  up to a maximum of 50 Khz step rate.

	- The DDA rate for a segment is set to an integer multiple of the 
	  step freqency of the fastest motor (major axis). This amount of 
	  overclocking is controlled by the DDA_OVERCLOCK value, typically 16x.
	  A minimum DDA rate is enforced that prevents overflowing the 16 bit 
	  DDA timer PERIOD value. The DDA timer always runs at 32 Mhz. The 
	  prescaler is not used. Various methods are used to keep the numbers 
	  in range for long lines. See _mq_set_f_dda() for details.

	- Pulse phasing is preserved between segments if possible. This makes
	  for smoother motion, particularly at very low speeds and short 
	  segment lengths (avoids pulse jitter). Phase continuity is achieved 
	  by simply not resetting the DDA counters across segments. In some 
	  cases the differences between timer values across segments are too 
	  large for this to work, and you risk motor stalls due to pulse 
	  starvation. These cases are detected and the counters are reset 
	  to prevent stalling.

	- Pulse phasing is also helped by minimizing the time spent loading 
	  the next move segment. To this end as much as possible about that 
	  move is pre-computed during the queuing phase. Also, all moves are 
	  loaded from the interrupt level, avoiding the need for mutual 
	  exclusion locking or volatiles (which slow things down).
 */

/* ---- Generalized Serial Handler / Parser (controller.c) ----

  Want to do the following things:

	- Be able to interpret (and mix) various types of inputs, including:
		- Control commands from stdio - e.g. ^c, ^q/^p, ^n/^o...
		- Configuration commands for various sub-systems
		- Gcode blocks
		- Arbitrary commands that bypass the Gcode layer
		- Multi-DOF protocols TBD 
	- Accept and mix inputs from multiple sources:
		- USB
		- RS-485
		- Arduino serial port (Aux)
		- strings in program memory
		- EEPROM data
		- SD card data

---- Design notes ----

  	- XIO line readers are the lowest level (above single character read)
		From serial inputs: read single characters to assemble a string
		From in-memory strings: read characters from a string in program memory
		Either mode: read string to next terminator and return NULL terminated string 
		Do not otherwise process or normalize the string

	- tg_parser is the top-level parser / dispatcher
		Examine the head of the string to determine how to dispatch
		Supported dispatches:
		- Gcode block
		- Gcode configuration line
		- Direct drive (motion control) command
		- Network command / config (not implemented)

	- Individual parsers/interpreters are called from tg_parser
		These can assume:
		- They will only receive a single line (multi-line inputs have been split)
		- Tyey perform line normalization required for that dispatch type
		- Can run the current command to completion before receiving another command

	- Flow control
		Flow control is provided by the called routine running to completion 
		without blocking. If blocking could occur (e.g. move buffer is full)
		the routine should return and provide a continuation in the main 
		controller loop. This necessitates some careful state handling.

---- How To Code Continuations ----

	Continuations are used to manage points where the application would 
	ordinarily block. Call it application managed threading by way of an 
	inverted control loop. By coding using continuations the application 
	does not need an RTOS and is extremely responsive (there are no "ticks")

	Rules for writing a continuation task:
	  - A continuation is a pair of routines. The first is the main routine,
		the second the continuation. See mc_line() and mc_line_continue().

	  - The main routine is called first and should never block. It may 
	    have function arguments. It performs all initial actions and sets 
		up a static structure to hold data that is needed by the 
		continuation routine. The main routine should end by returning a 
		uint8_t TG_OK or an error code.

	  - The continuation task is a callback that is permanemtly registered 
	  	at the right level of the blocking heirarchy in the tg_controller 
		loop; where it will be called repeatedly by the controller. The 
		continuation cannot have input args - all necessary data must be 
		available in the static struct (or by some other means).

	  - Continuations should be coded as state machines. See the homing 
	  	cycle as an example. Common states used by most machines include: 
		OFF, NEW, or RUNNING. OFF means take no action (return NOOP). 
		The state on initial entry after the main routine should be NEW.
		RUNNING is a catch-all for simple routines. More complex state
		machines may have numerous other states.

	  - The continuation must return the following codes and may return 
	  	additional codes to indicate various exception conditions:

	 	TG_NOOP: No operation ocurred. This is the usual return from an 
			OFF state. All continuations must be callable with no effect 
			when they are OFF (as they are called repeatedly by the 
			controller whether or not they are active).

		TG_EAGAIN: The continuation is blocked or still processing. This one 
			is really important. As long as the continuation still has work 
			to do it must return TG_EAGAIN. Returning eagain causes the 
			tg_controller dispatcher to restart the controller loop from 
			the beginning, skipping all later routines. This enables 
			heirarchical blocking to be performed. The later routines will 
			not be run until the blocking conditions at the lower-level are
			removed.

		TG_OK; The continuation task  has just is completed - i.e. it has 
			just transitioned to OFF. TG_OK should only be returned only once. 
			The next state will be OFF, which will return NOOP.

		TG_COMPLETE: This additional state is used for nesting state 
			machines such as the homing cycle or other cycles (see the 
			homing cycle as an example of a nested state machine). 
			The lower-level routines called by a parent will return 
			TG_EAGAIN until they are done, then they return TG_OK. 
			The return codes from the continuation should be trapped by 
			a wrapper routine that manages the parent and child returns 
			When the parent REALLY wants to return it sends its wrapper 
			TG_COMPLETE, which is translated to an OK for the parent routine.
*/

