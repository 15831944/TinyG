
/**** GCODE NOTES ****/

/*---- Notes on structure of this code ----

  The Gcode interpreter and lower layers are organized as so:

	gcode.c/.h
	canonical_machine.c/.h
	planner.c/.h
	move_buffer.c/.h
	stepper.c/.h

	gcode.c/.h is the gcode parser. It reads and executes gcode blocks. 
	Gcode is executed by calling the underlying canonical machine 
	functions in canonical_machine.c/.h. The parser is stateless and 
	starts "from scratch" for each new gcode block (some state is 
	retrieved from the gcode model kept by the canonical machine).

	canonical_machine.c/.h implements the NIST RS274NGC canonical 
	machining functions (more or less). Some functions have been added,
	some not implemented, and some of the calling conventions are 
	different. The canonical machine normalizes all coordinates and 
	parameters to internal representation, keeps the Gcode model state,
	and makes calls to the motion control layer for actual movement.

	The canonical machine is extendsible to handle canned cycles, like 
	homing cycles, tool changes, probe cycles, and other complex cycles 
	using motion primitives.(I'm not sure if this is exactly how Kramer 
	planned it - particularly when it comes to state management, but 
	it's how it's implemented).

	planner.c/.h does acceleration / deceleration management to plan and 
	execute motion primitives (moves) for the desired robot type. 
	Primitives include lines, arcs, dwells, stop/start. The planner 
	layer implements the actual robot kinematics. A cartesian robot 
	for X,Y,Z, A, B and C axes is supported. Other types of robot 
	kinematics would extend or replace this layer. 

	move_buffer.c/.h queues axis moves from the motion control layer for 
	the steppers (or other motor control layer). It also pre-computes the 
	queued moves for the motors so the motor interrupts can just load
	values without having computational load during line segment 
	interstitials.

	stepper.c/.h runs the stepper motors. An optimized DDA has been 
	implemented. (See later in this file or stepper.h)

	Stop, start and dwell are also handled here.

  	A note about efficiency: Having all these layers doesn't mean that 
	there are an excessive number of stack operations - just that things 
	are easier to maintain and visualize. Much of the code is run as 
	inlines and static scoped variables (i.e. not passed on the stack). 
	And even if there were a lot of function calls, most of the code  
	doesn't need optimization anyway (with the exception of the steppers
	and some of the communications drivers)
*/

/*---- Supported commands ----
 	G0				Rapid linear motion
	G1				Linear motion at feed rate
	G2, G3			Clockwise / counterclockwise arc at feed rate
	G4				Dwell
	G17, G18, G19	Select plane: XY plane {G17}, XZ plane {G18}, YZ plane {G19}
	G20, G21		Length units: inches {G20}, millimeters {G21}
	G53				Move in absolute coordinates
	G80				Cancel motion mode
	G90, G91		Set distance mode; absolute {G90}, incremental {G91}
	G92				Coordinate System Offsets - limited support provided
	G93, G94		Set feed rate mode: inverse time mode {G93}, 
										units per minute mode {G94}
	M0				Program stop
	M1				Optional program stop
	M2				Program end
	M3, M4			Turn spindle clockwise / counterclockwise
	M5				Stop spindle turning
	M30				Program end (pallet shuttle and reset)
	M60				Program stop (and pallet shuttle)

  Commands omitted for the time being:
	G10	  			Coordinate system data
	G14, G15		Spiral motion
	G28, G30		Return to home (requires parameters)
	G38.2 			Straight probe
	G40, G41, G42	Cutter radius compensation
	G43, G49		Tool length offsets
	G54 - G59.3		Select coordinate system (group 12)
	G61, G61.1, G64 Set path control mode (group 13)
	G81 - G89		Canned cycles
	G92	- G92.3		Coordinate system offsets
	G98, G99		Set canned cycle return level

	M6				Tool change
	M7, M8, M9		Coolant (group8)
	M48, M49		Enable/disable feed and speed override switches (group 9)
	
  Other commands and features intentionally not supported:
	- Multiple coordinate systems
	- Evaluation of expressions
	- Variables (Parameters)
	- Multiple home locations
	- Probing
	- Override control

  FYI: GCode modal groups (from NIST RS274NGC_3 Table 4)

   The modal groups for G codes are:
	group 1 = {G0, G1, G2, G3, G38.2, G80, G81, G82, G83, G84, G85, G86, G87, G88, G89} motion
	group 2 = {G17, G18, G19} plane selection 
	group 3 = {G90, G91} distance mode 
	group 5 = {G93, G94} feed rate mode
	group 6 = {G20, G21} units 
	group 7 = {G40, G41, G42} cutter radius compensation 
	group 8 = {G43, G49} tool length offset 
	group 10 = {G98, G99} return mode in canned cycles 
	group 12 = {G54, G55, G56, G57, G58, G59, G59.1, G59.2, G59.3} coordinate system selection 
	group 13 = {G61, G61.1, G64} path control mode

   The modal groups for M codes are:
	group 4 = {M0, M1, M2, M30, M60} stopping 
	group 6 = {M6} tool change 
	group 7 = {M3, M4, M5} spindle turning 
	group 8 = {M7, M8, M9} coolant (special case: M7 and M8 may be active at the same time) 
	group 9 = {M48, M49} enable/disable feed and speed override switches

   In addition to the above modal groups, there is a group for non-modal G codes:
	group 0 = {G4, G10, G28, G30, G53, G92, G92.1, G92.2, G92.3}	
*/
/*---- Coordinate system notes ----

  TinyG runs a reduced functionality coordinate system from full NIST.
	NIST defines these commands that affect the coordinate system:

  	G10				Coordinate system origin setting
	G54 - G59.3		Select coordinate system (group 12)
	G92	- G92.3		Coordinate system offsets
	G43				Tool offset

	NIST also defines 9 coordinate systems (P1 - P9), plus the machine 
	coordinate system which also defines the machine zero. Our challenge 
	is that we don't know the machine zero unless we go through a 
	lengthy homing cycle - which is not even necessarily supported on 
	all machines. 

  So TinyG implements the foloowing:

	On power up the Gcode interpreter is set to zero (X,Y,Z), which makes 
	the machine zero the current (random) position of the tool. A single 
	coordinate system is provided. G10, G43, and G54 - G59 are not 
	implemented.

	A reduced functionality G92 is available that does the following:
		G92 accepts axis-value pairs for all axes. The value will set that
		axis to the value. For example, to zero a robot you can enter:

			G92 x0 y0 z0 a0 b0 c0	(or any variant of this)

		One or more axes must be provided. Axes that are not provided are 
		not changed.

	A homing cycle is implemented. The homing cycle finds the minimum 
	limit switch for each confgured axis, then offsets that axis relative 
	to the location of the limit switch.

*/
/*---- Notes on rotary axes, modes and feedrates ----

  Rotary Axes
	All three rotary axes are implemented A,B and C.
	Feedrate may be degrees/min , mm/min, or inches/min depending on mode
	Mixing linear and rotary motion in a coordinated move gets complicated
	According to NIST:
	  If the move is linear only (XYZ) feedrate is interpreted as in/min or mm/min
	  If the move is rotary only (A) feedrate is interpreted as degrees/min
	  If the move is mixed the move is interpreted as a helix 

  Degrees mode		
	NIST RS274NGC specifies rotary axes in degrees per minute,	
	So degrees mode is the default mode for rotary axes	
	In degrees mode Travel per Revolution = degrees per revolution	
	e.g. Set Travel per Revolution to 360 or whatever the axis is geared 
		 down to (like a rotary table)
		
  Distance mode		
	In distance mode rotary axes are specified in distance units per minute
		representing distance traveled at the surface of the axis or part	
	In distance mode the axis "scaling_factor" parameter is used to translate 
		degrees to distance traveled	
	The scaling factor is the degrees of revolution per surface-unit distance - 
		the formula is: 360 / circumference of the axis or part	
	e.g. A 1" radius work piece will travel 6.2831" per revolution. 
		The scaling factor would be 360/6.2831 or 57.295 degrees per inch
		(1 radian, not uncoincidentally) 
		
  Rotary Slave modes		
	These modes move the rotary axis in proportion to the linear movement 
	of any of the following:	
	X	proportional to travel in the X axis
	Y	y axis
	Z	z axis
	XY	proportional to travel in the XY plane
	YZ	YZ plane
	XZ	XZ plane
	XYZ	proportional to travel in XYZ

	In slave mode scaling_factor translates from linear distance to degrees
	 - the formula is: 360 / distance traveled	
	e.g. A stepping extruder is slaved to the XY plane. To extrude at a 
		 rate of 1/2 revolution per cm traveled set scaling factor to 18
		 	scaling factor = 360 / 200 mm
		 	scaling factor = 18
*/

 */
/*---- Notes on Starting, Stopping and program state ----
  
  NIST RS274NGC_3 defines program run state semantics as so:

 	(Program) Start Program starts when if begins receiving blocks.
  					Corresponds to pressing the "cycle start" button.
					Program preserves state from previously run program, or
					defaults to persisted state (defaults, currently) upon power-on

 	(Program) Stop {M0} Program stops running temporarily (also M1)

 	(Program) End {M2} Program ends without the ability to resume
  					Also corresponds to trailing '%' sign in a g-code file

 	Reset 	  Resets machine parameters to defaults (NIST pg 38):
					- zero is reset
					- plane is set to xy
					- distance mode is set to absolute mode
					- feed rate mode is set to units per minute
					- spindle stopped
					- current motion mode set to G1
					- (others may be added)

  We define mappings as so:

  	^c	End and Reset
	^x	End and Reset
	^s	Stop
	^q	Start (resume)
	^z	Set coordinate system P1 origin to current tool position
*/
/* 
 *	Coordinated motion (line drawing) is performed using a classic 
 *	Bresenham DDA as per reprap and grbl. A number of additional steps 
 *	are taken to optimize interpolation and pulse train accuracy.
 *
 *	- The DDA accepts and processes fractional motor steps. Steps are 
 *	  passed to the move queue as doubles, which do not need to be integer
 *	  values. The DDA implements fractional steps and interpolation by 
 *	  extending the counter range downward using the DDA_SUBSTEPS setting. 
 *
 *	- The DDA is not used as a 'ramp' for acceleration management. Accel
 *	  is computed as 3rd order (maximum jerk) equations that generate 
 *	  accel/decel segments to the DDA in much the same way arc drawing
 *	  is approximated. The DDA runs at a constant rate for each segment,
 *	  up to a maximum of 50 Khz step rate.
 *
 *	- The DDA rate for a segment is set to an integer multiple of the 
 *	  step freqency of the fastest motor (major axis). This amount of 
 *	  overclocking is controlled by the DDA_OVERCLOCK value, typically 16x.
 *	  A minimum DDA rate is enforced that prevents overflowing the 16 bit 
 *	  DDA timer PERIOD value. The DDA timer always runs at 32 Mhz. The 
 *	  prescaler is not used. Various methods are used to keep the numbers 
 *	  in range for long lines. See _mq_set_f_dda() for details.
 *
 *	- Pulse phasing is preserved between segments if possible. This makes
 *	  for smoother motion, particularly at very low speeds and short 
 *	  segment lengths (avoids pulse jitter). Phase continuity is achieved 
 *	  by simply not resetting the DDA counters across segments. In some 
 *	  cases the differences between timer values across segments are too 
 *	  large for this to work, and you risk motor stalls due to pulse 
 *	  starvation. These cases are detected and the counters are reset 
 *	  to prevent stalling.
 *
 *  - Pulse phasing is also helped by minimizing the time spent loading 
 *	  the next move segment. To this end as much as possible about that 
 *	  move is pre-computed during the queuing phase. Also, all moves are 
 *	  loaded from the interrupt level, avoiding the need for mutual 
 *	  exclusion locking or volatiles (which slow things down).
 */
