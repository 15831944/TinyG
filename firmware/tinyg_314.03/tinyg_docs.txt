
/**** GCODE NOTES ****/

/*---- Notes on structure of this code ----

  The Gcode interpreter and lower layers are organized as so:

	gcode.c/.h
	canonical_machine.c/.h
	planner.c/.h
	move_buffer.c/.h
	stepper.c/.h

	gcode.c/.h is the gcode parser. It reads and executes gcode blocks. 
	Gcode is executed by calling the underlying canonical machine 
	functions in canonical_machine.c/.h. The parser is stateless and 
	starts "from scratch" for each new gcode block (some state is 
	retrieved from the gcode model kept by the canonical machine).

	canonical_machine.c/.h implements the NIST RS274NGC canonical 
	machining functions (more or less). Some functions have been added,
	some not implemented, and some of the calling conventions are 
	different. The canonical machine normalizes all coordinates and 
	parameters to internal representation, keeps the Gcode model state,
	and makes calls to the motion control layer for actual movement.

	The canonical machine is extendsible to handle canned cycles, like 
	homing cycles, tool changes, probe cycles, and other complex cycles 
	using motion primitives.(I'm not sure if this is exactly how Kramer 
	planned it - particularly when it comes to state management, but 
	it's how it's implemented).

	planner.c/.h does acceleration / deceleration management to plan and 
	execute motion primitives (moves) for the desired robot type. 
	Primitives include lines, arcs, dwells, stop/start. The planner 
	layer implements the actual robot kinematics. A cartesian robot 
	for X,Y,Z, A, B and C axes is supported. Other types of robot 
	kinematics would extend or replace this layer. 

	move_buffer.c/.h queues axis moves from the motion control layer for 
	the steppers (or other motor control layer). It also pre-computes the 
	queued moves for the motors so the motor interrupts can just load
	values without having computational load during line segment 
	interstitials.

	stepper.c/.h runs the stepper motors. An optimized DDA has been 
	implemented. (See later in this file or stepper.h)

	Stop, start and dwell are also handled here.

  	A note about efficiency: Having all these layers doesn't mean that 
	there are an excessive number of stack operations - just that things 
	are easier to maintain and visualize. Much of the code is run as 
	inlines and static scoped variables (i.e. not passed on the stack). 
	And even if there were a lot of function calls, most of the code  
	doesn't need optimization anyway (with the exception of the steppers
	and some of the communications drivers)
*/
/*---- Supported commands ----
 	G0				Rapid linear motion
	G1				Linear motion at feed rate
	G2, G3			Clockwise / counterclockwise arc at feed rate
	G4				Dwell
	G17, G18, G19	Select plane: XY plane {G17}, XZ plane {G18}, YZ plane {G19}
	G20, G21		Length units: inches {G20}, millimeters {G21}
	G53				Move in absolute coordinates
	G61, G61.1, G64 Set path control mode (group 13)
	G80				Cancel motion mode
	G90, G91		Set distance mode; absolute {G90}, incremental {G91}
	G92				Coordinate System Offsets - limited support provided
	G93, G94		Set feed rate mode: inverse time mode {G93}, 
										units per minute mode {G94}
	M0				Program stop
	M1				Optional program stop
	M2				Program end
	M3, M4			Turn spindle clockwise / counterclockwise
	M5				Stop spindle turning
	M30				Program end (pallet shuttle and reset)
	M60				Program stop (and pallet shuttle)

  Commands omitted for the time being:
	G10	  			Coordinate system data
	G14, G15		Spiral motion
	G28, G30		Return to home (requires parameters)
	G38.2 			Straight probe
	G40, G41, G42	Cutter radius compensation
	G43, G49		Tool length offsets
	G54 - G59.3		Select coordinate system (group 12)
	G81 - G89		Canned cycles
	G92	- G92.3		Coordinate system offsets
	G98, G99		Set canned cycle return level

	M6				Tool change
	M7, M8, M9		Coolant (group8)
	M48, M49		Enable/disable feed and speed override switches (group 9)
	
  Other commands and features intentionally not supported:
	- Multiple coordinate systems
	- Evaluation of expressions
	- Variables (Parameters)
	- Multiple home locations
	- Probing
	- Override control

  FYI: GCode modal groups (from NIST RS274NGC_3 Table 4)

   The modal groups for G codes are:
	group 1 = {G0, G1, G2, G3, G38.2, G80, G81, G82, G83, G84, G85, G86, G87, G88, G89} motion
	group 2 = {G17, G18, G19} plane selection 
	group 3 = {G90, G91} distance mode 
	group 5 = {G93, G94} feed rate mode
	group 6 = {G20, G21} units 
	group 7 = {G40, G41, G42} cutter radius compensation 
	group 8 = {G43, G49} tool length offset 
	group 10 = {G98, G99} return mode in canned cycles 
	group 12 = {G54, G55, G56, G57, G58, G59, G59.1, G59.2, G59.3} coordinate system selection 
	group 13 = {G61, G61.1, G64} path control mode

   The modal groups for M codes are:
	group 4 = {M0, M1, M2, M30, M60} stopping 
	group 6 = {M6} tool change 
	group 7 = {M3, M4, M5} spindle turning 
	group 8 = {M7, M8, M9} coolant (special case: M7 and M8 may be active at the same time) 
	group 9 = {M48, M49} enable/disable feed and speed override switches

   In addition to the above modal groups, there is a group for non-modal G codes:
	group 0 = {G4, G10, G28, G30, G53, G92, G92.1, G92.2, G92.3}	
*/
/*---- Notes on Gcode defaults ----

	The following configurations are supported to set the power-on defaults
	for the Gcode interpreter.

	$G20 $G21			units mode 		(inches, mm; respectively)
	$G17 $G18 $G19		arc plane		(XY, XZ, YZ)
	$G61 $G61.1 $G64	path control	(exact stop, exact path, continuous)
	$G90 $G91			distance mode	(absolute, relative)

	Entering "$G21" is not the same as entering "G21". Both will set the 
	gcode model to that state, but the $ command will also cause the 
	controller to default to the selected state on power-up or reset.
 */
/*---- Coordinate system notes ----

  TinyG runs a reduced functionality coordinate system from full NIST.
	NIST defines these commands that affect the coordinate system:

  	G10				Coordinate system origin setting
	G54 - G59.3		Select coordinate system (group 12)
	G92	- G92.3		Coordinate system offsets
	G43				Tool offset

	NIST also defines 9 coordinate systems (P1 - P9), plus the machine 
	coordinate system which also defines the machine zero. Our challenge 
	is that we don't know the machine zero unless we go through a 
	lengthy homing cycle - which is not even necessarily supported on 
	all machines. 

  So TinyG implements the following:

	On power up the Gcode interpreter is set to zero (X,Y,Z), which makes 
	the machine zero the current (random) position of the tool. A single 
	coordinate system is provided. G10, G43, and G54 - G59 are not 
	implemented.

	A reduced functionality G92 is available that does the following:
		G92 accepts axis-value pairs for all axes. The value will set that
		axis to the value. For example, to zero a robot you can enter:

			G92 x0 y0 z0 a0 b0 c0	(or any variant of this)

		One or more axes must be provided. Axes that are not provided are 
		not changed.

	A homing cycle is implemented. The homing cycle finds the home switch 
	for each confgured axis, then offsets that axis relative to the 
	location of the switch.
*/
/*---- Notes on units ----

	TinyG runs natively in mm units - i.e. the internal system is all done
	in metric. It accepts G21 / G21 to change between inches and mm mode.
	When in inches mode (G20) all inputs are translated to mm internally -
	the machine operator does not see this. Also, all displays are performed
	in inches.

	Configuration settings are interpreted in the active units mode. 

	For example, if the machine is in inches mode (G20) and you set the max 
	feed rate using the command $xfr30 the feed rate will be set to 30 in/min.
	If the machine were in mm mode (G21) it would have been 30 mm/min. 
	It's a good idea to include a G20 or G21 in any script that changes 
	settings.

	The rotary axes (ABC) run natively in degrees mode. See notes on 
	rotary axes for lots more detail.
 */
/*---- Notes on Feed and Seek Rates ----

	Feed rates (and seek rates) are done according to NIST RS274NGCv3 
	section 2.1.2.5, "Feed Rate", which reads:

   "A.	For motion involving one or more of the X, Y, and Z axes (with or 
		without simultaneous rotational axis motion), the feed rate means
		length units per minute along the programmed XYZ path, as if the 
		rotational axes were not moving.

	B.	For motion of one rotational axis with X, Y, and Z axes not moving, 
		the feed rate means degrees per minute rotation of the rotational axis.

	C.	For motion of two or three rotational axes with X, Y, and Z axes not 
		moving, the rate is applied as follows. Let dA, dB, and dC be the 
		angles in degrees through which the A, B, and C axes, respectively, 
		must move. Let D = sqrt(dA^2 + dB^2 + dC^2). Conceptually, D is a 
		measure of total angular motion, using the usual Euclidean metric. 

		Let T be the amount of time required to move through D degrees at 
		the current feed rate in degrees per minute. The rotational axes 
		should be moved in coordinated linear motion so that the elapsed 
		time from the start to the end of the motion is T plus any time 
		required for acceleration or deceleration."

	TinyG interprets this to mean that for a combined linear / rotational 
	move (A + 2nd paragraph of C) the feed rate is set as the linear feed 
	rate in prevailing linear units (mm or inch).

	For B and C moves (rotational only) the feed rate is in degrees per minute.

	The above behaviors apply to axes on STANDARD mode. Rotational axes 
	can behave differently in other modes.
 */
/*---- Notes on Setting Feed and Seek Rates ----

	Seek rates are the upper limit of the machine under minimal load.
	The maximum feed rates are typically less than seek rates. Set seek 
	rates before feed rates. The following example discusses setting 
	the seek rate ($xsr) to the maximum speed of reliable travel, or 
	the "top speed" of the machine. 

	A good seek rate will drive the motor reliably at high speed and allow
	for a little headroom where the motor is still running well. Attempting
	to set the seek rate too much above this speed should cause the motor to 
	stall.

	Notes: 
		Values in this example are in inches [and mm]. MM values may be 
		approximate but accurate enough for these purposes. 

		Settings strings in this example, such as $xsr show the x axis.
		Other axes are similar, such as $ysr, or $asr for Y and A axes.

	Make sure motor setting such as step angle ($xsa), microsteps ($xmi), 
	and polarity ($xpo) are correct for the motor and the setup. Make sure 
	the travel per revolution ($xtr) is set correctly for your machine.
	Typical values are $xsa = 1.8 degrees per step, $xmi = 8 microsteps,
	$xpo = 0 (not inverted), and $xtr = 0.100 as the reciprocal of lead 
	screw pitch, e.g. 1/(10 TPI). [or 2.54 in mm].

	Set an acceleration value ($jl) where you can audibly hear the motor 
	come up to speed. A value of 2,000,000 [50,000,000] is good. 
	Note: commas are accepted but ignored by config.

	Test seek rate with a G0, such as G0 X5 [G0 X100]. The motor should 
	accelerate, cruise at speed, then decelerate to a stop. The motor should 
	not stall or fail to start. Lower the seek rate if this is the case.

	If the motor hums but doesn't start it's probably not getting enough 
	current. Alternately, if the motor stops and starts; or stutters; 
	and the driver chips are excessively hot the motor is getting too much 
	current. See Setting Motor Current.

	If the the motor more or less works but seems to be dropping steps it 
	could be any of the mechanical system (too much friction), the current
	setting, or the seek rate being too high. Probably some combination of 
	all three. Experimentation is required. It's best to try to fix them in 
	that order.

	It's worth noting that the mechanics of the axes may not be identical, 
	and the achieveable seek rates may differ.

	Set feed rates ($xfr) similarly. These often require adjustment for a 
	given job or material as the cutting loads may vary. The seek rates 
	should not require job-by-job adjustment.

 */
/*---- Notes on Rotational Axis Settings and Modes ----

	Rotational Axis Settings

	The rotational axes (ABC) run natively in degrees mode. All gcode 
	values for the ABC axes are in degrees. The configuration settings 
	of the rotational axes are also all in degrees (with the exception 
	of the Radius setting as described below).

	Seek and feed rates are in degrees per minute and behave as per 
	RS274NGCv3 feed rate defintions.

	Travel per revolution means the number of degrees the machine moves per
	motor revolution - it expresses gearing. For example a rotary table has
	a 90:1 gear ratio. The travel per revolution should be set to 4. 
	(360 / 90).
	
	Travel hard and soft limits are in degrees. Most of the time rotational
	axes are "wrapped" axes that have no limits. In this case the limits 
	should be set to -1.

	All homing cycle values (rates and distances) are also in degrees,
	although the meanings may vary depening on homing modes. 


	Rotational Axis Modes

	The default mode for a rotary axis is STANDARD. Gcode values are 
	interpreted in degrees as discussed earlier. 

	Radius Mode

	In RADIUS mode the gcode values for that axis are interpreted as linear 
	units; either inches or mm depending on the prevailing G20/G21 setting. 
	The conversion of linear units to degrees is accomplished using the radius
	setting for that axis. Setting the radius to 1" means that the Gcode block 
	G0 A6.283 (inches) will make A perform one revolution (1" * 2 * pi).

	In radius mode all configuration is still done in degrees. All the radius
	does is convert the incoming gcode value internally to degrees.

	In this mode the max feed rate is still indicated in degrees per minute.
	Convert to feet per minute at the surface of the rotation axis by:
		SFM = feed rate * radius * 0.5236   
		where feed rate is in degrees/min and 
		radius is in inches.

	Rotational Slave Modes

	Slave modes use the distance traveled in one ore more linear dimensions
	as the linear input to the rotational axis. They ignore any value that 
	might have been erroneously provided to the slaved axis via a Gcode word.

	How does this work? The linear distance traveled in one, two or three 
	of the XYZ dimensions is computed. The distance is then applied as a 
	linear distance value for the rotational axis. The linear value is 
	converted to degrees using the radius setting - similarly to operation
	in Radius mode.

 	Rotational slave modes are:		
		X	uses distance traveled in X
		Y	uses distance traveled in Y
		Z	uses distance traveled in Z
		XY	uses distance traveled in the XY plane
		YZ	uses distance traveled in the XZ plane
		XZ	uses distance traveled in the XZ plane
		XYZ	uses distance traveled in XYZ

	Slaved Extruder Example

	Take the case of a stepper controlled extruder for 3d printing. The
	stepper motor is configured on the A axis. 

	The A axis max feed rate is initially set to a degrees per minute that 
	is somewhat lower than the stepper can deliver. 1000 steps per second 
	for a 1.8 degree stepper equals 108,000 degrees per second. If this 
	rate is faster than the extruder and/or stepper can handle it should 
	be lowered - as it is used to limit the maximum rate an extrusion 
	move can be executed. 

	The travel_per_revolution setting accounts for the gearing of the 
	stepper to the extrusion mechanism. Let's say the gearing is 50:1.
	Travel per revolution is set to 360/50 = 7.2 

	Once these 2 settings are established they need not be changed.

	The A axis radius is used to set the extrusion rate. This is 
	experimental will probably change depending on the part being built,
	and can change dynamically during a build by issuing a $araNNN command
	(or MXXX command once we get that linked).

	Now when there is movement in the XY plane the extruder will feed
	at a rate proportional to the movement. The extrusion rate will also 
	obey the same acceleration/deceleration as the extruder head. 
	Movement in Z will not affect the extrusion rate.

	So why is there a separate EXTRUDER mode? Extruder mode works as above,
	but additionally it only extrudes for G1, G2 and G3. It does not extrude
	during seeks (G0).

*/
/*---- Notes on Starting, Stopping and program state ----
  
  NIST RS274NGC_3 defines program run state semantics as so:

 	(Program) Start Program starts when if begins receiving blocks.
  					Corresponds to pressing the "cycle start" button.
					Program preserves state from previously run program, or
					defaults to persisted state (defaults, currently) upon power-on

 	(Program) Stop {M0} Program stops running temporarily (also M1)

 	(Program) End {M2} Program ends without the ability to resume
  					Also corresponds to trailing '%' sign in a g-code file

 	Reset 	  Resets machine parameters to defaults (NIST pg 38):
					- zero is reset
					- plane is set to xy
					- distance mode is set to absolute mode
					- feed rate mode is set to units per minute
					- spindle stopped
					- current motion mode set to G1
					- (others may be added)

  We define mappings as so:

  	^c	End and Reset
	^x	End and Reset
	^s	Stop
	^q	Start (resume)
	^z	Set coordinate system P1 origin to current tool position
*/
/*---- Notes on the operation of the DDA ----
	Coordinated motion (line drawing) is performed using a classic 
	Bresenham DDA as per reprap and grbl. A number of additional steps 
	are taken to optimize interpolation and pulse train accuracy.

	- The DDA accepts and processes fractional motor steps. Steps are 
	  passed to the move queue as doubles, which do not need to be integer
	  values. The DDA implements fractional steps and interpolation by 
	  extending the counter range downward using the DDA_SUBSTEPS setting.

	- The DDA is not used as a 'ramp' for acceleration management. Accel
	  is computed as 3rd order (maximum jerk) equations that generate 
	  accel/decel segments to the DDA in much the same way arc drawing
	  is approximated. The DDA runs at a constant rate for each segment,
	  up to a maximum of 50 Khz step rate.

	- The DDA rate for a segment is set to an integer multiple of the 
	  step freqency of the fastest motor (major axis). This amount of 
	  overclocking is controlled by the DDA_OVERCLOCK value, typically 16x.
	  A minimum DDA rate is enforced that prevents overflowing the 16 bit 
	  DDA timer PERIOD value. The DDA timer always runs at 32 Mhz. The 
	  prescaler is not used. Various methods are used to keep the numbers 
	  in range for long lines. See _mq_set_f_dda() for details.

	- Pulse phasing is preserved between segments if possible. This makes
	  for smoother motion, particularly at very low speeds and short 
	  segment lengths (avoids pulse jitter). Phase continuity is achieved 
	  by simply not resetting the DDA counters across segments. In some 
	  cases the differences between timer values across segments are too 
	  large for this to work, and you risk motor stalls due to pulse 
	  starvation. These cases are detected and the counters are reset 
	  to prevent stalling.

	- Pulse phasing is also helped by minimizing the time spent loading 
	  the next move segment. To this end as much as possible about that 
	  move is pre-computed during the queuing phase. Also, all moves are 
	  loaded from the interrupt level, avoiding the need for mutual 
	  exclusion locking or volatiles (which slow things down).
 */

