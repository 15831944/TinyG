
TinyG_001.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003ce4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000002a  00802000  00003ce4  00003d78  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000512  0080202a  0080202a  00003da2  2**0
                  ALLOC
  3 .debug_aranges 000001a0  00000000  00000000  00003da2  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 0000075c  00000000  00000000  00003f42  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000036bb  00000000  00000000  0000469e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001081  00000000  00000000  00007d59  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00002469  00000000  00000000  00008dda  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000570  00000000  00000000  0000b244  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000128f  00000000  00000000  0000b7b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00001818  00000000  00000000  0000ca43  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000030  00000000  00000000  0000e25b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3a 02 	jmp	0x474	; 0x474 <__ctors_end>
       4:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
       8:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
       c:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      10:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      14:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      18:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      1c:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      20:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      24:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      28:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      2c:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      30:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      34:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      38:	0c 94 81 11 	jmp	0x2302	; 0x2302 <__vector_14>
      3c:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      40:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      44:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      48:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      4c:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      50:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      54:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      58:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      5c:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      60:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      64:	0c 94 96 16 	jmp	0x2d2c	; 0x2d2c <__vector_25>
      68:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      6c:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      70:	0c 94 c0 16 	jmp	0x2d80	; 0x2d80 <__vector_28>
      74:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      78:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      7c:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      80:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      84:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      88:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      8c:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      90:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      94:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      98:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      9c:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      a0:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      a4:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      a8:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      ac:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      b0:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      b4:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      b8:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      bc:	0c 94 10 12 	jmp	0x2420	; 0x2420 <__vector_47>
      c0:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      c4:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      c8:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      cc:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      d0:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      d4:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      d8:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      dc:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      e0:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      e4:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      e8:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      ec:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      f0:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      f4:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      f8:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
      fc:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     100:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     104:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     108:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     10c:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     110:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     114:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     118:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     11c:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     120:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     124:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     128:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     12c:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     130:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     134:	0c 94 c8 11 	jmp	0x2390	; 0x2390 <__vector_77>
     138:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     13c:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     140:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     144:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     148:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     14c:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     150:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     154:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     158:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     15c:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     160:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     164:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     168:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     16c:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     170:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     174:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     178:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     17c:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     180:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     184:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     188:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     18c:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     190:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     194:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     198:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     19c:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     1a0:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     1a4:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     1a8:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     1ac:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     1b0:	0c 94 53 12 	jmp	0x24a6	; 0x24a6 <__vector_108>
     1b4:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     1b8:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     1bc:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     1c0:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     1c4:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     1c8:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     1cc:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     1d0:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     1d4:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     1d8:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     1dc:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     1e0:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     1e4:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__bad_interrupt>
     1e8:	08 4a       	sbci	r16, 0xA8	; 168
     1ea:	d7 3b       	cpi	r29, 0xB7	; 183
     1ec:	3b ce       	rjmp	.-906    	; 0xfffffe64 <__eeprom_end+0xff7efe64>
     1ee:	01 6e       	ori	r16, 0xE1	; 225
     1f0:	84 bc       	out	0x24, r8	; 36
     1f2:	bf fd       	.word	0xfdbf	; ????
     1f4:	c1 2f       	mov	r28, r17
     1f6:	3d 6c       	ori	r19, 0xCD	; 205
     1f8:	74 31       	cpi	r23, 0x14	; 20
     1fa:	9a bd       	out	0x2a, r25	; 42
     1fc:	56 83       	std	Z+6, r21	; 0x06
     1fe:	3d da       	rcall	.-2950   	; 0xfffff67a <__eeprom_end+0xff7ef67a>
     200:	3d 00       	.word	0x003d	; ????
     202:	c7 7f       	andi	r28, 0xF7	; 247
     204:	11 be       	out	0x31, r1	; 49
     206:	d9 e4       	ldi	r29, 0x49	; 73
     208:	bb 4c       	sbci	r27, 0xCB	; 203
     20a:	3e 91       	ld	r19, -X
     20c:	6b aa       	std	Y+51, r6	; 0x33
     20e:	aa be       	out	0x3a, r10	; 58
     210:	00 00       	nop
     212:	00 80       	ld	r0, Z
     214:	3f 05       	cpc	r19, r15
     216:	a8 4c       	sbci	r26, 0xC8	; 200
     218:	cd b2       	in	r12, 0x1d	; 29
     21a:	d4 4e       	sbci	r29, 0xE4	; 228
     21c:	b9 38       	cpi	r27, 0x89	; 137
     21e:	36 a9       	ldd	r19, Z+54	; 0x36
     220:	02 0c       	add	r0, r2
     222:	50 b9       	out	0x00, r21	; 0
     224:	91 86       	std	Z+9, r9	; 0x09
     226:	88 08       	sbc	r8, r8
     228:	3c a6       	std	Y+44, r3	; 0x2c
     22a:	aa aa       	std	Y+50, r10	; 0x32
     22c:	2a be       	out	0x3a, r2	; 58
     22e:	00 00       	nop
     230:	00 80       	ld	r0, Z
     232:	3f 27       	eor	r19, r31

00000233 <__c.3587>:
     233:	27 24 27 20 74 6f 20 64 75 6d 70 20 63 75 72 72     '$' to dump curr
     243:	65 6e 74 20 73 65 74 74 69 6e 67 73 0d 0a 00        ent settings...

00000252 <__c.3578>:
     252:	53 74 6f 72 65 64 20 6e 65 77 20 73 65 74 74 69     Stored new setti
     262:	6e 67 0d 0a 00                                      ng...

00000267 <__c.3576>:
     267:	55 6e 6b 6e 6f 77 6e 20 70 61 72 61 6d 65 74 65     Unknown paramete
     277:	72 0d 0a 00                                         r...

0000027b <__c.3539>:
     27b:	29 0d 0a 0d 0a 27 24 78 3d 76 61 6c 75 65 27 20     )....'$x=value' 
     28b:	74 6f 20 73 65 74 20 70 61 72 61 6d 65 74 65 72     to set parameter
     29b:	20 6f 72 20 6a 75 73 74 20 27 24 27 20 74 6f 20      or just '$' to 
     2ab:	64 75 6d 70 20 63 75 72 72 65 6e 74 20 73 65 74     dump current set
     2bb:	74 69 6e 67 73 0d 0a 00                             tings...

000002c3 <__c.3537>:
     2c3:	20 28 73 74 65 70 20 70 6f 72 74 20 69 6e 76 65      (step port inve
     2d3:	72 74 20 6d 61 73 6b 2e 20 62 69 6e 61 72 79 20     rt mask. binary 
     2e3:	3d 20 00                                            = .

000002e6 <__c.3535>:
     2e6:	20 28 6d 6d 2f 61 72 63 20 73 65 67 6d 65 6e 74      (mm/arc segment
     2f6:	29 0d 0a 24 37 20 3d 20 00                          )..$7 = .

000002ff <__c.3533>:
     2ff:	20 28 6d 6d 2f 73 65 63 20 64 65 66 61 75 6c 74      (mm/sec default
     30f:	20 73 65 65 6b 20 72 61 74 65 29 0d 0a 24 36 20      seek rate)..$6 
     31f:	3d 20 00                                            = .

00000322 <__c.3531>:
     322:	20 28 6d 6d 2f 73 65 63 20 64 65 66 61 75 6c 74      (mm/sec default
     332:	20 66 65 65 64 20 72 61 74 65 29 0d 0a 24 35 20      feed rate)..$5 
     342:	3d 20 00                                            = .

00000345 <__c.3529>:
     345:	20 28 6d 69 63 72 6f 73 65 63 6f 6e 64 73 20 73      (microseconds s
     355:	74 65 70 20 70 75 6c 73 65 29 0d 0a 24 34 20 3d     tep pulse)..$4 =
     365:	20 00                                                .

00000367 <__c.3527>:
     367:	20 28 73 74 65 70 73 2f 6d 6d 20 7a 29 0d 0a 24      (steps/mm z)..$
     377:	33 20 3d 20 00                                      3 = .

0000037c <__c.3525>:
     37c:	20 28 73 74 65 70 73 2f 6d 6d 20 79 29 0d 0a 24      (steps/mm y)..$
     38c:	32 20 3d 20 00                                      2 = .

00000391 <__c.3523>:
     391:	20 28 73 74 65 70 73 2f 6d 6d 20 78 29 0d 0a 24      (steps/mm x)..$
     3a1:	31 20 3d 20 00                                      1 = .

000003a6 <__c.3521>:
     3a6:	24 30 20 3d 20 00                                   $0 = .

000003ac <__c.3509>:
     3ac:	0d 0a 00                                            ...

000003af <__c.3507>:
     3af:	0d 0a 20 45 58 45 43 3e 3e 20 00                    .. EXEC>> .

000003ba <__c.3502>:
     3ba:	0d 0a 00                                            ...

000003bd <__c.3500>:
     3bd:	30 2e 30 31 00                                      0.01.

000003c2 <__c.3498>:
     3c2:	0d 0a 54 69 6e 79 47 20 5b 54 45 53 54 20 4d 4f     ..TinyG [TEST MO
     3d2:	44 45 5d 20 2d 20 56 65 72 73 69 6f 6e 20 00        DE] - Version .

000003e1 <__c.3494>:
     3e1:	54 69 6e 79 47 3e 3e 20 00                          TinyG>> .

000003ea <__c.3889>:
     3ea:	0d 0a 00                                            ...

000003ed <__c.3887>:
     3ed:	2c 20 53 74 65 70 73 3d 00                          , Steps=.

000003f6 <__c.3885>:
     3f6:	2c 20 44 3d 00                                      , D=.

000003fb <__c.3883>:
     3fb:	2c 20 75 53 3d 00                                   , uS=.

00000401 <__c.3881>:
     401:	2c 20 5a 3d 00                                      , Z=.

00000406 <__c.3879>:
     406:	2c 20 59 3d 00                                      , Y=.

0000040b <__c.3877>:
     40b:	4c 69 6e 65 20 58 3d 00                             Line X=.

00000413 <__c.3870>:
     413:	0d 0a 00                                            ...

00000416 <__c.3868>:
     416:	41 43 54 49 56 45 20 3d 20 00                       ACTIVE = .

00000420 <__c.3864>:
     420:	0d 0a 00                                            ...

00000423 <__c.3862>:
     423:	20 75 53 3d 00                                       uS=.

00000428 <__c.3860>:
     428:	20 5a 3d 00                                          Z=.

0000042c <__c.3858>:
     42c:	20 59 3d 00                                          Y=.

00000430 <__c.3856>:
     430:	4c 69 6e 65 3a 20 58 3d 00                          Line: X=.

00000439 <pstr_inf>:
     439:	49 4e 46                                            INF

0000043c <pstr_inity>:
     43c:	49 4e 49 54 59                                      INITY

00000441 <pstr_nan>:
     441:	4e 41 4e                                            NAN

00000444 <pwr_m10>:
     444:	cd cc cc 3d 0a d7 23 3c 17 b7 d1 38 77 cc 2b 32     ...=..#<...8w.+2
     454:	95 95 e6 24 1f b1 4f 0a                             ...$..O.

0000045c <pwr_p10>:
     45c:	00 00 20 41 00 00 c8 42 00 40 1c 46 20 bc be 4c     .. A...B.@.F ..L
     46c:	ca 1b 0e 5a ae c5 9d 74                             ...Z...t

00000474 <__ctors_end>:
     474:	11 24       	eor	r1, r1
     476:	1f be       	out	0x3f, r1	; 63
     478:	cf ef       	ldi	r28, 0xFF	; 255
     47a:	df e5       	ldi	r29, 0x5F	; 95
     47c:	de bf       	out	0x3e, r29	; 62
     47e:	cd bf       	out	0x3d, r28	; 61
     480:	00 e0       	ldi	r16, 0x00	; 0
     482:	0c bf       	out	0x3c, r16	; 60

00000484 <__do_copy_data>:
     484:	10 e2       	ldi	r17, 0x20	; 32
     486:	a0 e0       	ldi	r26, 0x00	; 0
     488:	b0 e2       	ldi	r27, 0x20	; 32
     48a:	e4 ee       	ldi	r30, 0xE4	; 228
     48c:	fc e3       	ldi	r31, 0x3C	; 60
     48e:	00 e0       	ldi	r16, 0x00	; 0
     490:	0b bf       	out	0x3b, r16	; 59
     492:	02 c0       	rjmp	.+4      	; 0x498 <__do_copy_data+0x14>
     494:	07 90       	elpm	r0, Z+
     496:	0d 92       	st	X+, r0
     498:	aa 32       	cpi	r26, 0x2A	; 42
     49a:	b1 07       	cpc	r27, r17
     49c:	d9 f7       	brne	.-10     	; 0x494 <__do_copy_data+0x10>

0000049e <__do_clear_bss>:
     49e:	15 e2       	ldi	r17, 0x25	; 37
     4a0:	aa e2       	ldi	r26, 0x2A	; 42
     4a2:	b0 e2       	ldi	r27, 0x20	; 32
     4a4:	01 c0       	rjmp	.+2      	; 0x4a8 <.do_clear_bss_start>

000004a6 <.do_clear_bss_loop>:
     4a6:	1d 92       	st	X+, r1

000004a8 <.do_clear_bss_start>:
     4a8:	ac 33       	cpi	r26, 0x3C	; 60
     4aa:	b1 07       	cpc	r27, r17
     4ac:	e1 f7       	brne	.-8      	; 0x4a6 <.do_clear_bss_loop>
     4ae:	0e 94 5d 02 	call	0x4ba	; 0x4ba <main>
     4b2:	0c 94 70 1e 	jmp	0x3ce0	; 0x3ce0 <_exit>

000004b6 <__bad_interrupt>:
     4b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000004ba <main>:


int main(void) 
{
	/* These inits are order dependent */
	cli();
     4ba:	f8 94       	cli
	xmega_init();				// xmega setup
     4bc:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <xmega_init>
	config_init();				// get config record from eeprom
     4c0:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <config_init>
	st_init(); 					// stepper subsystem
     4c4:	0e 94 1e 10 	call	0x203c	; 0x203c <st_init>
	mc_init();					// motion control subsystem
     4c8:	0e 94 f0 0b 	call	0x17e0	; 0x17e0 <mc_init>
	spindle_init();				// spindle controller
     4cc:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <spindle_init>
	en_init();					// encoders
     4d0:	0e 94 d3 0b 	call	0x17a6	; 0x17a6 <en_init>
	gc_init();					// gcode-parser
     4d4:	0e 94 02 03 	call	0x604	; 0x604 <gc_init>
	sp_init();					// serial protocol
     4d8:	0e 94 8e 0f 	call	0x1f1c	; 0x1f1c <sp_init>

	PMIC_SetVectorLocationToApplication();  // as opposed to boot rom
     4dc:	0e 94 2b 0f 	call	0x1e56	; 0x1e56 <PMIC_SetVectorLocationToApplication>
//	PMIC_EnableLowLevel();		// nothing at this level
	PMIC_EnableMediumLevel(); 	// enable serial IO
     4e0:	e0 ea       	ldi	r30, 0xA0	; 160
     4e2:	f0 e0       	ldi	r31, 0x00	; 0
     4e4:	80 91 a2 00 	lds	r24, 0x00A2
     4e8:	82 60       	ori	r24, 0x02	; 2
     4ea:	82 83       	std	Z+2, r24	; 0x02
	PMIC_EnableHighLevel();		// enable stepper timers
     4ec:	80 91 a2 00 	lds	r24, 0x00A2
     4f0:	84 60       	ori	r24, 0x04	; 4
     4f2:	82 83       	std	Z+2, r24	; 0x02
	sei();						// enable global interrupts
     4f4:	78 94       	sei

	for(;;){
		sleep_mode();
     4f6:	80 91 48 00 	lds	r24, 0x0048
     4fa:	81 60       	ori	r24, 0x01	; 1
     4fc:	80 93 48 00 	sts	0x0048, r24
     500:	88 95       	sleep
     502:	80 91 48 00 	lds	r24, 0x0048
     506:	8e 7f       	andi	r24, 0xFE	; 254
     508:	80 93 48 00 	sts	0x0048, r24
		sp_process(); 			// process the serial protocol
     50c:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <sp_process>
		st_execute_line();		// run next motor move
     510:	0e 94 5c 15 	call	0x2ab8	; 0x2ab8 <st_execute_line>
     514:	f0 cf       	rjmp	.-32     	; 0x4f6 <main+0x3c>

00000516 <select_plane>:

void select_plane(uint8_t axis_0, uint8_t axis_1, uint8_t axis_2) 

/* gc_init() */
{
	gc.plane_axis_0 = axis_0;
     516:	80 93 6d 20 	sts	0x206D, r24
	gc.plane_axis_1 = axis_1;
     51a:	60 93 6e 20 	sts	0x206E, r22
	gc.plane_axis_2 = axis_2;
     51e:	40 93 6f 20 	sts	0x206F, r20
}
     522:	08 95       	ret

00000524 <read_double>:
}

int read_double(char *textline, 	//!< string: line of RS274/NGC code being processed
                int *counter,       //!< pointer to a counter for position on the line 
                double *double_ptr) //!< pointer to double to be read                  
{
     524:	af 92       	push	r10
     526:	bf 92       	push	r11
     528:	cf 92       	push	r12
     52a:	df 92       	push	r13
     52c:	ef 92       	push	r14
     52e:	ff 92       	push	r15
     530:	0f 93       	push	r16
     532:	1f 93       	push	r17
     534:	df 93       	push	r29
     536:	cf 93       	push	r28
     538:	0f 92       	push	r0
     53a:	0f 92       	push	r0
     53c:	cd b7       	in	r28, 0x3d	; 61
     53e:	de b7       	in	r29, 0x3e	; 62
     540:	6c 01       	movw	r12, r24
     542:	5b 01       	movw	r10, r22
     544:	7a 01       	movw	r14, r20
  char *start = textline + *counter;
     546:	fb 01       	movw	r30, r22
     548:	00 81       	ld	r16, Z
     54a:	11 81       	ldd	r17, Z+1	; 0x01
     54c:	08 0f       	add	r16, r24
     54e:	19 1f       	adc	r17, r25
  char *end;
  
  *double_ptr = strtod(start, &end);
     550:	c8 01       	movw	r24, r16
     552:	be 01       	movw	r22, r28
     554:	6f 5f       	subi	r22, 0xFF	; 255
     556:	7f 4f       	sbci	r23, 0xFF	; 255
     558:	0e 94 df 1c 	call	0x39be	; 0x39be <strtod>
     55c:	f7 01       	movw	r30, r14
     55e:	60 83       	st	Z, r22
     560:	71 83       	std	Z+1, r23	; 0x01
     562:	82 83       	std	Z+2, r24	; 0x02
     564:	93 83       	std	Z+3, r25	; 0x03
  if(end == start) { 
     566:	89 81       	ldd	r24, Y+1	; 0x01
     568:	9a 81       	ldd	r25, Y+2	; 0x02
     56a:	80 17       	cp	r24, r16
     56c:	91 07       	cpc	r25, r17
     56e:	31 f4       	brne	.+12     	; 0x57c <read_double+0x58>
    FAIL(GCSTATUS_BAD_NUMBER_FORMAT); 
     570:	81 e0       	ldi	r24, 0x01	; 1
     572:	80 93 4e 20 	sts	0x204E, r24
     576:	20 e0       	ldi	r18, 0x00	; 0
     578:	30 e0       	ldi	r19, 0x00	; 0
     57a:	07 c0       	rjmp	.+14     	; 0x58a <read_double+0x66>
    return(0); 
  };

  *counter = end - textline;
     57c:	8c 19       	sub	r24, r12
     57e:	9d 09       	sbc	r25, r13
     580:	f5 01       	movw	r30, r10
     582:	80 83       	st	Z, r24
     584:	91 83       	std	Z+1, r25	; 0x01
     586:	21 e0       	ldi	r18, 0x01	; 1
     588:	30 e0       	ldi	r19, 0x00	; 0
  return(1);
}
     58a:	c9 01       	movw	r24, r18
     58c:	0f 90       	pop	r0
     58e:	0f 90       	pop	r0
     590:	cf 91       	pop	r28
     592:	df 91       	pop	r29
     594:	1f 91       	pop	r17
     596:	0f 91       	pop	r16
     598:	ff 90       	pop	r15
     59a:	ef 90       	pop	r14
     59c:	df 90       	pop	r13
     59e:	cf 90       	pop	r12
     5a0:	bf 90       	pop	r11
     5a2:	af 90       	pop	r10
     5a4:	08 95       	ret

000005a6 <next_statement>:
}

// Parses the next statement and leaves the counter on the first character following
// the statement. Returns 1 if there was a statements, 0 if end of string was reached
// or there was an error (check state.status_code).
int next_statement(char *letter, double *double_ptr, char *textline, int *counter) {
     5a6:	0f 93       	push	r16
     5a8:	1f 93       	push	r17
     5aa:	cf 93       	push	r28
     5ac:	df 93       	push	r29
     5ae:	ec 01       	movw	r28, r24
     5b0:	8b 01       	movw	r16, r22
     5b2:	d9 01       	movw	r26, r18
  if (textline[*counter] == 0) {
     5b4:	ed 91       	ld	r30, X+
     5b6:	fc 91       	ld	r31, X
     5b8:	11 97       	sbiw	r26, 0x01	; 1
     5ba:	e4 0f       	add	r30, r20
     5bc:	f5 1f       	adc	r31, r21
     5be:	e0 81       	ld	r30, Z
     5c0:	ee 23       	and	r30, r30
     5c2:	39 f0       	breq	.+14     	; 0x5d2 <next_statement+0x2c>
    return(0); // No more statements
  }
  
  *letter = textline[*counter];
     5c4:	e8 83       	st	Y, r30
  if((*letter < 'A') || (*letter > 'Z')) {
     5c6:	e1 54       	subi	r30, 0x41	; 65
     5c8:	ea 31       	cpi	r30, 0x1A	; 26
     5ca:	30 f0       	brcs	.+12     	; 0x5d8 <next_statement+0x32>
    FAIL(GCSTATUS_EXPECTED_COMMAND_LETTER);
     5cc:	82 e0       	ldi	r24, 0x02	; 2
     5ce:	80 93 4e 20 	sts	0x204E, r24
     5d2:	20 e0       	ldi	r18, 0x00	; 0
     5d4:	30 e0       	ldi	r19, 0x00	; 0
     5d6:	10 c0       	rjmp	.+32     	; 0x5f8 <next_statement+0x52>
    return(0);
  }
  (*counter)++;
     5d8:	8d 91       	ld	r24, X+
     5da:	9c 91       	ld	r25, X
     5dc:	11 97       	sbiw	r26, 0x01	; 1
     5de:	01 96       	adiw	r24, 0x01	; 1
     5e0:	8d 93       	st	X+, r24
     5e2:	9c 93       	st	X, r25
  if (!read_double(textline, counter, double_ptr)) {
     5e4:	ca 01       	movw	r24, r20
     5e6:	b9 01       	movw	r22, r18
     5e8:	a8 01       	movw	r20, r16
     5ea:	0e 94 92 02 	call	0x524	; 0x524 <read_double>
     5ee:	00 97       	sbiw	r24, 0x00	; 0
     5f0:	11 f0       	breq	.+4      	; 0x5f6 <next_statement+0x50>
     5f2:	81 e0       	ldi	r24, 0x01	; 1
     5f4:	90 e0       	ldi	r25, 0x00	; 0
     5f6:	9c 01       	movw	r18, r24
    return(0);
  };
  return(1);
}
     5f8:	c9 01       	movw	r24, r18
     5fa:	df 91       	pop	r29
     5fc:	cf 91       	pop	r28
     5fe:	1f 91       	pop	r17
     600:	0f 91       	pop	r16
     602:	08 95       	ret

00000604 <gc_init>:
int next_statement(char *letter, double *double_ptr, char *line, int *counter);

/* gc_init() */

void gc_init() {
	memset(&gc, 0, sizeof(gc));
     604:	82 e2       	ldi	r24, 0x22	; 34
     606:	ee e4       	ldi	r30, 0x4E	; 78
     608:	f0 e2       	ldi	r31, 0x20	; 32
     60a:	df 01       	movw	r26, r30
     60c:	1d 92       	st	X+, r1
     60e:	8a 95       	dec	r24
     610:	e9 f7       	brne	.-6      	; 0x60c <gc_init+0x8>
	gc.feed_rate = settings.default_feed_rate/60;
     612:	60 91 41 20 	lds	r22, 0x2041
     616:	70 91 42 20 	lds	r23, 0x2042
     61a:	80 91 43 20 	lds	r24, 0x2043
     61e:	90 91 44 20 	lds	r25, 0x2044
     622:	20 e0       	ldi	r18, 0x00	; 0
     624:	30 e0       	ldi	r19, 0x00	; 0
     626:	40 e7       	ldi	r20, 0x70	; 112
     628:	52 e4       	ldi	r21, 0x42	; 66
     62a:	0e 94 b7 18 	call	0x316e	; 0x316e <__divsf3>
     62e:	60 93 56 20 	sts	0x2056, r22
     632:	70 93 57 20 	sts	0x2057, r23
     636:	80 93 58 20 	sts	0x2058, r24
     63a:	90 93 59 20 	sts	0x2059, r25
	gc.seek_rate = settings.default_seek_rate/60;
     63e:	60 91 45 20 	lds	r22, 0x2045
     642:	70 91 46 20 	lds	r23, 0x2046
     646:	80 91 47 20 	lds	r24, 0x2047
     64a:	90 91 48 20 	lds	r25, 0x2048
     64e:	20 e0       	ldi	r18, 0x00	; 0
     650:	30 e0       	ldi	r19, 0x00	; 0
     652:	40 e7       	ldi	r20, 0x70	; 112
     654:	52 e4       	ldi	r21, 0x42	; 66
     656:	0e 94 b7 18 	call	0x316e	; 0x316e <__divsf3>
     65a:	60 93 5a 20 	sts	0x205A, r22
     65e:	70 93 5b 20 	sts	0x205B, r23
     662:	80 93 5c 20 	sts	0x205C, r24
     666:	90 93 5d 20 	sts	0x205D, r25

void select_plane(uint8_t axis_0, uint8_t axis_1, uint8_t axis_2) 

/* gc_init() */
{
	gc.plane_axis_0 = axis_0;
     66a:	10 92 6d 20 	sts	0x206D, r1
	gc.plane_axis_1 = axis_1;
     66e:	91 e0       	ldi	r25, 0x01	; 1
     670:	90 93 6e 20 	sts	0x206E, r25
	gc.plane_axis_2 = axis_2;
     674:	82 e0       	ldi	r24, 0x02	; 2
     676:	80 93 6f 20 	sts	0x206F, r24
void gc_init() {
	memset(&gc, 0, sizeof(gc));
	gc.feed_rate = settings.default_feed_rate/60;
	gc.seek_rate = settings.default_seek_rate/60;
	select_plane(X_AXIS, Y_AXIS, Z_AXIS);
	gc.absolute_mode = TRUE;
     67a:	90 93 52 20 	sts	0x2052, r25
}
     67e:	08 95       	ret

00000680 <theta>:

	Find the angle in radians of deviance from the positive y axis. 
	negative angles to the left of y-axis, positive to the right.
*/
double theta(double x, double y)
{
     680:	af 92       	push	r10
     682:	bf 92       	push	r11
     684:	cf 92       	push	r12
     686:	df 92       	push	r13
     688:	ef 92       	push	r14
     68a:	ff 92       	push	r15
     68c:	0f 93       	push	r16
     68e:	1f 93       	push	r17
     690:	79 01       	movw	r14, r18
     692:	8a 01       	movw	r16, r20
	double theta = atan(x/fabs(y));
     694:	5f 77       	andi	r21, 0x7F	; 127
     696:	0e 94 b7 18 	call	0x316e	; 0x316e <__divsf3>
     69a:	0e 94 75 18 	call	0x30ea	; 0x30ea <atan>
     69e:	5b 01       	movw	r10, r22
     6a0:	6c 01       	movw	r12, r24

	if (y>0) {
     6a2:	c8 01       	movw	r24, r16
     6a4:	b7 01       	movw	r22, r14
     6a6:	20 e0       	ldi	r18, 0x00	; 0
     6a8:	30 e0       	ldi	r19, 0x00	; 0
     6aa:	40 e0       	ldi	r20, 0x00	; 0
     6ac:	50 e0       	ldi	r21, 0x00	; 0
     6ae:	0e 94 a0 1a 	call	0x3540	; 0x3540 <__gesf2>
     6b2:	18 16       	cp	r1, r24
     6b4:	cc f0       	brlt	.+50     	; 0x6e8 <theta+0x68>
		return(theta);
	} else {
		if (theta>0) 
     6b6:	c6 01       	movw	r24, r12
     6b8:	b5 01       	movw	r22, r10
     6ba:	20 e0       	ldi	r18, 0x00	; 0
     6bc:	30 e0       	ldi	r19, 0x00	; 0
     6be:	40 e0       	ldi	r20, 0x00	; 0
     6c0:	50 e0       	ldi	r21, 0x00	; 0
     6c2:	0e 94 a0 1a 	call	0x3540	; 0x3540 <__gesf2>
     6c6:	18 16       	cp	r1, r24
     6c8:	2c f4       	brge	.+10     	; 0x6d4 <theta+0x54>
	    {
			return(M_PI-theta);
     6ca:	6b ed       	ldi	r22, 0xDB	; 219
     6cc:	7f e0       	ldi	r23, 0x0F	; 15
     6ce:	89 e4       	ldi	r24, 0x49	; 73
     6d0:	90 e4       	ldi	r25, 0x40	; 64
     6d2:	04 c0       	rjmp	.+8      	; 0x6dc <theta+0x5c>
    	} else {
			return(-M_PI-theta);
     6d4:	6b ed       	ldi	r22, 0xDB	; 219
     6d6:	7f e0       	ldi	r23, 0x0F	; 15
     6d8:	89 e4       	ldi	r24, 0x49	; 73
     6da:	90 ec       	ldi	r25, 0xC0	; 192
     6dc:	a6 01       	movw	r20, r12
     6de:	95 01       	movw	r18, r10
     6e0:	0e 94 10 18 	call	0x3020	; 0x3020 <__subsf3>
     6e4:	5b 01       	movw	r10, r22
     6e6:	6c 01       	movw	r12, r24
		}
	}
}
     6e8:	b5 01       	movw	r22, r10
     6ea:	c6 01       	movw	r24, r12
     6ec:	1f 91       	pop	r17
     6ee:	0f 91       	pop	r16
     6f0:	ff 90       	pop	r15
     6f2:	ef 90       	pop	r14
     6f4:	df 90       	pop	r13
     6f6:	cf 90       	pop	r12
     6f8:	bf 90       	pop	r11
     6fa:	af 90       	pop	r10
     6fc:	08 95       	ret

000006fe <gc_execute_line>:

/* gc_execute_line() - executes one line of 0-terminated G-Code. 
	The line is assumed to contain only uppercase characters and 
	signed floats (no whitespace).
*/
uint8_t gc_execute_line(char *textline) {
     6fe:	2f 92       	push	r2
     700:	3f 92       	push	r3
     702:	4f 92       	push	r4
     704:	5f 92       	push	r5
     706:	6f 92       	push	r6
     708:	7f 92       	push	r7
     70a:	8f 92       	push	r8
     70c:	9f 92       	push	r9
     70e:	af 92       	push	r10
     710:	bf 92       	push	r11
     712:	cf 92       	push	r12
     714:	df 92       	push	r13
     716:	ef 92       	push	r14
     718:	ff 92       	push	r15
     71a:	0f 93       	push	r16
     71c:	1f 93       	push	r17
     71e:	df 93       	push	r29
     720:	cf 93       	push	r28
     722:	cd b7       	in	r28, 0x3d	; 61
     724:	de b7       	in	r29, 0x3e	; 62
     726:	ee 97       	sbiw	r28, 0x3e	; 62
     728:	cd bf       	out	0x3d, r28	; 61
     72a:	de bf       	out	0x3e, r29	; 62
     72c:	5c 01       	movw	r10, r24
	int counter = 0;  
     72e:	1a 82       	std	Y+2, r1	; 0x02
     730:	1b 82       	std	Y+3, r1	; 0x03
  
	uint8_t absolute_override = FALSE; /* 1 = absolute motion for this block only {G53} */
	uint8_t next_action = NEXT_ACTION_DEFAULT; /* One of the NEXT_ACTION_-constants */
  
	double target[3], offset[3];  
  	double p = 0, r = 0;
     732:	80 e0       	ldi	r24, 0x00	; 0
     734:	90 e0       	ldi	r25, 0x00	; 0
     736:	a0 e0       	ldi	r26, 0x00	; 0
     738:	b0 e0       	ldi	r27, 0x00	; 0
     73a:	88 87       	std	Y+8, r24	; 0x08
     73c:	99 87       	std	Y+9, r25	; 0x09
     73e:	aa 87       	std	Y+10, r26	; 0x0a
     740:	bb 87       	std	Y+11, r27	; 0x0b
	int int_value;
  
	clear_vector(target);
     742:	8c e0       	ldi	r24, 0x0C	; 12
     744:	fe 01       	movw	r30, r28
     746:	3c 96       	adiw	r30, 0x0c	; 12
     748:	df 01       	movw	r26, r30
     74a:	28 2f       	mov	r18, r24
     74c:	1d 92       	st	X+, r1
     74e:	2a 95       	dec	r18
     750:	e9 f7       	brne	.-6      	; 0x74c <gc_execute_line+0x4e>
	clear_vector(offset);
     752:	fe 01       	movw	r30, r28
     754:	78 96       	adiw	r30, 0x18	; 24
     756:	df 01       	movw	r26, r30
     758:	1d 92       	st	X+, r1
     75a:	8a 95       	dec	r24
     75c:	e9 f7       	brne	.-6      	; 0x758 <gc_execute_line+0x5a>

	gc.status_code = GCSTATUS_OK;
     75e:	10 92 4e 20 	sts	0x204E, r1

  // First: parse all statements
  
	if (textline[0] == '(') { 
     762:	f5 01       	movw	r30, r10
     764:	80 81       	ld	r24, Z
     766:	88 32       	cpi	r24, 0x28	; 40
     768:	b1 f0       	breq	.+44     	; 0x796 <gc_execute_line+0x98>
		return(gc.status_code); 
	}
	if (textline[0] == '/') { 	// ignore block delete
     76a:	8f 32       	cpi	r24, 0x2F	; 47
     76c:	29 f4       	brne	.+10     	; 0x778 <gc_execute_line+0x7a>
		counter++; 
     76e:	8a 81       	ldd	r24, Y+2	; 0x02
     770:	9b 81       	ldd	r25, Y+3	; 0x03
     772:	01 96       	adiw	r24, 0x01	; 1
     774:	8a 83       	std	Y+2, r24	; 0x02
     776:	9b 83       	std	Y+3, r25	; 0x03
	} 
  	if (textline[0] == '$') { 	// This is a parameter line intended to change EEPROM-settings
     778:	d5 01       	movw	r26, r10
     77a:	8c 91       	ld	r24, X
     77c:	84 32       	cpi	r24, 0x24	; 36
     77e:	09 f0       	breq	.+2      	; 0x782 <gc_execute_line+0x84>
     780:	2e c1       	rjmp	.+604    	; 0x9de <gc_execute_line+0x2e0>
    							// Parameter lines are on the form '$4=374.3' or 
								// '$' to dump current settings
		counter = 1;
     782:	81 e0       	ldi	r24, 0x01	; 1
     784:	90 e0       	ldi	r25, 0x00	; 0
     786:	8a 83       	std	Y+2, r24	; 0x02
     788:	9b 83       	std	Y+3, r25	; 0x03
		if(textline[counter] == 0) {
     78a:	11 96       	adiw	r26, 0x01	; 1
     78c:	8c 91       	ld	r24, X
     78e:	88 23       	and	r24, r24
     790:	21 f4       	brne	.+8      	; 0x79a <gc_execute_line+0x9c>
			dump_settings(); return(GCSTATUS_OK); 
     792:	0e 94 73 09 	call	0x12e6	; 0x12e6 <dump_settings>
     796:	80 e0       	ldi	r24, 0x00	; 0
     798:	cb c4       	rjmp	.+2454   	; 0x1130 <gc_execute_line+0xa32>
		}
	    read_double(textline, &counter, &p);
     79a:	8e 01       	movw	r16, r28
     79c:	0e 5f       	subi	r16, 0xFE	; 254
     79e:	1f 4f       	sbci	r17, 0xFF	; 255
     7a0:	c5 01       	movw	r24, r10
     7a2:	b8 01       	movw	r22, r16
     7a4:	ae 01       	movw	r20, r28
     7a6:	48 5f       	subi	r20, 0xF8	; 248
     7a8:	5f 4f       	sbci	r21, 0xFF	; 255
     7aa:	0e 94 92 02 	call	0x524	; 0x524 <read_double>

    	if(textline[counter++] != '=') { 
     7ae:	2a 81       	ldd	r18, Y+2	; 0x02
     7b0:	3b 81       	ldd	r19, Y+3	; 0x03
     7b2:	f5 01       	movw	r30, r10
     7b4:	e2 0f       	add	r30, r18
     7b6:	f3 1f       	adc	r31, r19
     7b8:	80 81       	ld	r24, Z
     7ba:	8d 33       	cpi	r24, 0x3D	; 61
     7bc:	09 f0       	breq	.+2      	; 0x7c0 <gc_execute_line+0xc2>
     7be:	b7 c4       	rjmp	.+2414   	; 0x112e <gc_execute_line+0xa30>
     7c0:	2f 5f       	subi	r18, 0xFF	; 255
     7c2:	3f 4f       	sbci	r19, 0xFF	; 255
     7c4:	2a 83       	std	Y+2, r18	; 0x02
     7c6:	3b 83       	std	Y+3, r19	; 0x03
			return(GCSTATUS_UNSUPPORTED_STATEMENT); 
		}
    	read_double(textline, &counter, &value);
     7c8:	c5 01       	movw	r24, r10
     7ca:	b8 01       	movw	r22, r16
     7cc:	ae 01       	movw	r20, r28
     7ce:	4c 5f       	subi	r20, 0xFC	; 252
     7d0:	5f 4f       	sbci	r21, 0xFF	; 255
     7d2:	0e 94 92 02 	call	0x524	; 0x524 <read_double>

    	if(textline[counter] != 0) { 
     7d6:	ea 81       	ldd	r30, Y+2	; 0x02
     7d8:	fb 81       	ldd	r31, Y+3	; 0x03
     7da:	ea 0d       	add	r30, r10
     7dc:	fb 1d       	adc	r31, r11
     7de:	80 81       	ld	r24, Z
     7e0:	88 23       	and	r24, r24
     7e2:	09 f0       	breq	.+2      	; 0x7e6 <gc_execute_line+0xe8>
     7e4:	a4 c4       	rjmp	.+2376   	; 0x112e <gc_execute_line+0xa30>
			return(GCSTATUS_UNSUPPORTED_STATEMENT); 
		}
    	store_setting(p, value);
     7e6:	68 85       	ldd	r22, Y+8	; 0x08
     7e8:	79 85       	ldd	r23, Y+9	; 0x09
     7ea:	8a 85       	ldd	r24, Y+10	; 0x0a
     7ec:	9b 85       	ldd	r25, Y+11	; 0x0b
     7ee:	0e 94 1f 19 	call	0x323e	; 0x323e <__fixsfsi>
     7f2:	dc 01       	movw	r26, r24
     7f4:	cb 01       	movw	r24, r22
     7f6:	4c 81       	ldd	r20, Y+4	; 0x04
     7f8:	5d 81       	ldd	r21, Y+5	; 0x05
     7fa:	6e 81       	ldd	r22, Y+6	; 0x06
     7fc:	7f 81       	ldd	r23, Y+7	; 0x07
     7fe:	0e 94 02 09 	call	0x1204	; 0x1204 <store_setting>
     802:	ed c0       	rjmp	.+474    	; 0x9de <gc_execute_line+0x2e0>
  	}
  
  // Pass 1: Commands
	while(next_statement(&letter, &value, textline, &counter)) {
    	int_value = trunc(value);
     804:	6c 81       	ldd	r22, Y+4	; 0x04
     806:	7d 81       	ldd	r23, Y+5	; 0x05
     808:	8e 81       	ldd	r24, Y+6	; 0x06
     80a:	9f 81       	ldd	r25, Y+7	; 0x07
     80c:	0e 94 73 1c 	call	0x38e6	; 0x38e6 <trunc>
     810:	7b 01       	movw	r14, r22
     812:	8c 01       	movw	r16, r24
     814:	0e 94 1f 19 	call	0x323e	; 0x323e <__fixsfsi>
    	switch(letter) {
     818:	49 81       	ldd	r20, Y+1	; 0x01
     81a:	4d 34       	cpi	r20, 0x4D	; 77
     81c:	09 f4       	brne	.+2      	; 0x820 <gc_execute_line+0x122>
     81e:	a3 c0       	rjmp	.+326    	; 0x966 <gc_execute_line+0x268>
     820:	44 35       	cpi	r20, 0x54	; 84
     822:	09 f4       	brne	.+2      	; 0x826 <gc_execute_line+0x128>
     824:	d1 c0       	rjmp	.+418    	; 0x9c8 <gc_execute_line+0x2ca>
     826:	47 34       	cpi	r20, 0x47	; 71
     828:	09 f0       	breq	.+2      	; 0x82c <gc_execute_line+0x12e>
     82a:	d4 c0       	rjmp	.+424    	; 0x9d4 <gc_execute_line+0x2d6>
			case 'G':
				switch(int_value) {
     82c:	64 31       	cpi	r22, 0x14	; 20
     82e:	71 05       	cpc	r23, r1
     830:	09 f4       	brne	.+2      	; 0x834 <gc_execute_line+0x136>
     832:	81 c0       	rjmp	.+258    	; 0x936 <gc_execute_line+0x238>
     834:	65 31       	cpi	r22, 0x15	; 21
     836:	71 05       	cpc	r23, r1
     838:	4c f5       	brge	.+82     	; 0x88c <gc_execute_line+0x18e>
     83a:	63 30       	cpi	r22, 0x03	; 3
     83c:	71 05       	cpc	r23, r1
     83e:	09 f4       	brne	.+2      	; 0x842 <gc_execute_line+0x144>
     840:	62 c0       	rjmp	.+196    	; 0x906 <gc_execute_line+0x208>
     842:	64 30       	cpi	r22, 0x04	; 4
     844:	71 05       	cpc	r23, r1
     846:	6c f4       	brge	.+26     	; 0x862 <gc_execute_line+0x164>
     848:	61 30       	cpi	r22, 0x01	; 1
     84a:	71 05       	cpc	r23, r1
     84c:	09 f4       	brne	.+2      	; 0x850 <gc_execute_line+0x152>
     84e:	55 c0       	rjmp	.+170    	; 0x8fa <gc_execute_line+0x1fc>
     850:	62 30       	cpi	r22, 0x02	; 2
     852:	71 05       	cpc	r23, r1
     854:	0c f0       	brlt	.+2      	; 0x858 <gc_execute_line+0x15a>
     856:	54 c0       	rjmp	.+168    	; 0x900 <gc_execute_line+0x202>
     858:	61 15       	cp	r22, r1
     85a:	71 05       	cpc	r23, r1
     85c:	09 f4       	brne	.+2      	; 0x860 <gc_execute_line+0x162>
     85e:	4a c0       	rjmp	.+148    	; 0x8f4 <gc_execute_line+0x1f6>
     860:	b0 c0       	rjmp	.+352    	; 0x9c2 <gc_execute_line+0x2c4>
     862:	61 31       	cpi	r22, 0x11	; 17
     864:	71 05       	cpc	r23, r1
     866:	09 f4       	brne	.+2      	; 0x86a <gc_execute_line+0x16c>
     868:	51 c0       	rjmp	.+162    	; 0x90c <gc_execute_line+0x20e>
     86a:	62 31       	cpi	r22, 0x12	; 18
     86c:	71 05       	cpc	r23, r1
     86e:	2c f4       	brge	.+10     	; 0x87a <gc_execute_line+0x17c>
     870:	64 30       	cpi	r22, 0x04	; 4
     872:	71 05       	cpc	r23, r1
     874:	09 f0       	breq	.+2      	; 0x878 <gc_execute_line+0x17a>
     876:	a5 c0       	rjmp	.+330    	; 0x9c2 <gc_execute_line+0x2c4>
     878:	3a c0       	rjmp	.+116    	; 0x8ee <gc_execute_line+0x1f0>
     87a:	62 31       	cpi	r22, 0x12	; 18
     87c:	71 05       	cpc	r23, r1
     87e:	09 f4       	brne	.+2      	; 0x882 <gc_execute_line+0x184>
     880:	4c c0       	rjmp	.+152    	; 0x91a <gc_execute_line+0x21c>
     882:	63 31       	cpi	r22, 0x13	; 19
     884:	71 05       	cpc	r23, r1
     886:	09 f0       	breq	.+2      	; 0x88a <gc_execute_line+0x18c>
     888:	9c c0       	rjmp	.+312    	; 0x9c2 <gc_execute_line+0x2c4>
     88a:	4e c0       	rjmp	.+156    	; 0x928 <gc_execute_line+0x22a>
     88c:	60 35       	cpi	r22, 0x50	; 80
     88e:	71 05       	cpc	r23, r1
     890:	09 f4       	brne	.+2      	; 0x894 <gc_execute_line+0x196>
     892:	5a c0       	rjmp	.+180    	; 0x948 <gc_execute_line+0x24a>
     894:	61 35       	cpi	r22, 0x51	; 81
     896:	71 05       	cpc	r23, r1
     898:	9c f4       	brge	.+38     	; 0x8c0 <gc_execute_line+0x1c2>
     89a:	6c 31       	cpi	r22, 0x1C	; 28
     89c:	71 05       	cpc	r23, r1
     89e:	21 f1       	breq	.+72     	; 0x8e8 <gc_execute_line+0x1ea>
     8a0:	6d 31       	cpi	r22, 0x1D	; 29
     8a2:	71 05       	cpc	r23, r1
     8a4:	2c f4       	brge	.+10     	; 0x8b0 <gc_execute_line+0x1b2>
     8a6:	65 31       	cpi	r22, 0x15	; 21
     8a8:	71 05       	cpc	r23, r1
     8aa:	09 f0       	breq	.+2      	; 0x8ae <gc_execute_line+0x1b0>
     8ac:	8a c0       	rjmp	.+276    	; 0x9c2 <gc_execute_line+0x2c4>
     8ae:	46 c0       	rjmp	.+140    	; 0x93c <gc_execute_line+0x23e>
     8b0:	6e 31       	cpi	r22, 0x1E	; 30
     8b2:	71 05       	cpc	r23, r1
     8b4:	c9 f0       	breq	.+50     	; 0x8e8 <gc_execute_line+0x1ea>
     8b6:	65 33       	cpi	r22, 0x35	; 53
     8b8:	71 05       	cpc	r23, r1
     8ba:	09 f0       	breq	.+2      	; 0x8be <gc_execute_line+0x1c0>
     8bc:	82 c0       	rjmp	.+260    	; 0x9c2 <gc_execute_line+0x2c4>
     8be:	41 c0       	rjmp	.+130    	; 0x942 <gc_execute_line+0x244>
     8c0:	6b 35       	cpi	r22, 0x5B	; 91
     8c2:	71 05       	cpc	r23, r1
     8c4:	09 f4       	brne	.+2      	; 0x8c8 <gc_execute_line+0x1ca>
     8c6:	46 c0       	rjmp	.+140    	; 0x954 <gc_execute_line+0x256>
     8c8:	6c 35       	cpi	r22, 0x5C	; 92
     8ca:	71 05       	cpc	r23, r1
     8cc:	2c f4       	brge	.+10     	; 0x8d8 <gc_execute_line+0x1da>
     8ce:	6a 35       	cpi	r22, 0x5A	; 90
     8d0:	71 05       	cpc	r23, r1
     8d2:	09 f0       	breq	.+2      	; 0x8d6 <gc_execute_line+0x1d8>
     8d4:	76 c0       	rjmp	.+236    	; 0x9c2 <gc_execute_line+0x2c4>
     8d6:	3b c0       	rjmp	.+118    	; 0x94e <gc_execute_line+0x250>
     8d8:	6d 35       	cpi	r22, 0x5D	; 93
     8da:	71 05       	cpc	r23, r1
     8dc:	f1 f1       	breq	.+124    	; 0x95a <gc_execute_line+0x25c>
     8de:	6e 35       	cpi	r22, 0x5E	; 94
     8e0:	71 05       	cpc	r23, r1
     8e2:	09 f0       	breq	.+2      	; 0x8e6 <gc_execute_line+0x1e8>
     8e4:	6e c0       	rjmp	.+220    	; 0x9c2 <gc_execute_line+0x2c4>
     8e6:	3c c0       	rjmp	.+120    	; 0x960 <gc_execute_line+0x262>
     8e8:	b2 e0       	ldi	r27, 0x02	; 2
     8ea:	b9 ab       	std	Y+49, r27	; 0x31
     8ec:	73 c0       	rjmp	.+230    	; 0x9d4 <gc_execute_line+0x2d6>
     8ee:	e1 e0       	ldi	r30, 0x01	; 1
     8f0:	e9 ab       	std	Y+49, r30	; 0x31
     8f2:	70 c0       	rjmp	.+224    	; 0x9d4 <gc_execute_line+0x2d6>
					case 0: gc.motion_mode = MOTION_MODE_RAPID_LINEAR; break;
     8f4:	10 92 4f 20 	sts	0x204F, r1
     8f8:	6d c0       	rjmp	.+218    	; 0x9d4 <gc_execute_line+0x2d6>
					case 1: gc.motion_mode = MOTION_MODE_LINEAR; break;
     8fa:	d0 92 4f 20 	sts	0x204F, r13
     8fe:	6a c0       	rjmp	.+212    	; 0x9d4 <gc_execute_line+0x2d6>
					case 2: gc.motion_mode = MOTION_MODE_CW_ARC; break;
     900:	c0 92 4f 20 	sts	0x204F, r12
     904:	67 c0       	rjmp	.+206    	; 0x9d4 <gc_execute_line+0x2d6>
					case 3: gc.motion_mode = MOTION_MODE_CCW_ARC; break;
     906:	90 92 4f 20 	sts	0x204F, r9
     90a:	64 c0       	rjmp	.+200    	; 0x9d4 <gc_execute_line+0x2d6>

void select_plane(uint8_t axis_0, uint8_t axis_1, uint8_t axis_2) 

/* gc_init() */
{
	gc.plane_axis_0 = axis_0;
     90c:	10 92 6d 20 	sts	0x206D, r1
	gc.plane_axis_1 = axis_1;
     910:	d0 92 6e 20 	sts	0x206E, r13
	gc.plane_axis_2 = axis_2;
     914:	c0 92 6f 20 	sts	0x206F, r12
     918:	5d c0       	rjmp	.+186    	; 0x9d4 <gc_execute_line+0x2d6>

void select_plane(uint8_t axis_0, uint8_t axis_1, uint8_t axis_2) 

/* gc_init() */
{
	gc.plane_axis_0 = axis_0;
     91a:	10 92 6d 20 	sts	0x206D, r1
	gc.plane_axis_1 = axis_1;
     91e:	c0 92 6e 20 	sts	0x206E, r12
	gc.plane_axis_2 = axis_2;
     922:	d0 92 6f 20 	sts	0x206F, r13
     926:	56 c0       	rjmp	.+172    	; 0x9d4 <gc_execute_line+0x2d6>

void select_plane(uint8_t axis_0, uint8_t axis_1, uint8_t axis_2) 

/* gc_init() */
{
	gc.plane_axis_0 = axis_0;
     928:	d0 92 6d 20 	sts	0x206D, r13
	gc.plane_axis_1 = axis_1;
     92c:	c0 92 6e 20 	sts	0x206E, r12
	gc.plane_axis_2 = axis_2;
     930:	10 92 6f 20 	sts	0x206F, r1
     934:	4f c0       	rjmp	.+158    	; 0x9d4 <gc_execute_line+0x2d6>
					case 3: gc.motion_mode = MOTION_MODE_CCW_ARC; break;
					case 4: next_action = NEXT_ACTION_DWELL; break;
					case 17: select_plane(X_AXIS, Y_AXIS, Z_AXIS); break;
					case 18: select_plane(X_AXIS, Z_AXIS, Y_AXIS); break;
					case 19: select_plane(Y_AXIS, Z_AXIS, X_AXIS); break;
					case 20: gc.inches_mode = TRUE; break;
     936:	d0 92 51 20 	sts	0x2051, r13
     93a:	4c c0       	rjmp	.+152    	; 0x9d4 <gc_execute_line+0x2d6>
					case 21: gc.inches_mode = FALSE; break;
     93c:	10 92 51 20 	sts	0x2051, r1
     940:	49 c0       	rjmp	.+146    	; 0x9d4 <gc_execute_line+0x2d6>
     942:	f1 e0       	ldi	r31, 0x01	; 1
     944:	fa ab       	std	Y+50, r31	; 0x32
     946:	46 c0       	rjmp	.+140    	; 0x9d4 <gc_execute_line+0x2d6>
					case 28: case 30: next_action = NEXT_ACTION_GO_HOME; break;
					case 53: absolute_override = TRUE; break;
					case 80: gc.motion_mode = MOTION_MODE_CANCEL; break;
     948:	80 92 4f 20 	sts	0x204F, r8
     94c:	43 c0       	rjmp	.+134    	; 0x9d4 <gc_execute_line+0x2d6>
					case 90: gc.absolute_mode = TRUE; break;
     94e:	d0 92 52 20 	sts	0x2052, r13
     952:	40 c0       	rjmp	.+128    	; 0x9d4 <gc_execute_line+0x2d6>
					case 91: gc.absolute_mode = FALSE; break;
     954:	10 92 52 20 	sts	0x2052, r1
     958:	3d c0       	rjmp	.+122    	; 0x9d4 <gc_execute_line+0x2d6>
					case 93: gc.inverse_feed_rate_mode = TRUE; break;
     95a:	d0 92 50 20 	sts	0x2050, r13
     95e:	3a c0       	rjmp	.+116    	; 0x9d4 <gc_execute_line+0x2d6>
					case 94: gc.inverse_feed_rate_mode = FALSE; break;
     960:	10 92 50 20 	sts	0x2050, r1
     964:	37 c0       	rjmp	.+110    	; 0x9d4 <gc_execute_line+0x2d6>
					default: FAIL(GCSTATUS_UNSUPPORTED_STATEMENT);
				}
				break;
      
			case 'M':
				switch(int_value) {
     966:	63 30       	cpi	r22, 0x03	; 3
     968:	71 05       	cpc	r23, r1
     96a:	e1 f0       	breq	.+56     	; 0x9a4 <gc_execute_line+0x2a6>
     96c:	64 30       	cpi	r22, 0x04	; 4
     96e:	71 05       	cpc	r23, r1
     970:	34 f4       	brge	.+12     	; 0x97e <gc_execute_line+0x280>
     972:	77 fd       	sbrc	r23, 7
     974:	26 c0       	rjmp	.+76     	; 0x9c2 <gc_execute_line+0x2c4>
     976:	62 30       	cpi	r22, 0x02	; 2
     978:	71 05       	cpc	r23, r1
     97a:	74 f0       	brlt	.+28     	; 0x998 <gc_execute_line+0x29a>
     97c:	10 c0       	rjmp	.+32     	; 0x99e <gc_execute_line+0x2a0>
     97e:	65 30       	cpi	r22, 0x05	; 5
     980:	71 05       	cpc	r23, r1
     982:	d1 f0       	breq	.+52     	; 0x9b8 <gc_execute_line+0x2ba>
     984:	65 30       	cpi	r22, 0x05	; 5
     986:	71 05       	cpc	r23, r1
     988:	94 f0       	brlt	.+36     	; 0x9ae <gc_execute_line+0x2b0>
     98a:	6e 31       	cpi	r22, 0x1E	; 30
     98c:	71 05       	cpc	r23, r1
     98e:	39 f0       	breq	.+14     	; 0x99e <gc_execute_line+0x2a0>
     990:	6c 33       	cpi	r22, 0x3C	; 60
     992:	71 05       	cpc	r23, r1
     994:	b1 f4       	brne	.+44     	; 0x9c2 <gc_execute_line+0x2c4>
     996:	03 c0       	rjmp	.+6      	; 0x99e <gc_execute_line+0x2a0>
					case 0: case 1: gc.program_flow = PROGRAM_FLOW_PAUSED; break;
     998:	d0 92 53 20 	sts	0x2053, r13
     99c:	1b c0       	rjmp	.+54     	; 0x9d4 <gc_execute_line+0x2d6>
					case 2: case 30: case 60: gc.program_flow = PROGRAM_FLOW_COMPLETED; break;
     99e:	c0 92 53 20 	sts	0x2053, r12
     9a2:	18 c0       	rjmp	.+48     	; 0x9d4 <gc_execute_line+0x2d6>
					case 3: gc.spindle_direction = 1; break;
     9a4:	40 92 54 20 	sts	0x2054, r4
     9a8:	50 92 55 20 	sts	0x2055, r5
     9ac:	13 c0       	rjmp	.+38     	; 0x9d4 <gc_execute_line+0x2d6>
					case 4: gc.spindle_direction = -1; break;
     9ae:	60 92 54 20 	sts	0x2054, r6
     9b2:	70 92 55 20 	sts	0x2055, r7
     9b6:	0e c0       	rjmp	.+28     	; 0x9d4 <gc_execute_line+0x2d6>
					case 5: gc.spindle_direction = 0; break;
     9b8:	10 92 54 20 	sts	0x2054, r1
     9bc:	10 92 55 20 	sts	0x2055, r1
     9c0:	09 c0       	rjmp	.+18     	; 0x9d4 <gc_execute_line+0x2d6>
        			default: FAIL(GCSTATUS_UNSUPPORTED_STATEMENT);
     9c2:	90 92 4e 20 	sts	0x204E, r9
     9c6:	06 c0       	rjmp	.+12     	; 0x9d4 <gc_execute_line+0x2d6>
				}
				break;

			case 'T': gc.tool = trunc(value); break;
     9c8:	c8 01       	movw	r24, r16
     9ca:	b7 01       	movw	r22, r14
     9cc:	0e 94 24 19 	call	0x3248	; 0x3248 <__fixunssfsi>
     9d0:	60 93 6a 20 	sts	0x206A, r22
		}
		if(gc.status_code) {
     9d4:	80 91 4e 20 	lds	r24, 0x204E
     9d8:	88 23       	and	r24, r24
     9da:	a9 f0       	breq	.+42     	; 0xa06 <gc_execute_line+0x308>
     9dc:	21 c0       	rjmp	.+66     	; 0xa20 <gc_execute_line+0x322>
     9de:	1a aa       	std	Y+50, r1	; 0x32
     9e0:	19 aa       	std	Y+49, r1	; 0x31
		}
    	store_setting(p, value);
  	}
  
  // Pass 1: Commands
	while(next_statement(&letter, &value, textline, &counter)) {
     9e2:	1e 01       	movw	r2, r28
     9e4:	08 94       	sec
     9e6:	21 1c       	adc	r2, r1
     9e8:	31 1c       	adc	r3, r1
      
			case 'M':
				switch(int_value) {
					case 0: case 1: gc.program_flow = PROGRAM_FLOW_PAUSED; break;
					case 2: case 30: case 60: gc.program_flow = PROGRAM_FLOW_COMPLETED; break;
					case 3: gc.spindle_direction = 1; break;
     9ea:	31 e0       	ldi	r19, 0x01	; 1
     9ec:	43 2e       	mov	r4, r19
     9ee:	51 2c       	mov	r5, r1
					case 4: gc.spindle_direction = -1; break;
					case 5: gc.spindle_direction = 0; break;
        			default: FAIL(GCSTATUS_UNSUPPORTED_STATEMENT);
     9f0:	23 e0       	ldi	r18, 0x03	; 3
     9f2:	92 2e       	mov	r9, r18
				break;
      
			case 'M':
				switch(int_value) {
					case 0: case 1: gc.program_flow = PROGRAM_FLOW_PAUSED; break;
					case 2: case 30: case 60: gc.program_flow = PROGRAM_FLOW_COMPLETED; break;
     9f4:	92 e0       	ldi	r25, 0x02	; 2
     9f6:	c9 2e       	mov	r12, r25
					case 3: gc.spindle_direction = 1; break;
					case 4: gc.spindle_direction = -1; break;
     9f8:	66 24       	eor	r6, r6
     9fa:	6a 94       	dec	r6
     9fc:	76 2c       	mov	r7, r6
				}
				break;
      
			case 'M':
				switch(int_value) {
					case 0: case 1: gc.program_flow = PROGRAM_FLOW_PAUSED; break;
     9fe:	dd 24       	eor	r13, r13
     a00:	d3 94       	inc	r13
					case 19: select_plane(Y_AXIS, Z_AXIS, X_AXIS); break;
					case 20: gc.inches_mode = TRUE; break;
					case 21: gc.inches_mode = FALSE; break;
					case 28: case 30: next_action = NEXT_ACTION_GO_HOME; break;
					case 53: absolute_override = TRUE; break;
					case 80: gc.motion_mode = MOTION_MODE_CANCEL; break;
     a02:	84 e0       	ldi	r24, 0x04	; 4
     a04:	88 2e       	mov	r8, r24
		}
    	store_setting(p, value);
  	}
  
  // Pass 1: Commands
	while(next_statement(&letter, &value, textline, &counter)) {
     a06:	c1 01       	movw	r24, r2
     a08:	be 01       	movw	r22, r28
     a0a:	6c 5f       	subi	r22, 0xFC	; 252
     a0c:	7f 4f       	sbci	r23, 0xFF	; 255
     a0e:	a5 01       	movw	r20, r10
     a10:	9e 01       	movw	r18, r28
     a12:	2e 5f       	subi	r18, 0xFE	; 254
     a14:	3f 4f       	sbci	r19, 0xFF	; 255
     a16:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <next_statement>
     a1a:	89 2b       	or	r24, r25
     a1c:	09 f0       	breq	.+2      	; 0xa20 <gc_execute_line+0x322>
     a1e:	f2 ce       	rjmp	.-540    	; 0x804 <gc_execute_line+0x106>
			break;
		}
	}
  
  // If there were any errors parsing this line, we will return right away with the bad news
	if (gc.status_code) { 
     a20:	80 91 4e 20 	lds	r24, 0x204E
     a24:	88 23       	and	r24, r24
     a26:	09 f0       	breq	.+2      	; 0xa2a <gc_execute_line+0x32c>
     a28:	83 c3       	rjmp	.+1798   	; 0x1130 <gc_execute_line+0xa32>
		return(gc.status_code); 
	}

	counter = 0;
     a2a:	1a 82       	std	Y+2, r1	; 0x02
     a2c:	1b 82       	std	Y+3, r1	; 0x03
	clear_vector(offset);
     a2e:	8c e0       	ldi	r24, 0x0C	; 12
     a30:	fe 01       	movw	r30, r28
     a32:	78 96       	adiw	r30, 0x18	; 24
     a34:	df 01       	movw	r26, r30
     a36:	1d 92       	st	X+, r1
     a38:	8a 95       	dec	r24
     a3a:	e9 f7       	brne	.-6      	; 0xa36 <gc_execute_line+0x338>
	memcpy(target, gc.position, sizeof(target)); // target = gc.position
     a3c:	de 01       	movw	r26, r28
     a3e:	1c 96       	adiw	r26, 0x0c	; 12
     a40:	ee e5       	ldi	r30, 0x5E	; 94
     a42:	f0 e2       	ldi	r31, 0x20	; 32
     a44:	8c e0       	ldi	r24, 0x0C	; 12
     a46:	01 90       	ld	r0, Z+
     a48:	0d 92       	st	X+, r0
     a4a:	81 50       	subi	r24, 0x01	; 1
     a4c:	e1 f7       	brne	.-8      	; 0xa46 <gc_execute_line+0x348>
     a4e:	1b ae       	std	Y+59, r1	; 0x3b
     a50:	1c ae       	std	Y+60, r1	; 0x3c
     a52:	b0 e8       	ldi	r27, 0x80	; 128
     a54:	bd af       	std	Y+61, r27	; 0x3d
     a56:	ef eb       	ldi	r30, 0xBF	; 191
     a58:	ee af       	std	Y+62, r30	; 0x3e
     a5a:	66 24       	eor	r6, r6
     a5c:	77 24       	eor	r7, r7
     a5e:	60 e0       	ldi	r22, 0x00	; 0
     a60:	70 e0       	ldi	r23, 0x00	; 0
     a62:	80 e0       	ldi	r24, 0x00	; 0
     a64:	90 e0       	ldi	r25, 0x00	; 0
     a66:	6d a7       	std	Y+45, r22	; 0x2d
     a68:	7e a7       	std	Y+46, r23	; 0x2e
     a6a:	8f a7       	std	Y+47, r24	; 0x2f
     a6c:	98 ab       	std	Y+48, r25	; 0x30

  // Pass 2: Parameters
	while(next_statement(&letter, &value, textline, &counter)) {
     a6e:	04 e0       	ldi	r16, 0x04	; 4
     a70:	20 2e       	mov	r2, r16
     a72:	31 2c       	mov	r3, r1
     a74:	2c 0e       	add	r2, r28
     a76:	3d 1e       	adc	r3, r29
     a78:	12 e0       	ldi	r17, 0x02	; 2
     a7a:	41 2e       	mov	r4, r17
     a7c:	51 2c       	mov	r5, r1
     a7e:	4c 0e       	add	r4, r28
     a80:	5d 1e       	adc	r5, r29
     a82:	4e 01       	movw	r8, r28
     a84:	08 94       	sec
     a86:	81 1c       	adc	r8, r1
     a88:	91 1c       	adc	r9, r1
     a8a:	a1 c0       	rjmp	.+322    	; 0xbce <gc_execute_line+0x4d0>
		int_value = trunc(value);
		unit_converted_value = to_millimeters(value);
     a8c:	cc 80       	ldd	r12, Y+4	; 0x04
     a8e:	dd 80       	ldd	r13, Y+5	; 0x05
     a90:	ee 80       	ldd	r14, Y+6	; 0x06
     a92:	ff 80       	ldd	r15, Y+7	; 0x07
}


inline float to_millimeters(double value) 
{
	return(gc.inches_mode ? (value * INCHES_PER_MM) : value);
     a94:	80 91 51 20 	lds	r24, 0x2051
     a98:	88 23       	and	r24, r24
     a9a:	19 f4       	brne	.+6      	; 0xaa2 <gc_execute_line+0x3a4>
     a9c:	a7 01       	movw	r20, r14
     a9e:	96 01       	movw	r18, r12
     aa0:	0a c0       	rjmp	.+20     	; 0xab6 <gc_execute_line+0x3b8>
     aa2:	c7 01       	movw	r24, r14
     aa4:	b6 01       	movw	r22, r12
     aa6:	25 e8       	ldi	r18, 0x85	; 133
     aa8:	32 e4       	ldi	r19, 0x42	; 66
     aaa:	41 e2       	ldi	r20, 0x21	; 33
     aac:	5d e3       	ldi	r21, 0x3D	; 61
     aae:	0e 94 a5 1b 	call	0x374a	; 0x374a <__mulsf3>
     ab2:	9b 01       	movw	r18, r22
     ab4:	ac 01       	movw	r20, r24

  // Pass 2: Parameters
	while(next_statement(&letter, &value, textline, &counter)) {
		int_value = trunc(value);
		unit_converted_value = to_millimeters(value);
		switch(letter) {
     ab6:	09 81       	ldd	r16, Y+1	; 0x01
     ab8:	00 35       	cpi	r16, 0x50	; 80
     aba:	09 f4       	brne	.+2      	; 0xabe <gc_execute_line+0x3c0>
     abc:	4d c0       	rjmp	.+154    	; 0xb58 <gc_execute_line+0x45a>
     abe:	01 35       	cpi	r16, 0x51	; 81
     ac0:	58 f4       	brcc	.+22     	; 0xad8 <gc_execute_line+0x3da>
     ac2:	06 34       	cpi	r16, 0x46	; 70
     ac4:	01 f1       	breq	.+64     	; 0xb06 <gc_execute_line+0x408>
     ac6:	06 34       	cpi	r16, 0x46	; 70
     ac8:	08 f4       	brcc	.+2      	; 0xacc <gc_execute_line+0x3ce>
     aca:	81 c0       	rjmp	.+258    	; 0xbce <gc_execute_line+0x4d0>
     acc:	80 2f       	mov	r24, r16
     ace:	89 54       	subi	r24, 0x49	; 73
     ad0:	83 30       	cpi	r24, 0x03	; 3
     ad2:	08 f0       	brcs	.+2      	; 0xad6 <gc_execute_line+0x3d8>
     ad4:	7c c0       	rjmp	.+248    	; 0xbce <gc_execute_line+0x4d0>
     ad6:	31 c0       	rjmp	.+98     	; 0xb3a <gc_execute_line+0x43c>
     ad8:	03 35       	cpi	r16, 0x53	; 83
     ada:	09 f4       	brne	.+2      	; 0xade <gc_execute_line+0x3e0>
     adc:	42 c0       	rjmp	.+132    	; 0xb62 <gc_execute_line+0x464>
     ade:	04 35       	cpi	r16, 0x54	; 84
     ae0:	20 f4       	brcc	.+8      	; 0xaea <gc_execute_line+0x3ec>
     ae2:	02 35       	cpi	r16, 0x52	; 82
     ae4:	09 f0       	breq	.+2      	; 0xae8 <gc_execute_line+0x3ea>
     ae6:	73 c0       	rjmp	.+230    	; 0xbce <gc_execute_line+0x4d0>
     ae8:	06 c0       	rjmp	.+12     	; 0xaf6 <gc_execute_line+0x3f8>
     aea:	80 2f       	mov	r24, r16
     aec:	88 55       	subi	r24, 0x58	; 88
     aee:	83 30       	cpi	r24, 0x03	; 3
     af0:	08 f0       	brcs	.+2      	; 0xaf4 <gc_execute_line+0x3f6>
     af2:	6d c0       	rjmp	.+218    	; 0xbce <gc_execute_line+0x4d0>
     af4:	3f c0       	rjmp	.+126    	; 0xb74 <gc_execute_line+0x476>
     af6:	2d a7       	std	Y+45, r18	; 0x2d
     af8:	3e a7       	std	Y+46, r19	; 0x2e
     afa:	4f a7       	std	Y+47, r20	; 0x2f
     afc:	58 ab       	std	Y+48, r21	; 0x30
     afe:	b1 e0       	ldi	r27, 0x01	; 1
     b00:	6b 2e       	mov	r6, r27
     b02:	71 2c       	mov	r7, r1
     b04:	64 c0       	rjmp	.+200    	; 0xbce <gc_execute_line+0x4d0>
			case 'F': 
				if (gc.inverse_feed_rate_mode) {
     b06:	80 91 50 20 	lds	r24, 0x2050
     b0a:	88 23       	and	r24, r24
     b0c:	29 f0       	breq	.+10     	; 0xb18 <gc_execute_line+0x41a>
     b0e:	2b af       	std	Y+59, r18	; 0x3b
     b10:	3c af       	std	Y+60, r19	; 0x3c
     b12:	4d af       	std	Y+61, r20	; 0x3d
     b14:	5e af       	std	Y+62, r21	; 0x3e
     b16:	5b c0       	rjmp	.+182    	; 0xbce <gc_execute_line+0x4d0>
					inverse_feed_rate = unit_converted_value; // seconds per motion for this motion only
				} else {
					gc.feed_rate = unit_converted_value/60; // millimeters pr second
     b18:	ca 01       	movw	r24, r20
     b1a:	b9 01       	movw	r22, r18
     b1c:	20 e0       	ldi	r18, 0x00	; 0
     b1e:	30 e0       	ldi	r19, 0x00	; 0
     b20:	40 e7       	ldi	r20, 0x70	; 112
     b22:	52 e4       	ldi	r21, 0x42	; 66
     b24:	0e 94 b7 18 	call	0x316e	; 0x316e <__divsf3>
     b28:	60 93 56 20 	sts	0x2056, r22
     b2c:	70 93 57 20 	sts	0x2057, r23
     b30:	80 93 58 20 	sts	0x2058, r24
     b34:	90 93 59 20 	sts	0x2059, r25
     b38:	4a c0       	rjmp	.+148    	; 0xbce <gc_execute_line+0x4d0>
				}
				break;
			case 'I': case 'J': case 'K': offset[letter-'I'] = unit_converted_value; break;
     b3a:	e0 2f       	mov	r30, r16
     b3c:	f0 e0       	ldi	r31, 0x00	; 0
     b3e:	e9 54       	subi	r30, 0x49	; 73
     b40:	f0 40       	sbci	r31, 0x00	; 0
     b42:	ee 0f       	add	r30, r30
     b44:	ff 1f       	adc	r31, r31
     b46:	ee 0f       	add	r30, r30
     b48:	ff 1f       	adc	r31, r31
     b4a:	e8 0d       	add	r30, r8
     b4c:	f9 1d       	adc	r31, r9
     b4e:	27 8b       	std	Z+23, r18	; 0x17
     b50:	30 8f       	std	Z+24, r19	; 0x18
     b52:	41 8f       	std	Z+25, r20	; 0x19
     b54:	52 8f       	std	Z+26, r21	; 0x1a
     b56:	3b c0       	rjmp	.+118    	; 0xbce <gc_execute_line+0x4d0>
			case 'P': p = value; break;
     b58:	c8 86       	std	Y+8, r12	; 0x08
     b5a:	d9 86       	std	Y+9, r13	; 0x09
     b5c:	ea 86       	std	Y+10, r14	; 0x0a
     b5e:	fb 86       	std	Y+11, r15	; 0x0b
     b60:	36 c0       	rjmp	.+108    	; 0xbce <gc_execute_line+0x4d0>
			case 'R': r = unit_converted_value; radius_mode = TRUE; break;
			case 'S': gc.spindle_speed = value; break;
     b62:	c7 01       	movw	r24, r14
     b64:	b6 01       	movw	r22, r12
     b66:	0e 94 1f 19 	call	0x323e	; 0x323e <__fixsfsi>
     b6a:	60 93 6b 20 	sts	0x206B, r22
     b6e:	70 93 6c 20 	sts	0x206C, r23
     b72:	2d c0       	rjmp	.+90     	; 0xbce <gc_execute_line+0x4d0>
			case 'X': case 'Y': case 'Z':
				if (gc.absolute_mode || absolute_override) {
     b74:	80 91 52 20 	lds	r24, 0x2052
     b78:	88 23       	and	r24, r24
     b7a:	19 f4       	brne	.+6      	; 0xb82 <gc_execute_line+0x484>
     b7c:	7a a9       	ldd	r23, Y+50	; 0x32
     b7e:	77 23       	and	r23, r23
     b80:	79 f0       	breq	.+30     	; 0xba0 <gc_execute_line+0x4a2>
					target[letter - 'X'] = unit_converted_value;
     b82:	e0 2f       	mov	r30, r16
     b84:	f0 e0       	ldi	r31, 0x00	; 0
     b86:	e8 55       	subi	r30, 0x58	; 88
     b88:	f0 40       	sbci	r31, 0x00	; 0
     b8a:	ee 0f       	add	r30, r30
     b8c:	ff 1f       	adc	r31, r31
     b8e:	ee 0f       	add	r30, r30
     b90:	ff 1f       	adc	r31, r31
     b92:	e8 0d       	add	r30, r8
     b94:	f9 1d       	adc	r31, r9
     b96:	23 87       	std	Z+11, r18	; 0x0b
     b98:	34 87       	std	Z+12, r19	; 0x0c
     b9a:	45 87       	std	Z+13, r20	; 0x0d
     b9c:	56 87       	std	Z+14, r21	; 0x0e
     b9e:	17 c0       	rjmp	.+46     	; 0xbce <gc_execute_line+0x4d0>
				} else {
					target[letter - 'X'] += unit_converted_value;
     ba0:	10 e0       	ldi	r17, 0x00	; 0
     ba2:	08 55       	subi	r16, 0x58	; 88
     ba4:	10 40       	sbci	r17, 0x00	; 0
     ba6:	00 0f       	add	r16, r16
     ba8:	11 1f       	adc	r17, r17
     baa:	00 0f       	add	r16, r16
     bac:	11 1f       	adc	r17, r17
     bae:	08 0d       	add	r16, r8
     bb0:	19 1d       	adc	r17, r9
     bb2:	d8 01       	movw	r26, r16
     bb4:	1b 96       	adiw	r26, 0x0b	; 11
     bb6:	6d 91       	ld	r22, X+
     bb8:	7d 91       	ld	r23, X+
     bba:	8d 91       	ld	r24, X+
     bbc:	9c 91       	ld	r25, X
     bbe:	1e 97       	sbiw	r26, 0x0e	; 14
     bc0:	0e 94 11 18 	call	0x3022	; 0x3022 <__addsf3>
     bc4:	f8 01       	movw	r30, r16
     bc6:	63 87       	std	Z+11, r22	; 0x0b
     bc8:	74 87       	std	Z+12, r23	; 0x0c
     bca:	85 87       	std	Z+13, r24	; 0x0d
     bcc:	96 87       	std	Z+14, r25	; 0x0e
	counter = 0;
	clear_vector(offset);
	memcpy(target, gc.position, sizeof(target)); // target = gc.position

  // Pass 2: Parameters
	while(next_statement(&letter, &value, textline, &counter)) {
     bce:	c4 01       	movw	r24, r8
     bd0:	b1 01       	movw	r22, r2
     bd2:	a5 01       	movw	r20, r10
     bd4:	92 01       	movw	r18, r4
     bd6:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <next_statement>
     bda:	89 2b       	or	r24, r25
     bdc:	09 f0       	breq	.+2      	; 0xbe0 <gc_execute_line+0x4e2>
     bde:	56 cf       	rjmp	.-340    	; 0xa8c <gc_execute_line+0x38e>
 				break;
		}	
	}
  
  // If there were any errors parsing this line, we will return right away with the bad news
	 if (gc.status_code) {
     be0:	80 91 4e 20 	lds	r24, 0x204E
     be4:	88 23       	and	r24, r24
     be6:	09 f0       	breq	.+2      	; 0xbea <gc_execute_line+0x4ec>
     be8:	a3 c2       	rjmp	.+1350   	; 0x1130 <gc_execute_line+0xa32>
		return(gc.status_code); 
	}
    
  // Update spindle state
	if (gc.spindle_direction) {
     bea:	80 91 54 20 	lds	r24, 0x2054
     bee:	90 91 55 20 	lds	r25, 0x2055
     bf2:	00 97       	sbiw	r24, 0x00	; 0
     bf4:	59 f0       	breq	.+22     	; 0xc0c <gc_execute_line+0x50e>
    	spindle_run(gc.spindle_direction, gc.spindle_speed);
     bf6:	40 91 6b 20 	lds	r20, 0x206B
     bfa:	50 91 6c 20 	lds	r21, 0x206C
     bfe:	66 27       	eor	r22, r22
     c00:	57 fd       	sbrc	r21, 7
     c02:	60 95       	com	r22
     c04:	76 2f       	mov	r23, r22
     c06:	0e 94 ae 0f 	call	0x1f5c	; 0x1f5c <spindle_run>
     c0a:	02 c0       	rjmp	.+4      	; 0xc10 <gc_execute_line+0x512>
	} else {
		spindle_stop();\
     c0c:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <spindle_stop>
	}
  
  // Perform any physical actions
	switch (next_action) {
     c10:	f9 a9       	ldd	r31, Y+49	; 0x31
     c12:	f1 30       	cpi	r31, 0x01	; 1
     c14:	41 f0       	breq	.+16     	; 0xc26 <gc_execute_line+0x528>
     c16:	f1 30       	cpi	r31, 0x01	; 1
     c18:	a8 f0       	brcs	.+42     	; 0xc44 <gc_execute_line+0x546>
     c1a:	f2 30       	cpi	r31, 0x02	; 2
     c1c:	09 f0       	breq	.+2      	; 0xc20 <gc_execute_line+0x522>
     c1e:	7b c2       	rjmp	.+1270   	; 0x1116 <gc_execute_line+0xa18>
    	case NEXT_ACTION_GO_HOME: mc_go_home(); break;
     c20:	0e 94 e6 0b 	call	0x17cc	; 0x17cc <mc_go_home>
     c24:	78 c2       	rjmp	.+1264   	; 0x1116 <gc_execute_line+0xa18>
		case NEXT_ACTION_DWELL: mc_dwell(trunc(p*1000)); break;
     c26:	68 85       	ldd	r22, Y+8	; 0x08
     c28:	79 85       	ldd	r23, Y+9	; 0x09
     c2a:	8a 85       	ldd	r24, Y+10	; 0x0a
     c2c:	9b 85       	ldd	r25, Y+11	; 0x0b
     c2e:	20 e0       	ldi	r18, 0x00	; 0
     c30:	30 e0       	ldi	r19, 0x00	; 0
     c32:	4a e7       	ldi	r20, 0x7A	; 122
     c34:	54 e4       	ldi	r21, 0x44	; 68
     c36:	0e 94 a5 1b 	call	0x374a	; 0x374a <__mulsf3>
     c3a:	0e 94 24 19 	call	0x3248	; 0x3248 <__fixunssfsi>
     c3e:	0e 94 ce 0e 	call	0x1d9c	; 0x1d9c <mc_dwell>
     c42:	69 c2       	rjmp	.+1234   	; 0x1116 <gc_execute_line+0xa18>
		case NEXT_ACTION_DEFAULT: 
 		switch (gc.motion_mode) {
     c44:	b0 90 4f 20 	lds	r11, 0x204F
     c48:	21 e0       	ldi	r18, 0x01	; 1
     c4a:	2b 15       	cp	r18, r11
     c4c:	28 f4       	brcc	.+10     	; 0xc58 <gc_execute_line+0x55a>
     c4e:	33 e0       	ldi	r19, 0x03	; 3
     c50:	3b 15       	cp	r19, r11
     c52:	08 f4       	brcc	.+2      	; 0xc56 <gc_execute_line+0x558>
     c54:	60 c2       	rjmp	.+1216   	; 0x1116 <gc_execute_line+0xa18>
     c56:	1e c0       	rjmp	.+60     	; 0xc94 <gc_execute_line+0x596>
			case MOTION_MODE_CANCEL: break;
			case MOTION_MODE_RAPID_LINEAR:
			case MOTION_MODE_LINEAR:
				mc_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], 
     c58:	6c 85       	ldd	r22, Y+12	; 0x0c
     c5a:	7d 85       	ldd	r23, Y+13	; 0x0d
     c5c:	8e 85       	ldd	r24, Y+14	; 0x0e
     c5e:	9f 85       	ldd	r25, Y+15	; 0x0f
     c60:	28 89       	ldd	r18, Y+16	; 0x10
     c62:	39 89       	ldd	r19, Y+17	; 0x11
     c64:	4a 89       	ldd	r20, Y+18	; 0x12
     c66:	5b 89       	ldd	r21, Y+19	; 0x13
     c68:	ec 88       	ldd	r14, Y+20	; 0x14
     c6a:	fd 88       	ldd	r15, Y+21	; 0x15
     c6c:	0e 89       	ldd	r16, Y+22	; 0x16
     c6e:	1f 89       	ldd	r17, Y+23	; 0x17
     c70:	80 90 50 20 	lds	r8, 0x2050
     c74:	88 20       	and	r8, r8
     c76:	09 f0       	breq	.+2      	; 0xc7a <gc_execute_line+0x57c>
     c78:	45 c2       	rjmp	.+1162   	; 0x1104 <gc_execute_line+0xa06>
     c7a:	a0 91 56 20 	lds	r26, 0x2056
     c7e:	ab af       	std	Y+59, r26	; 0x3b
     c80:	b0 91 57 20 	lds	r27, 0x2057
     c84:	bc af       	std	Y+60, r27	; 0x3c
     c86:	e0 91 58 20 	lds	r30, 0x2058
     c8a:	ed af       	std	Y+61, r30	; 0x3d
     c8c:	f0 91 59 20 	lds	r31, 0x2059
     c90:	fe af       	std	Y+62, r31	; 0x3e
     c92:	38 c2       	rjmp	.+1136   	; 0x1104 <gc_execute_line+0xa06>
						(gc.inverse_feed_rate_mode) ? 
						inverse_feed_rate : gc.feed_rate, gc.inverse_feed_rate_mode);
			break;
			case MOTION_MODE_CW_ARC: case MOTION_MODE_CCW_ARC:
				if (radius_mode) {
     c94:	67 28       	or	r6, r7
     c96:	09 f4       	brne	.+2      	; 0xc9a <gc_execute_line+0x59c>
     c98:	e2 c0       	rjmp	.+452    	; 0xe5e <gc_execute_line+0x760>
          j = (y + (x * h_x2_div_d))/2
          
        */
        
        // Calculate the change in position along each selected axis
        double x = target[gc.plane_axis_0]-gc.position[gc.plane_axis_0];
     c9a:	e0 91 6d 20 	lds	r30, 0x206D
     c9e:	f0 e0       	ldi	r31, 0x00	; 0
     ca0:	ee 0f       	add	r30, r30
     ca2:	ff 1f       	adc	r31, r31
     ca4:	ee 0f       	add	r30, r30
     ca6:	ff 1f       	adc	r31, r31
     ca8:	8e 01       	movw	r16, r28
     caa:	0f 5f       	subi	r16, 0xFF	; 255
     cac:	1f 4f       	sbci	r17, 0xFF	; 255
     cae:	d8 01       	movw	r26, r16
     cb0:	ae 0f       	add	r26, r30
     cb2:	bf 1f       	adc	r27, r31
     cb4:	e2 5a       	subi	r30, 0xA2	; 162
     cb6:	ff 4d       	sbci	r31, 0xDF	; 223
     cb8:	1b 96       	adiw	r26, 0x0b	; 11
     cba:	6d 91       	ld	r22, X+
     cbc:	7d 91       	ld	r23, X+
     cbe:	8d 91       	ld	r24, X+
     cc0:	9c 91       	ld	r25, X
     cc2:	1e 97       	sbiw	r26, 0x0e	; 14
     cc4:	20 81       	ld	r18, Z
     cc6:	31 81       	ldd	r19, Z+1	; 0x01
     cc8:	42 81       	ldd	r20, Z+2	; 0x02
     cca:	53 81       	ldd	r21, Z+3	; 0x03
     ccc:	0e 94 10 18 	call	0x3020	; 0x3020 <__subsf3>
     cd0:	1b 01       	movw	r2, r22
     cd2:	2c 01       	movw	r4, r24
        double y = target[gc.plane_axis_1]-gc.position[gc.plane_axis_1];
     cd4:	e0 91 6e 20 	lds	r30, 0x206E
     cd8:	f0 e0       	ldi	r31, 0x00	; 0
     cda:	ee 0f       	add	r30, r30
     cdc:	ff 1f       	adc	r31, r31
     cde:	ee 0f       	add	r30, r30
     ce0:	ff 1f       	adc	r31, r31
     ce2:	0e 0f       	add	r16, r30
     ce4:	1f 1f       	adc	r17, r31
     ce6:	e2 5a       	subi	r30, 0xA2	; 162
     ce8:	ff 4d       	sbci	r31, 0xDF	; 223
     cea:	d8 01       	movw	r26, r16
     cec:	1b 96       	adiw	r26, 0x0b	; 11
     cee:	6d 91       	ld	r22, X+
     cf0:	7d 91       	ld	r23, X+
     cf2:	8d 91       	ld	r24, X+
     cf4:	9c 91       	ld	r25, X
     cf6:	1e 97       	sbiw	r26, 0x0e	; 14
     cf8:	20 81       	ld	r18, Z
     cfa:	31 81       	ldd	r19, Z+1	; 0x01
     cfc:	42 81       	ldd	r20, Z+2	; 0x02
     cfe:	53 81       	ldd	r21, Z+3	; 0x03
     d00:	0e 94 10 18 	call	0x3020	; 0x3020 <__subsf3>
     d04:	3b 01       	movw	r6, r22
     d06:	4c 01       	movw	r8, r24
        
        clear_vector(&offset);
     d08:	18 8e       	std	Y+24, r1	; 0x18
     d0a:	19 8e       	std	Y+25, r1	; 0x19
        double h_x2_div_d = -sqrt(4 * r*r - x*x - y*y)/hypot(x,y); // == -(h * 2 / d)
     d0c:	6d a5       	ldd	r22, Y+45	; 0x2d
     d0e:	7e a5       	ldd	r23, Y+46	; 0x2e
     d10:	8f a5       	ldd	r24, Y+47	; 0x2f
     d12:	98 a9       	ldd	r25, Y+48	; 0x30
     d14:	20 e0       	ldi	r18, 0x00	; 0
     d16:	30 e0       	ldi	r19, 0x00	; 0
     d18:	40 e8       	ldi	r20, 0x80	; 128
     d1a:	50 e4       	ldi	r21, 0x40	; 64
     d1c:	0e 94 a5 1b 	call	0x374a	; 0x374a <__mulsf3>
     d20:	2d a5       	ldd	r18, Y+45	; 0x2d
     d22:	3e a5       	ldd	r19, Y+46	; 0x2e
     d24:	4f a5       	ldd	r20, Y+47	; 0x2f
     d26:	58 a9       	ldd	r21, Y+48	; 0x30
     d28:	0e 94 a5 1b 	call	0x374a	; 0x374a <__mulsf3>
     d2c:	7b 01       	movw	r14, r22
     d2e:	8c 01       	movw	r16, r24
     d30:	c2 01       	movw	r24, r4
     d32:	b1 01       	movw	r22, r2
     d34:	a2 01       	movw	r20, r4
     d36:	91 01       	movw	r18, r2
     d38:	0e 94 a5 1b 	call	0x374a	; 0x374a <__mulsf3>
     d3c:	9b 01       	movw	r18, r22
     d3e:	ac 01       	movw	r20, r24
     d40:	c8 01       	movw	r24, r16
     d42:	b7 01       	movw	r22, r14
     d44:	0e 94 10 18 	call	0x3020	; 0x3020 <__subsf3>
     d48:	7b 01       	movw	r14, r22
     d4a:	8c 01       	movw	r16, r24
     d4c:	c4 01       	movw	r24, r8
     d4e:	b3 01       	movw	r22, r6
     d50:	a4 01       	movw	r20, r8
     d52:	93 01       	movw	r18, r6
     d54:	0e 94 a5 1b 	call	0x374a	; 0x374a <__mulsf3>
     d58:	9b 01       	movw	r18, r22
     d5a:	ac 01       	movw	r20, r24
     d5c:	c8 01       	movw	r24, r16
     d5e:	b7 01       	movw	r22, r14
     d60:	0e 94 10 18 	call	0x3020	; 0x3020 <__subsf3>
     d64:	0e 94 32 1c 	call	0x3864	; 0x3864 <sqrt>
     d68:	7b 01       	movw	r14, r22
     d6a:	8c 01       	movw	r16, r24
     d6c:	c2 01       	movw	r24, r4
     d6e:	b1 01       	movw	r22, r2
     d70:	a4 01       	movw	r20, r8
     d72:	93 01       	movw	r18, r6
     d74:	0e 94 ad 1a 	call	0x355a	; 0x355a <hypot>
     d78:	9b 01       	movw	r18, r22
     d7a:	ac 01       	movw	r20, r24
     d7c:	17 fb       	bst	r17, 7
     d7e:	10 95       	com	r17
     d80:	17 f9       	bld	r17, 7
     d82:	10 95       	com	r17
     d84:	c8 01       	movw	r24, r16
     d86:	b7 01       	movw	r22, r14
     d88:	0e 94 b7 18 	call	0x316e	; 0x316e <__divsf3>
     d8c:	6b 01       	movw	r12, r22
     d8e:	7c 01       	movw	r14, r24
        // If r is smaller than d, the arc is now traversing the complex plane beyond the reach of any
        // real CNC, and thus - for practical reasons - we will terminate promptly:
        if(isnan(h_x2_div_d)) { FAIL(GCSTATUS_FLOATING_POINT_ERROR); return(gc.status_code); }
     d90:	a7 01       	movw	r20, r14
     d92:	96 01       	movw	r18, r12
     d94:	0e 94 7a 1c 	call	0x38f4	; 0x38f4 <__unordsf2>
     d98:	88 23       	and	r24, r24
     d9a:	21 f0       	breq	.+8      	; 0xda4 <gc_execute_line+0x6a6>
     d9c:	85 e0       	ldi	r24, 0x05	; 5
     d9e:	80 93 4e 20 	sts	0x204E, r24
     da2:	c6 c1       	rjmp	.+908    	; 0x1130 <gc_execute_line+0xa32>
        // Invert the sign of h_x2_div_d if the circle is counter clockwise (see sketch below)
        if (gc.motion_mode == MOTION_MODE_CCW_ARC) { h_x2_div_d = -h_x2_div_d; }
     da4:	b3 e0       	ldi	r27, 0x03	; 3
     da6:	bb 16       	cp	r11, r27
     da8:	21 f4       	brne	.+8      	; 0xdb2 <gc_execute_line+0x6b4>
     daa:	f7 fa       	bst	r15, 7
     dac:	f0 94       	com	r15
     dae:	f7 f8       	bld	r15, 7
     db0:	f0 94       	com	r15

        // Negative R is g-code-alese for "I want a circle with more than 180 degrees of travel" (go figure!), 
        // even though it is advised against ever generating such circles in a single line of g-code. By 
        // inverting the sign of h_x2_div_d the center of the circles is placed on the opposite side of the line of
        // travel and thus we get the unadvisably long arcs as prescribed.
        if (r < 0) { h_x2_div_d = -h_x2_div_d; }        
     db2:	6d a5       	ldd	r22, Y+45	; 0x2d
     db4:	7e a5       	ldd	r23, Y+46	; 0x2e
     db6:	8f a5       	ldd	r24, Y+47	; 0x2f
     db8:	98 a9       	ldd	r25, Y+48	; 0x30
     dba:	20 e0       	ldi	r18, 0x00	; 0
     dbc:	30 e0       	ldi	r19, 0x00	; 0
     dbe:	40 e0       	ldi	r20, 0x00	; 0
     dc0:	50 e0       	ldi	r21, 0x00	; 0
     dc2:	0e 94 b0 18 	call	0x3160	; 0x3160 <__cmpsf2>
     dc6:	88 23       	and	r24, r24
     dc8:	24 f4       	brge	.+8      	; 0xdd2 <gc_execute_line+0x6d4>
     dca:	f7 fa       	bst	r15, 7
     dcc:	f0 94       	com	r15
     dce:	f7 f8       	bld	r15, 7
     dd0:	f0 94       	com	r15
        // Complete the operation by calculating the actual center of the arc
        offset[gc.plane_axis_0] = (x-(y*h_x2_div_d))/2;
     dd2:	00 91 6d 20 	lds	r16, 0x206D
     dd6:	a0 2e       	mov	r10, r16
     dd8:	bb 24       	eor	r11, r11
     dda:	aa 0c       	add	r10, r10
     ddc:	bb 1c       	adc	r11, r11
     dde:	aa 0c       	add	r10, r10
     de0:	bb 1c       	adc	r11, r11
     de2:	8e 01       	movw	r16, r28
     de4:	0f 5f       	subi	r16, 0xFF	; 255
     de6:	1f 4f       	sbci	r17, 0xFF	; 255
     de8:	a0 0e       	add	r10, r16
     dea:	b1 1e       	adc	r11, r17
     dec:	c4 01       	movw	r24, r8
     dee:	b3 01       	movw	r22, r6
     df0:	a7 01       	movw	r20, r14
     df2:	96 01       	movw	r18, r12
     df4:	0e 94 a5 1b 	call	0x374a	; 0x374a <__mulsf3>
     df8:	9b 01       	movw	r18, r22
     dfa:	ac 01       	movw	r20, r24
     dfc:	c2 01       	movw	r24, r4
     dfe:	b1 01       	movw	r22, r2
     e00:	0e 94 10 18 	call	0x3020	; 0x3020 <__subsf3>
     e04:	20 e0       	ldi	r18, 0x00	; 0
     e06:	30 e0       	ldi	r19, 0x00	; 0
     e08:	40 e0       	ldi	r20, 0x00	; 0
     e0a:	5f e3       	ldi	r21, 0x3F	; 63
     e0c:	0e 94 a5 1b 	call	0x374a	; 0x374a <__mulsf3>
     e10:	f5 01       	movw	r30, r10
     e12:	67 8b       	std	Z+23, r22	; 0x17
     e14:	70 8f       	std	Z+24, r23	; 0x18
     e16:	81 8f       	std	Z+25, r24	; 0x19
     e18:	92 8f       	std	Z+26, r25	; 0x1a
        offset[gc.plane_axis_1] = (y+(x*h_x2_div_d))/2;
     e1a:	80 91 6e 20 	lds	r24, 0x206E
     e1e:	90 e0       	ldi	r25, 0x00	; 0
     e20:	88 0f       	add	r24, r24
     e22:	99 1f       	adc	r25, r25
     e24:	88 0f       	add	r24, r24
     e26:	99 1f       	adc	r25, r25
     e28:	08 0f       	add	r16, r24
     e2a:	19 1f       	adc	r17, r25
     e2c:	c2 01       	movw	r24, r4
     e2e:	b1 01       	movw	r22, r2
     e30:	a7 01       	movw	r20, r14
     e32:	96 01       	movw	r18, r12
     e34:	0e 94 a5 1b 	call	0x374a	; 0x374a <__mulsf3>
     e38:	9b 01       	movw	r18, r22
     e3a:	ac 01       	movw	r20, r24
     e3c:	c4 01       	movw	r24, r8
     e3e:	b3 01       	movw	r22, r6
     e40:	0e 94 11 18 	call	0x3022	; 0x3022 <__addsf3>
     e44:	20 e0       	ldi	r18, 0x00	; 0
     e46:	30 e0       	ldi	r19, 0x00	; 0
     e48:	40 e0       	ldi	r20, 0x00	; 0
     e4a:	5f e3       	ldi	r21, 0x3F	; 63
     e4c:	0e 94 a5 1b 	call	0x374a	; 0x374a <__mulsf3>
     e50:	d8 01       	movw	r26, r16
     e52:	57 96       	adiw	r26, 0x17	; 23
     e54:	6d 93       	st	X+, r22
     e56:	7d 93       	st	X+, r23
     e58:	8d 93       	st	X+, r24
     e5a:	9c 93       	st	X, r25
     e5c:	5a 97       	sbiw	r26, 0x1a	; 26
                        C   <- theta_start (e.g. -145 degrees: theta_start == -PI*(3/4))

      */
            
      // calculate the theta (angle) of the current point
      double theta_start = theta(-offset[gc.plane_axis_0], -offset[gc.plane_axis_1]);
     e5e:	e0 91 6d 20 	lds	r30, 0x206D
     e62:	f0 e0       	ldi	r31, 0x00	; 0
     e64:	ee 0f       	add	r30, r30
     e66:	ff 1f       	adc	r31, r31
     e68:	ee 0f       	add	r30, r30
     e6a:	ff 1f       	adc	r31, r31
     e6c:	8e 01       	movw	r16, r28
     e6e:	0f 5f       	subi	r16, 0xFF	; 255
     e70:	1f 4f       	sbci	r17, 0xFF	; 255
     e72:	e0 0f       	add	r30, r16
     e74:	f1 1f       	adc	r31, r17
     e76:	67 89       	ldd	r22, Z+23	; 0x17
     e78:	70 8d       	ldd	r23, Z+24	; 0x18
     e7a:	81 8d       	ldd	r24, Z+25	; 0x19
     e7c:	92 8d       	ldd	r25, Z+26	; 0x1a
     e7e:	90 58       	subi	r25, 0x80	; 128
     e80:	e0 91 6e 20 	lds	r30, 0x206E
     e84:	f0 e0       	ldi	r31, 0x00	; 0
     e86:	ee 0f       	add	r30, r30
     e88:	ff 1f       	adc	r31, r31
     e8a:	ee 0f       	add	r30, r30
     e8c:	ff 1f       	adc	r31, r31
     e8e:	e0 0f       	add	r30, r16
     e90:	f1 1f       	adc	r31, r17
     e92:	27 89       	ldd	r18, Z+23	; 0x17
     e94:	30 8d       	ldd	r19, Z+24	; 0x18
     e96:	41 8d       	ldd	r20, Z+25	; 0x19
     e98:	52 8d       	ldd	r21, Z+26	; 0x1a
     e9a:	50 58       	subi	r21, 0x80	; 128
     e9c:	0e 94 40 03 	call	0x680	; 0x680 <theta>
     ea0:	69 a7       	std	Y+41, r22	; 0x29
     ea2:	7a a7       	std	Y+42, r23	; 0x2a
     ea4:	8b a7       	std	Y+43, r24	; 0x2b
     ea6:	9c a7       	std	Y+44, r25	; 0x2c
      // calculate the theta (angle) of the target point
      double theta_end = theta(target[gc.plane_axis_0] - offset[gc.plane_axis_0] - gc.position[gc.plane_axis_0], 
         target[gc.plane_axis_1] - offset[gc.plane_axis_1] - gc.position[gc.plane_axis_1]);
     ea8:	20 91 6d 20 	lds	r18, 0x206D
     eac:	e2 2e       	mov	r14, r18
     eae:	ff 24       	eor	r15, r15
     eb0:	20 91 6e 20 	lds	r18, 0x206E
     eb4:	a2 2e       	mov	r10, r18
     eb6:	bb 24       	eor	r11, r11
     eb8:	ee 0c       	add	r14, r14
     eba:	ff 1c       	adc	r15, r15
     ebc:	ee 0c       	add	r14, r14
     ebe:	ff 1c       	adc	r15, r15
     ec0:	f8 01       	movw	r30, r16
     ec2:	ee 0d       	add	r30, r14
     ec4:	ff 1d       	adc	r31, r15
     ec6:	63 85       	ldd	r22, Z+11	; 0x0b
     ec8:	74 85       	ldd	r23, Z+12	; 0x0c
     eca:	85 85       	ldd	r24, Z+13	; 0x0d
     ecc:	96 85       	ldd	r25, Z+14	; 0x0e
     ece:	27 89       	ldd	r18, Z+23	; 0x17
     ed0:	30 8d       	ldd	r19, Z+24	; 0x18
     ed2:	41 8d       	ldd	r20, Z+25	; 0x19
     ed4:	52 8d       	ldd	r21, Z+26	; 0x1a
     ed6:	0e 94 10 18 	call	0x3020	; 0x3020 <__subsf3>
     eda:	ee e5       	ldi	r30, 0x5E	; 94
     edc:	f0 e2       	ldi	r31, 0x20	; 32
     ede:	ee 0e       	add	r14, r30
     ee0:	ff 1e       	adc	r15, r31
     ee2:	d7 01       	movw	r26, r14
     ee4:	2d 91       	ld	r18, X+
     ee6:	3d 91       	ld	r19, X+
     ee8:	4d 91       	ld	r20, X+
     eea:	5c 91       	ld	r21, X
     eec:	0e 94 10 18 	call	0x3020	; 0x3020 <__subsf3>
     ef0:	6b 01       	movw	r12, r22
     ef2:	7c 01       	movw	r14, r24
     ef4:	aa 0c       	add	r10, r10
     ef6:	bb 1c       	adc	r11, r11
     ef8:	aa 0c       	add	r10, r10
     efa:	bb 1c       	adc	r11, r11
     efc:	0a 0d       	add	r16, r10
     efe:	1b 1d       	adc	r17, r11
     f00:	f8 01       	movw	r30, r16
     f02:	63 85       	ldd	r22, Z+11	; 0x0b
     f04:	74 85       	ldd	r23, Z+12	; 0x0c
     f06:	85 85       	ldd	r24, Z+13	; 0x0d
     f08:	96 85       	ldd	r25, Z+14	; 0x0e
     f0a:	27 89       	ldd	r18, Z+23	; 0x17
     f0c:	30 8d       	ldd	r19, Z+24	; 0x18
     f0e:	41 8d       	ldd	r20, Z+25	; 0x19
     f10:	52 8d       	ldd	r21, Z+26	; 0x1a
     f12:	0e 94 10 18 	call	0x3020	; 0x3020 <__subsf3>
     f16:	2e e5       	ldi	r18, 0x5E	; 94
     f18:	30 e2       	ldi	r19, 0x20	; 32
     f1a:	a2 0e       	add	r10, r18
     f1c:	b3 1e       	adc	r11, r19
     f1e:	d5 01       	movw	r26, r10
     f20:	2d 91       	ld	r18, X+
     f22:	3d 91       	ld	r19, X+
     f24:	4d 91       	ld	r20, X+
     f26:	5c 91       	ld	r21, X
     f28:	0e 94 10 18 	call	0x3020	; 0x3020 <__subsf3>
     f2c:	9b 01       	movw	r18, r22
     f2e:	ac 01       	movw	r20, r24
     f30:	c7 01       	movw	r24, r14
     f32:	b6 01       	movw	r22, r12
     f34:	0e 94 40 03 	call	0x680	; 0x680 <theta>
     f38:	7b 01       	movw	r14, r22
     f3a:	8c 01       	movw	r16, r24
      // double theta_end = theta(5,0);
      // ensure that the difference is positive so that we have clockwise travel
      if (theta_end < theta_start) { theta_end += 2*M_PI; }
     f3c:	29 a5       	ldd	r18, Y+41	; 0x29
     f3e:	3a a5       	ldd	r19, Y+42	; 0x2a
     f40:	4b a5       	ldd	r20, Y+43	; 0x2b
     f42:	5c a5       	ldd	r21, Y+44	; 0x2c
     f44:	0e 94 b0 18 	call	0x3160	; 0x3160 <__cmpsf2>
     f48:	88 23       	and	r24, r24
     f4a:	54 f4       	brge	.+20     	; 0xf60 <gc_execute_line+0x862>
     f4c:	c8 01       	movw	r24, r16
     f4e:	b7 01       	movw	r22, r14
     f50:	2b ed       	ldi	r18, 0xDB	; 219
     f52:	3f e0       	ldi	r19, 0x0F	; 15
     f54:	49 ec       	ldi	r20, 0xC9	; 201
     f56:	50 e4       	ldi	r21, 0x40	; 64
     f58:	0e 94 11 18 	call	0x3022	; 0x3022 <__addsf3>
     f5c:	7b 01       	movw	r14, r22
     f5e:	8c 01       	movw	r16, r24
      double angular_travel = theta_end-theta_start;
     f60:	c8 01       	movw	r24, r16
     f62:	b7 01       	movw	r22, r14
     f64:	29 a5       	ldd	r18, Y+41	; 0x29
     f66:	3a a5       	ldd	r19, Y+42	; 0x2a
     f68:	4b a5       	ldd	r20, Y+43	; 0x2b
     f6a:	5c a5       	ldd	r21, Y+44	; 0x2c
     f6c:	0e 94 10 18 	call	0x3020	; 0x3020 <__subsf3>
     f70:	1b 01       	movw	r2, r22
     f72:	2c 01       	movw	r4, r24
      // Invert angular motion if the g-code wanted a counterclockwise arc
      if (gc.motion_mode == MOTION_MODE_CCW_ARC) {
     f74:	80 91 4f 20 	lds	r24, 0x204F
     f78:	83 30       	cpi	r24, 0x03	; 3
     f7a:	51 f4       	brne	.+20     	; 0xf90 <gc_execute_line+0x892>
        angular_travel = angular_travel-2*M_PI;
     f7c:	c2 01       	movw	r24, r4
     f7e:	b1 01       	movw	r22, r2
     f80:	2b ed       	ldi	r18, 0xDB	; 219
     f82:	3f e0       	ldi	r19, 0x0F	; 15
     f84:	49 ec       	ldi	r20, 0xC9	; 201
     f86:	50 e4       	ldi	r21, 0x40	; 64
     f88:	0e 94 10 18 	call	0x3020	; 0x3020 <__subsf3>
     f8c:	1b 01       	movw	r2, r22
     f8e:	2c 01       	movw	r4, r24
      }
      // Find the radius
      double radius = hypot(offset[gc.plane_axis_0], offset[gc.plane_axis_1]);
     f90:	80 91 6d 20 	lds	r24, 0x206D
     f94:	e8 2f       	mov	r30, r24
     f96:	f0 e0       	ldi	r31, 0x00	; 0
     f98:	ef a3       	std	Y+39, r30	; 0x27
     f9a:	f8 a7       	std	Y+40, r31	; 0x28
     f9c:	ee 0f       	add	r30, r30
     f9e:	ff 1f       	adc	r31, r31
     fa0:	ee 0f       	add	r30, r30
     fa2:	ff 1f       	adc	r31, r31
     fa4:	de 01       	movw	r26, r28
     fa6:	11 96       	adiw	r26, 0x01	; 1
     fa8:	ea 0f       	add	r30, r26
     faa:	fb 1f       	adc	r31, r27
     fac:	e7 88       	ldd	r14, Z+23	; 0x17
     fae:	f0 8c       	ldd	r15, Z+24	; 0x18
     fb0:	01 8d       	ldd	r16, Z+25	; 0x19
     fb2:	12 8d       	ldd	r17, Z+26	; 0x1a
     fb4:	80 91 6e 20 	lds	r24, 0x206E
     fb8:	28 2f       	mov	r18, r24
     fba:	30 e0       	ldi	r19, 0x00	; 0
     fbc:	2d a3       	std	Y+37, r18	; 0x25
     fbe:	3e a3       	std	Y+38, r19	; 0x26
     fc0:	f9 01       	movw	r30, r18
     fc2:	ee 0f       	add	r30, r30
     fc4:	ff 1f       	adc	r31, r31
     fc6:	ee 0f       	add	r30, r30
     fc8:	ff 1f       	adc	r31, r31
     fca:	ea 0f       	add	r30, r26
     fcc:	fb 1f       	adc	r31, r27
     fce:	27 89       	ldd	r18, Z+23	; 0x17
     fd0:	30 8d       	ldd	r19, Z+24	; 0x18
     fd2:	41 8d       	ldd	r20, Z+25	; 0x19
     fd4:	52 8d       	ldd	r21, Z+26	; 0x1a
      // Calculate the motion along the depth axis of the helix
      double depth = target[gc.plane_axis_2]-gc.position[gc.plane_axis_2];
     fd6:	80 91 6f 20 	lds	r24, 0x206F
     fda:	68 2e       	mov	r6, r24
     fdc:	77 24       	eor	r7, r7
     fde:	c3 01       	movw	r24, r6
     fe0:	88 0f       	add	r24, r24
     fe2:	99 1f       	adc	r25, r25
     fe4:	88 0f       	add	r24, r24
     fe6:	99 1f       	adc	r25, r25
     fe8:	a8 0f       	add	r26, r24
     fea:	b9 1f       	adc	r27, r25
     fec:	1b 96       	adiw	r26, 0x0b	; 11
     fee:	6d 91       	ld	r22, X+
     ff0:	7d 91       	ld	r23, X+
     ff2:	8d 91       	ld	r24, X+
     ff4:	9c 91       	ld	r25, X
     ff6:	1e 97       	sbiw	r26, 0x0e	; 14
     ff8:	6b ab       	std	Y+51, r22	; 0x33
     ffa:	7c ab       	std	Y+52, r23	; 0x34
     ffc:	8d ab       	std	Y+53, r24	; 0x35
     ffe:	9e ab       	std	Y+54, r25	; 0x36
    1000:	f3 01       	movw	r30, r6
    1002:	ee 0f       	add	r30, r30
    1004:	ff 1f       	adc	r31, r31
    1006:	ee 0f       	add	r30, r30
    1008:	ff 1f       	adc	r31, r31
    100a:	e2 5a       	subi	r30, 0xA2	; 162
    100c:	ff 4d       	sbci	r31, 0xDF	; 223
    100e:	a0 80       	ld	r10, Z
    1010:	b1 80       	ldd	r11, Z+1	; 0x01
    1012:	c2 80       	ldd	r12, Z+2	; 0x02
    1014:	d3 80       	ldd	r13, Z+3	; 0x03
      // Trace the arc
      mc_arc(theta_start, angular_travel, radius, depth, gc.plane_axis_0, gc.plane_axis_1, gc.plane_axis_2, 
    1016:	70 91 50 20 	lds	r23, 0x2050
    101a:	7c a3       	std	Y+36, r23	; 0x24
    101c:	77 23       	and	r23, r23
    101e:	49 f0       	breq	.+18     	; 0x1032 <gc_execute_line+0x934>
    1020:	8b ad       	ldd	r24, Y+59	; 0x3b
    1022:	8f ab       	std	Y+55, r24	; 0x37
    1024:	9c ad       	ldd	r25, Y+60	; 0x3c
    1026:	98 af       	std	Y+56, r25	; 0x38
    1028:	ad ad       	ldd	r26, Y+61	; 0x3d
    102a:	a9 af       	std	Y+57, r26	; 0x39
    102c:	be ad       	ldd	r27, Y+62	; 0x3e
    102e:	ba af       	std	Y+58, r27	; 0x3a
    1030:	0c c0       	rjmp	.+24     	; 0x104a <gc_execute_line+0x94c>
    1032:	e0 91 56 20 	lds	r30, 0x2056
    1036:	ef ab       	std	Y+55, r30	; 0x37
    1038:	f0 91 57 20 	lds	r31, 0x2057
    103c:	f8 af       	std	Y+56, r31	; 0x38
    103e:	60 91 58 20 	lds	r22, 0x2058
    1042:	69 af       	std	Y+57, r22	; 0x39
    1044:	70 91 59 20 	lds	r23, 0x2059
    1048:	7a af       	std	Y+58, r23	; 0x3a
      // Invert angular motion if the g-code wanted a counterclockwise arc
      if (gc.motion_mode == MOTION_MODE_CCW_ARC) {
        angular_travel = angular_travel-2*M_PI;
      }
      // Find the radius
      double radius = hypot(offset[gc.plane_axis_0], offset[gc.plane_axis_1]);
    104a:	c8 01       	movw	r24, r16
    104c:	b7 01       	movw	r22, r14
    104e:	0e 94 ad 1a 	call	0x355a	; 0x355a <hypot>
    1052:	7b 01       	movw	r14, r22
    1054:	8c 01       	movw	r16, r24
      // Calculate the motion along the depth axis of the helix
      double depth = target[gc.plane_axis_2]-gc.position[gc.plane_axis_2];
      // Trace the arc
      mc_arc(theta_start, angular_travel, radius, depth, gc.plane_axis_0, gc.plane_axis_1, gc.plane_axis_2, 
    1056:	8d b7       	in	r24, 0x3d	; 61
    1058:	9e b7       	in	r25, 0x3e	; 62
    105a:	0a 97       	sbiw	r24, 0x0a	; 10
    105c:	8d bf       	out	0x3d, r24	; 61
    105e:	9e bf       	out	0x3e, r25	; 62
    1060:	8d b6       	in	r8, 0x3d	; 61
    1062:	9e b6       	in	r9, 0x3e	; 62
    1064:	08 94       	sec
    1066:	81 1c       	adc	r8, r1
    1068:	91 1c       	adc	r9, r1
    106a:	6b a9       	ldd	r22, Y+51	; 0x33
    106c:	7c a9       	ldd	r23, Y+52	; 0x34
    106e:	8d a9       	ldd	r24, Y+53	; 0x35
    1070:	9e a9       	ldd	r25, Y+54	; 0x36
    1072:	a6 01       	movw	r20, r12
    1074:	95 01       	movw	r18, r10
    1076:	0e 94 10 18 	call	0x3020	; 0x3020 <__subsf3>
    107a:	5b 01       	movw	r10, r22
    107c:	6c 01       	movw	r12, r24
    107e:	ed a1       	ldd	r30, Y+37	; 0x25
    1080:	fe a1       	ldd	r31, Y+38	; 0x26
    1082:	d4 01       	movw	r26, r8
    1084:	ed 93       	st	X+, r30
    1086:	fc 93       	st	X, r31
    1088:	11 97       	sbiw	r26, 0x01	; 1
    108a:	12 96       	adiw	r26, 0x02	; 2
    108c:	6d 92       	st	X+, r6
    108e:	7c 92       	st	X, r7
    1090:	13 97       	sbiw	r26, 0x03	; 3
    1092:	2f a9       	ldd	r18, Y+55	; 0x37
    1094:	38 ad       	ldd	r19, Y+56	; 0x38
    1096:	49 ad       	ldd	r20, Y+57	; 0x39
    1098:	5a ad       	ldd	r21, Y+58	; 0x3a
    109a:	c9 01       	movw	r24, r18
    109c:	da 01       	movw	r26, r20
    109e:	f4 01       	movw	r30, r8
    10a0:	84 83       	std	Z+4, r24	; 0x04
    10a2:	95 83       	std	Z+5, r25	; 0x05
    10a4:	a6 83       	std	Z+6, r26	; 0x06
    10a6:	b7 83       	std	Z+7, r27	; 0x07
    10a8:	2c a1       	ldd	r18, Y+36	; 0x24
    10aa:	20 87       	std	Z+8, r18	; 0x08
    10ac:	11 86       	std	Z+9, r1	; 0x09
    10ae:	69 a5       	ldd	r22, Y+41	; 0x29
    10b0:	7a a5       	ldd	r23, Y+42	; 0x2a
    10b2:	8b a5       	ldd	r24, Y+43	; 0x2b
    10b4:	9c a5       	ldd	r25, Y+44	; 0x2c
    10b6:	a2 01       	movw	r20, r4
    10b8:	91 01       	movw	r18, r2
    10ba:	8f a0       	ldd	r8, Y+39	; 0x27
    10bc:	98 a4       	ldd	r9, Y+40	; 0x28
    10be:	0e 94 21 0d 	call	0x1a42	; 0x1a42 <mc_arc>
        (gc.inverse_feed_rate_mode) ? inverse_feed_rate : gc.feed_rate, gc.inverse_feed_rate_mode);
      // Finish off with a line to make sure we arrive exactly where we think we are
      mc_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], 
    10c2:	6c 85       	ldd	r22, Y+12	; 0x0c
    10c4:	7d 85       	ldd	r23, Y+13	; 0x0d
    10c6:	8e 85       	ldd	r24, Y+14	; 0x0e
    10c8:	9f 85       	ldd	r25, Y+15	; 0x0f
    10ca:	28 89       	ldd	r18, Y+16	; 0x10
    10cc:	39 89       	ldd	r19, Y+17	; 0x11
    10ce:	4a 89       	ldd	r20, Y+18	; 0x12
    10d0:	5b 89       	ldd	r21, Y+19	; 0x13
    10d2:	ec 88       	ldd	r14, Y+20	; 0x14
    10d4:	fd 88       	ldd	r15, Y+21	; 0x15
    10d6:	0e 89       	ldd	r16, Y+22	; 0x16
    10d8:	1f 89       	ldd	r17, Y+23	; 0x17
    10da:	80 90 50 20 	lds	r8, 0x2050
    10de:	ad b7       	in	r26, 0x3d	; 61
    10e0:	be b7       	in	r27, 0x3e	; 62
    10e2:	1a 96       	adiw	r26, 0x0a	; 10
    10e4:	ad bf       	out	0x3d, r26	; 61
    10e6:	be bf       	out	0x3e, r27	; 62
    10e8:	88 20       	and	r8, r8
    10ea:	61 f4       	brne	.+24     	; 0x1104 <gc_execute_line+0xa06>
    10ec:	b0 91 56 20 	lds	r27, 0x2056
    10f0:	bb af       	std	Y+59, r27	; 0x3b
    10f2:	e0 91 57 20 	lds	r30, 0x2057
    10f6:	ec af       	std	Y+60, r30	; 0x3c
    10f8:	f0 91 58 20 	lds	r31, 0x2058
    10fc:	fd af       	std	Y+61, r31	; 0x3d
    10fe:	a0 91 59 20 	lds	r26, 0x2059
    1102:	ae af       	std	Y+62, r26	; 0x3e
    1104:	eb ad       	ldd	r30, Y+59	; 0x3b
    1106:	fc ad       	ldd	r31, Y+60	; 0x3c
    1108:	ad ad       	ldd	r26, Y+61	; 0x3d
    110a:	be ad       	ldd	r27, Y+62	; 0x3e
    110c:	5f 01       	movw	r10, r30
    110e:	6d 01       	movw	r12, r26
    1110:	99 24       	eor	r9, r9
    1112:	0e 94 f8 0b 	call	0x17f0	; 0x17f0 <mc_line>
  }
  
  // As far as the parser is concerned, the position is now == target. In reality the
  // motion control system might still be processing the action and the real tool position
  // in any intermediate location.
  memcpy(gc.position, target, sizeof(double)*3);
    1116:	ae e5       	ldi	r26, 0x5E	; 94
    1118:	b0 e2       	ldi	r27, 0x20	; 32
    111a:	fe 01       	movw	r30, r28
    111c:	3c 96       	adiw	r30, 0x0c	; 12
    111e:	8c e0       	ldi	r24, 0x0C	; 12
    1120:	01 90       	ld	r0, Z+
    1122:	0d 92       	st	X+, r0
    1124:	81 50       	subi	r24, 0x01	; 1
    1126:	e1 f7       	brne	.-8      	; 0x1120 <gc_execute_line+0xa22>
  return(gc.status_code);
    1128:	80 91 4e 20 	lds	r24, 0x204E
    112c:	01 c0       	rjmp	.+2      	; 0x1130 <gc_execute_line+0xa32>
    112e:	83 e0       	ldi	r24, 0x03	; 3
}
    1130:	ee 96       	adiw	r28, 0x3e	; 62
    1132:	cd bf       	out	0x3d, r28	; 61
    1134:	de bf       	out	0x3e, r29	; 62
    1136:	cf 91       	pop	r28
    1138:	df 91       	pop	r29
    113a:	1f 91       	pop	r17
    113c:	0f 91       	pop	r16
    113e:	ff 90       	pop	r15
    1140:	ef 90       	pop	r14
    1142:	df 90       	pop	r13
    1144:	cf 90       	pop	r12
    1146:	bf 90       	pop	r11
    1148:	af 90       	pop	r10
    114a:	9f 90       	pop	r9
    114c:	8f 90       	pop	r8
    114e:	7f 90       	pop	r7
    1150:	6f 90       	pop	r6
    1152:	5f 90       	pop	r5
    1154:	4f 90       	pop	r4
    1156:	3f 90       	pop	r3
    1158:	2f 90       	pop	r2
    115a:	08 95       	ret

0000115c <reset_settings>:
#include "wiring_serial.h"
#include <avr/pgmspace.h>

void reset_settings() 
{
	settings.steps_per_mm[0] = X_STEPS_PER_MM;
    115c:	86 ef       	ldi	r24, 0xF6	; 246
    115e:	9a e7       	ldi	r25, 0x7A	; 122
    1160:	ad e1       	ldi	r26, 0x1D	; 29
    1162:	b4 e4       	ldi	r27, 0x44	; 68
    1164:	80 93 33 20 	sts	0x2033, r24
    1168:	90 93 34 20 	sts	0x2034, r25
    116c:	a0 93 35 20 	sts	0x2035, r26
    1170:	b0 93 36 20 	sts	0x2036, r27
	settings.steps_per_mm[1] = Y_STEPS_PER_MM;
    1174:	80 93 37 20 	sts	0x2037, r24
    1178:	90 93 38 20 	sts	0x2038, r25
    117c:	a0 93 39 20 	sts	0x2039, r26
    1180:	b0 93 3a 20 	sts	0x203A, r27
	settings.steps_per_mm[2] = Z_STEPS_PER_MM;
    1184:	80 93 3b 20 	sts	0x203B, r24
    1188:	90 93 3c 20 	sts	0x203C, r25
    118c:	a0 93 3d 20 	sts	0x203D, r26
    1190:	b0 93 3e 20 	sts	0x203E, r27
	settings.pulse_microseconds = STEP_PULSE_MICROSECONDS;
    1194:	82 e0       	ldi	r24, 0x02	; 2
    1196:	80 93 40 20 	sts	0x2040, r24
	settings.default_feed_rate = DEFAULT_FEEDRATE;
    119a:	80 e0       	ldi	r24, 0x00	; 0
    119c:	90 e0       	ldi	r25, 0x00	; 0
    119e:	a6 e9       	ldi	r26, 0x96	; 150
    11a0:	b3 e4       	ldi	r27, 0x43	; 67
    11a2:	80 93 41 20 	sts	0x2041, r24
    11a6:	90 93 42 20 	sts	0x2042, r25
    11aa:	a0 93 43 20 	sts	0x2043, r26
    11ae:	b0 93 44 20 	sts	0x2044, r27
	settings.default_seek_rate = RAPID_FEEDRATE;
    11b2:	80 e0       	ldi	r24, 0x00	; 0
    11b4:	90 e0       	ldi	r25, 0x00	; 0
    11b6:	a0 ef       	ldi	r26, 0xF0	; 240
    11b8:	b3 e4       	ldi	r27, 0x43	; 67
    11ba:	80 93 45 20 	sts	0x2045, r24
    11be:	90 93 46 20 	sts	0x2046, r25
    11c2:	a0 93 47 20 	sts	0x2047, r26
    11c6:	b0 93 48 20 	sts	0x2048, r27
	settings.mm_per_arc_segment = MM_PER_ARC_SEGMENT;
    11ca:	8d ec       	ldi	r24, 0xCD	; 205
    11cc:	9c ec       	ldi	r25, 0xCC	; 204
    11ce:	ac ec       	ldi	r26, 0xCC	; 204
    11d0:	bd e3       	ldi	r27, 0x3D	; 61
    11d2:	80 93 4a 20 	sts	0x204A, r24
    11d6:	90 93 4b 20 	sts	0x204B, r25
    11da:	a0 93 4c 20 	sts	0x204C, r26
    11de:	b0 93 4d 20 	sts	0x204D, r27
	settings.invert_mask = STEPPING_INVERT_MASK;
    11e2:	10 92 49 20 	sts	0x2049, r1
}
    11e6:	08 95       	ret

000011e8 <write_settings>:
  	return(TRUE);
}

void write_settings() 
{
	eeprom_put_char(0, SETTINGS_VERSION);
    11e8:	80 e0       	ldi	r24, 0x00	; 0
    11ea:	90 e0       	ldi	r25, 0x00	; 0
    11ec:	64 e6       	ldi	r22, 0x64	; 100
    11ee:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <eeprom_put_char>
	memcpy_to_eeprom_with_checksum(1, (char*)&settings, sizeof(struct Settings));
    11f2:	81 e0       	ldi	r24, 0x01	; 1
    11f4:	90 e0       	ldi	r25, 0x00	; 0
    11f6:	63 e3       	ldi	r22, 0x33	; 51
    11f8:	70 e2       	ldi	r23, 0x20	; 32
    11fa:	4b e1       	ldi	r20, 0x1B	; 27
    11fc:	50 e0       	ldi	r21, 0x00	; 0
    11fe:	0e 94 e0 0a 	call	0x15c0	; 0x15c0 <memcpy_to_eeprom_with_checksum>
}
    1202:	08 95       	ret

00001204 <store_setting>:

/* store_setting() - a helper method to set settings from command line */

void store_setting(int parameter, double value) 
{
    1204:	fc 01       	movw	r30, r24
	switch(parameter) {
    1206:	84 30       	cpi	r24, 0x04	; 4
    1208:	91 05       	cpc	r25, r1
    120a:	39 f1       	breq	.+78     	; 0x125a <store_setting+0x56>
    120c:	85 30       	cpi	r24, 0x05	; 5
    120e:	91 05       	cpc	r25, r1
    1210:	34 f4       	brge	.+12     	; 0x121e <store_setting+0x1a>
    1212:	97 fd       	sbrc	r25, 7
    1214:	46 c0       	rjmp	.+140    	; 0x12a2 <store_setting+0x9e>
    1216:	83 30       	cpi	r24, 0x03	; 3
    1218:	91 05       	cpc	r25, r1
    121a:	5c f0       	brlt	.+22     	; 0x1232 <store_setting+0x2e>
    121c:	15 c0       	rjmp	.+42     	; 0x1248 <store_setting+0x44>
    121e:	86 30       	cpi	r24, 0x06	; 6
    1220:	91 05       	cpc	r25, r1
    1222:	69 f1       	breq	.+90     	; 0x127e <store_setting+0x7a>
    1224:	86 30       	cpi	r24, 0x06	; 6
    1226:	91 05       	cpc	r25, r1
    1228:	0c f1       	brlt	.+66     	; 0x126c <store_setting+0x68>
    122a:	87 30       	cpi	r24, 0x07	; 7
    122c:	91 05       	cpc	r25, r1
    122e:	c9 f5       	brne	.+114    	; 0x12a2 <store_setting+0x9e>
    1230:	2f c0       	rjmp	.+94     	; 0x1290 <store_setting+0x8c>
    	case 0: case 1: case 2: settings.steps_per_mm[parameter] = value; break;
    1232:	ee 0f       	add	r30, r30
    1234:	ff 1f       	adc	r31, r31
    1236:	ee 0f       	add	r30, r30
    1238:	ff 1f       	adc	r31, r31
    123a:	ed 5c       	subi	r30, 0xCD	; 205
    123c:	ff 4d       	sbci	r31, 0xDF	; 223
    123e:	40 83       	st	Z, r20
    1240:	51 83       	std	Z+1, r21	; 0x01
    1242:	62 83       	std	Z+2, r22	; 0x02
    1244:	73 83       	std	Z+3, r23	; 0x03
    1246:	30 c0       	rjmp	.+96     	; 0x12a8 <store_setting+0xa4>
    	case 3: settings.pulse_microseconds = round(value); break;
    1248:	cb 01       	movw	r24, r22
    124a:	ba 01       	movw	r22, r20
    124c:	0e 94 08 1c 	call	0x3810	; 0x3810 <round>
    1250:	0e 94 24 19 	call	0x3248	; 0x3248 <__fixunssfsi>
    1254:	60 93 40 20 	sts	0x2040, r22
    1258:	27 c0       	rjmp	.+78     	; 0x12a8 <store_setting+0xa4>
    	case 4: settings.default_feed_rate = value; break;
    125a:	40 93 41 20 	sts	0x2041, r20
    125e:	50 93 42 20 	sts	0x2042, r21
    1262:	60 93 43 20 	sts	0x2043, r22
    1266:	70 93 44 20 	sts	0x2044, r23
    126a:	1e c0       	rjmp	.+60     	; 0x12a8 <store_setting+0xa4>
    	case 5: settings.default_seek_rate = value; break;
    126c:	40 93 45 20 	sts	0x2045, r20
    1270:	50 93 46 20 	sts	0x2046, r21
    1274:	60 93 47 20 	sts	0x2047, r22
    1278:	70 93 48 20 	sts	0x2048, r23
    127c:	15 c0       	rjmp	.+42     	; 0x12a8 <store_setting+0xa4>
    	case 6: settings.mm_per_arc_segment = value; break;
    127e:	40 93 4a 20 	sts	0x204A, r20
    1282:	50 93 4b 20 	sts	0x204B, r21
    1286:	60 93 4c 20 	sts	0x204C, r22
    128a:	70 93 4d 20 	sts	0x204D, r23
    128e:	0c c0       	rjmp	.+24     	; 0x12a8 <store_setting+0xa4>
    	case 7: settings.invert_mask = trunc(value); break;
    1290:	cb 01       	movw	r24, r22
    1292:	ba 01       	movw	r22, r20
    1294:	0e 94 73 1c 	call	0x38e6	; 0x38e6 <trunc>
    1298:	0e 94 24 19 	call	0x3248	; 0x3248 <__fixunssfsi>
    129c:	60 93 49 20 	sts	0x2049, r22
    12a0:	03 c0       	rjmp	.+6      	; 0x12a8 <store_setting+0xa4>
    	default: printPgmString(PSTR("Unknown parameter\r\n"));
    12a2:	87 e6       	ldi	r24, 0x67	; 103
    12a4:	92 e0       	ldi	r25, 0x02	; 2
    12a6:	04 c0       	rjmp	.+8      	; 0x12b0 <store_setting+0xac>
    	return;
  	}
  	write_settings();
    12a8:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <write_settings>
	printPgmString(PSTR("Stored new setting\r\n"));
    12ac:	82 e5       	ldi	r24, 0x52	; 82
    12ae:	92 e0       	ldi	r25, 0x02	; 2
    12b0:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
    12b4:	08 95       	ret

000012b6 <read_settings>:
	printPgmString(PSTR(")\r\n\r\n'$x=value' to set parameter or just '$' to dump current settings\r\n"));
}

int read_settings() 
{
	uint8_t version = eeprom_get_char(0);	// Check version-byte of eeprom
    12b6:	80 e0       	ldi	r24, 0x00	; 0
    12b8:	90 e0       	ldi	r25, 0x00	; 0
    12ba:	0e 94 32 0a 	call	0x1464	; 0x1464 <eeprom_get_char>

	if (version != SETTINGS_VERSION) {		// Read settings-record and check checksum
    12be:	84 36       	cpi	r24, 0x64	; 100
    12c0:	19 f0       	breq	.+6      	; 0x12c8 <read_settings+0x12>
    12c2:	20 e0       	ldi	r18, 0x00	; 0
    12c4:	30 e0       	ldi	r19, 0x00	; 0
    12c6:	0d c0       	rjmp	.+26     	; 0x12e2 <read_settings+0x2c>
		return(FALSE); 
	} 
  	if (!(memcpy_from_eeprom_with_checksum((char*)&settings, 1, sizeof(struct Settings)))) {
    12c8:	83 e3       	ldi	r24, 0x33	; 51
    12ca:	90 e2       	ldi	r25, 0x20	; 32
    12cc:	61 e0       	ldi	r22, 0x01	; 1
    12ce:	70 e0       	ldi	r23, 0x00	; 0
    12d0:	4b e1       	ldi	r20, 0x1B	; 27
    12d2:	50 e0       	ldi	r21, 0x00	; 0
    12d4:	0e 94 3c 0a 	call	0x1478	; 0x1478 <memcpy_from_eeprom_with_checksum>
    12d8:	00 97       	sbiw	r24, 0x00	; 0
    12da:	11 f0       	breq	.+4      	; 0x12e0 <read_settings+0x2a>
    12dc:	81 e0       	ldi	r24, 0x01	; 1
    12de:	90 e0       	ldi	r25, 0x00	; 0
    12e0:	9c 01       	movw	r18, r24
    	return(FALSE);
  	}
  	return(TRUE);
}
    12e2:	c9 01       	movw	r24, r18
    12e4:	08 95       	ret

000012e6 <dump_settings>:
	settings.invert_mask = STEPPING_INVERT_MASK;
}

void dump_settings() 
{
	printPgmString(PSTR("$0 = ")); printFloat(settings.steps_per_mm[0]);
    12e6:	86 ea       	ldi	r24, 0xA6	; 166
    12e8:	93 e0       	ldi	r25, 0x03	; 3
    12ea:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
    12ee:	60 91 33 20 	lds	r22, 0x2033
    12f2:	70 91 34 20 	lds	r23, 0x2034
    12f6:	80 91 35 20 	lds	r24, 0x2035
    12fa:	90 91 36 20 	lds	r25, 0x2036
    12fe:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <printFloat>
	printPgmString(PSTR(" (steps/mm x)\r\n$1 = ")); printFloat(settings.steps_per_mm[1]);
    1302:	81 e9       	ldi	r24, 0x91	; 145
    1304:	93 e0       	ldi	r25, 0x03	; 3
    1306:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
    130a:	60 91 37 20 	lds	r22, 0x2037
    130e:	70 91 38 20 	lds	r23, 0x2038
    1312:	80 91 39 20 	lds	r24, 0x2039
    1316:	90 91 3a 20 	lds	r25, 0x203A
    131a:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <printFloat>
	printPgmString(PSTR(" (steps/mm y)\r\n$2 = ")); printFloat(settings.steps_per_mm[2]);
    131e:	8c e7       	ldi	r24, 0x7C	; 124
    1320:	93 e0       	ldi	r25, 0x03	; 3
    1322:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
    1326:	60 91 3b 20 	lds	r22, 0x203B
    132a:	70 91 3c 20 	lds	r23, 0x203C
    132e:	80 91 3d 20 	lds	r24, 0x203D
    1332:	90 91 3e 20 	lds	r25, 0x203E
    1336:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <printFloat>
	printPgmString(PSTR(" (steps/mm z)\r\n$3 = ")); printInteger(settings.pulse_microseconds);
    133a:	87 e6       	ldi	r24, 0x67	; 103
    133c:	93 e0       	ldi	r25, 0x03	; 3
    133e:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
    1342:	60 91 40 20 	lds	r22, 0x2040
    1346:	70 e0       	ldi	r23, 0x00	; 0
    1348:	80 e0       	ldi	r24, 0x00	; 0
    134a:	90 e0       	ldi	r25, 0x00	; 0
    134c:	0e 94 b6 17 	call	0x2f6c	; 0x2f6c <printInteger>
	printPgmString(PSTR(" (microseconds step pulse)\r\n$4 = ")); printFloat(settings.default_feed_rate);
    1350:	85 e4       	ldi	r24, 0x45	; 69
    1352:	93 e0       	ldi	r25, 0x03	; 3
    1354:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
    1358:	60 91 41 20 	lds	r22, 0x2041
    135c:	70 91 42 20 	lds	r23, 0x2042
    1360:	80 91 43 20 	lds	r24, 0x2043
    1364:	90 91 44 20 	lds	r25, 0x2044
    1368:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <printFloat>
	printPgmString(PSTR(" (mm/sec default feed rate)\r\n$5 = ")); printFloat(settings.default_seek_rate);
    136c:	82 e2       	ldi	r24, 0x22	; 34
    136e:	93 e0       	ldi	r25, 0x03	; 3
    1370:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
    1374:	60 91 45 20 	lds	r22, 0x2045
    1378:	70 91 46 20 	lds	r23, 0x2046
    137c:	80 91 47 20 	lds	r24, 0x2047
    1380:	90 91 48 20 	lds	r25, 0x2048
    1384:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <printFloat>
	printPgmString(PSTR(" (mm/sec default seek rate)\r\n$6 = ")); printFloat(settings.mm_per_arc_segment);
    1388:	8f ef       	ldi	r24, 0xFF	; 255
    138a:	92 e0       	ldi	r25, 0x02	; 2
    138c:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
    1390:	60 91 4a 20 	lds	r22, 0x204A
    1394:	70 91 4b 20 	lds	r23, 0x204B
    1398:	80 91 4c 20 	lds	r24, 0x204C
    139c:	90 91 4d 20 	lds	r25, 0x204D
    13a0:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <printFloat>
	printPgmString(PSTR(" (mm/arc segment)\r\n$7 = ")); printInteger(settings.invert_mask); 
    13a4:	86 ee       	ldi	r24, 0xE6	; 230
    13a6:	92 e0       	ldi	r25, 0x02	; 2
    13a8:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
    13ac:	60 91 49 20 	lds	r22, 0x2049
    13b0:	70 e0       	ldi	r23, 0x00	; 0
    13b2:	80 e0       	ldi	r24, 0x00	; 0
    13b4:	90 e0       	ldi	r25, 0x00	; 0
    13b6:	0e 94 b6 17 	call	0x2f6c	; 0x2f6c <printInteger>
	printPgmString(PSTR(" (step port invert mask. binary = ")); printIntegerInBase(settings.invert_mask, 2);  
    13ba:	83 ec       	ldi	r24, 0xC3	; 195
    13bc:	92 e0       	ldi	r25, 0x02	; 2
    13be:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
    13c2:	60 91 49 20 	lds	r22, 0x2049
    13c6:	70 e0       	ldi	r23, 0x00	; 0
    13c8:	80 e0       	ldi	r24, 0x00	; 0
    13ca:	90 e0       	ldi	r25, 0x00	; 0
    13cc:	22 e0       	ldi	r18, 0x02	; 2
    13ce:	30 e0       	ldi	r19, 0x00	; 0
    13d0:	40 e0       	ldi	r20, 0x00	; 0
    13d2:	50 e0       	ldi	r21, 0x00	; 0
    13d4:	0e 94 2f 17 	call	0x2e5e	; 0x2e5e <printIntegerInBase>
	printPgmString(PSTR(")\r\n\r\n'$x=value' to set parameter or just '$' to dump current settings\r\n"));
    13d8:	8b e7       	ldi	r24, 0x7B	; 123
    13da:	92 e0       	ldi	r25, 0x02	; 2
    13dc:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
}
    13e0:	08 95       	ret

000013e2 <config_init>:
	printPgmString(PSTR("Stored new setting\r\n"));
}

void config_init() 
{
	if(read_settings()) {
    13e2:	0e 94 5b 09 	call	0x12b6	; 0x12b6 <read_settings>
    13e6:	89 2b       	or	r24, r25
    13e8:	29 f0       	breq	.+10     	; 0x13f4 <config_init+0x12>
    	printPgmString(PSTR("'$' to dump current settings\r\n"));
    13ea:	83 e3       	ldi	r24, 0x33	; 51
    13ec:	92 e0       	ldi	r25, 0x02	; 2
    13ee:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
    13f2:	08 95       	ret
	} else {
    	printPgmString(("EEPROM blank. Rewrote default settings:\r\n"));
    13f4:	80 e0       	ldi	r24, 0x00	; 0
    13f6:	90 e2       	ldi	r25, 0x20	; 32
    13f8:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
    	reset_settings();
    13fc:	0e 94 ae 08 	call	0x115c	; 0x115c <reset_settings>
    	write_settings();
    1400:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <write_settings>
    	dump_settings();
    1404:	0e 94 73 09 	call	0x12e6	; 0x12e6 <dump_settings>
    1408:	08 95       	ret

0000140a <EEPROM_ReadByte>:
 *  \param  byteAddr  EEPROM Byte address, between 0 and EEPROM_PAGESIZE.
 *
 *  \return  Byte value read from EEPROM.
 */
uint8_t EEPROM_ReadByte( uint8_t pageAddr, uint8_t byteAddr )
{
    140a:	98 2f       	mov	r25, r24
 */
void EEPROM_WaitForNVM( void )
{
	do {
		/* Block execution while waiting for the NVM to be ready. */
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    140c:	e0 ec       	ldi	r30, 0xC0	; 192
    140e:	f1 e0       	ldi	r31, 0x01	; 1
    1410:	80 91 cf 01 	lds	r24, 0x01CF
    1414:	87 fd       	sbrc	r24, 7
    1416:	fa cf       	rjmp	.-12     	; 0x140c <EEPROM_ReadByte+0x2>
	/* Wait until NVM is not busy. */
	EEPROM_WaitForNVM();

	/* Calculate address */
	uint16_t address = (uint16_t)(pageAddr*EEPROM_PAGESIZE)
	                            |(byteAddr & (EEPROM_PAGESIZE-1));
    1418:	26 2f       	mov	r18, r22
    141a:	30 e0       	ldi	r19, 0x00	; 0
    141c:	2f 71       	andi	r18, 0x1F	; 31
    141e:	30 70       	andi	r19, 0x00	; 0
    1420:	89 2f       	mov	r24, r25
    1422:	90 e0       	ldi	r25, 0x00	; 0
    1424:	45 e0       	ldi	r20, 0x05	; 5
    1426:	88 0f       	add	r24, r24
    1428:	99 1f       	adc	r25, r25
    142a:	4a 95       	dec	r20
    142c:	e1 f7       	brne	.-8      	; 0x1426 <EEPROM_ReadByte+0x1c>
    142e:	28 2b       	or	r18, r24
    1430:	39 2b       	or	r19, r25

	/* Set address to read from. */
	NVM.ADDR0 = address & 0xFF;
    1432:	20 93 c0 01 	sts	0x01C0, r18
	NVM.ADDR1 = (address >> 8) & 0x1F;
    1436:	83 2f       	mov	r24, r19
    1438:	8f 71       	andi	r24, 0x1F	; 31
    143a:	81 83       	std	Z+1, r24	; 0x01
	NVM.ADDR2 = 0x00;
    143c:	12 82       	std	Z+2, r1	; 0x02

	/* Issue EEPROM Read command. */
	NVM.CMD = NVM_CMD_READ_EEPROM_gc;
    143e:	86 e0       	ldi	r24, 0x06	; 6
    1440:	82 87       	std	Z+10, r24	; 0x0a
	NVM_EXEC();
    1442:	ef 93       	push	r30
    1444:	ff 93       	push	r31
    1446:	0f 93       	push	r16
    1448:	2f 93       	push	r18
    144a:	eb ec       	ldi	r30, 0xCB	; 203
    144c:	f1 e0       	ldi	r31, 0x01	; 1
    144e:	08 ed       	ldi	r16, 0xD8	; 216
    1450:	21 e0       	ldi	r18, 0x01	; 1
    1452:	04 bf       	out	0x34, r16	; 52
    1454:	20 83       	st	Z, r18
    1456:	2f 91       	pop	r18
    1458:	0f 91       	pop	r16
    145a:	ff 91       	pop	r31
    145c:	ef 91       	pop	r30

	return NVM.DATA0;
    145e:	80 91 c4 01 	lds	r24, 0x01C4
}
    1462:	08 95       	ret

00001464 <eeprom_get_char>:

char eeprom_get_char( unsigned int addr )
{
	uint8_t pageAddr = (uint8_t)(addr / EEPROM_PAGESIZE);
	uint8_t byteAddr = (uint8_t)(addr % EEPROM_PAGESIZE);
	return (EEPROM_ReadByte( pageAddr, byteAddr ));
    1464:	68 2f       	mov	r22, r24
    1466:	6f 71       	andi	r22, 0x1F	; 31
    1468:	55 e0       	ldi	r21, 0x05	; 5
    146a:	96 95       	lsr	r25
    146c:	87 95       	ror	r24
    146e:	5a 95       	dec	r21
    1470:	e1 f7       	brne	.-8      	; 0x146a <eeprom_get_char+0x6>
    1472:	0e 94 05 0a 	call	0x140a	; 0x140a <EEPROM_ReadByte>
}
    1476:	08 95       	ret

00001478 <memcpy_from_eeprom_with_checksum>:
    eeprom_put_char(destination++, *(source++)); 
  }
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
    1478:	8f 92       	push	r8
    147a:	9f 92       	push	r9
    147c:	af 92       	push	r10
    147e:	bf 92       	push	r11
    1480:	cf 92       	push	r12
    1482:	df 92       	push	r13
    1484:	ff 92       	push	r15
    1486:	0f 93       	push	r16
    1488:	1f 93       	push	r17
    148a:	cf 93       	push	r28
    148c:	df 93       	push	r29
    148e:	4c 01       	movw	r8, r24
    1490:	5b 01       	movw	r10, r22
    1492:	6a 01       	movw	r12, r20
    1494:	8b 01       	movw	r16, r22
    1496:	ea 01       	movw	r28, r20
    1498:	ff 24       	eor	r15, r15
    149a:	18 c0       	rjmp	.+48     	; 0x14cc <memcpy_from_eeprom_with_checksum+0x54>
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    data = eeprom_get_char(source++);
    149c:	c8 01       	movw	r24, r16
    149e:	0e 94 32 0a 	call	0x1464	; 0x1464 <eeprom_get_char>
    checksum = (checksum << 1) || (checksum >> 7);
    14a2:	ff 20       	and	r15, r15
    14a4:	19 f0       	breq	.+6      	; 0x14ac <memcpy_from_eeprom_with_checksum+0x34>
    14a6:	21 e0       	ldi	r18, 0x01	; 1
    14a8:	30 e0       	ldi	r19, 0x00	; 0
    14aa:	08 c0       	rjmp	.+16     	; 0x14bc <memcpy_from_eeprom_with_checksum+0x44>
    14ac:	2f 2d       	mov	r18, r15
    14ae:	33 27       	eor	r19, r19
    14b0:	27 fd       	sbrc	r18, 7
    14b2:	30 95       	com	r19
    14b4:	22 27       	eor	r18, r18
    14b6:	33 0f       	add	r19, r19
    14b8:	22 1f       	adc	r18, r18
    14ba:	33 27       	eor	r19, r19
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    data = eeprom_get_char(source++);
    14bc:	0f 5f       	subi	r16, 0xFF	; 255
    14be:	1f 4f       	sbci	r17, 0xFF	; 255
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += data;    
    14c0:	f8 2e       	mov	r15, r24
    14c2:	f2 0e       	add	r15, r18
    *(destination++) = data; 
    14c4:	f4 01       	movw	r30, r8
    14c6:	81 93       	st	Z+, r24
    14c8:	4f 01       	movw	r8, r30
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    14ca:	21 97       	sbiw	r28, 0x01	; 1
    14cc:	20 97       	sbiw	r28, 0x00	; 0
    14ce:	31 f7       	brne	.-52     	; 0x149c <memcpy_from_eeprom_with_checksum+0x24>
    data = eeprom_get_char(source++);
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += data;    
    *(destination++) = data; 
  }
  return(checksum == eeprom_get_char(source));
    14d0:	c6 01       	movw	r24, r12
    14d2:	8a 0d       	add	r24, r10
    14d4:	9b 1d       	adc	r25, r11
    14d6:	0e 94 32 0a 	call	0x1464	; 0x1464 <eeprom_get_char>
    14da:	20 e0       	ldi	r18, 0x00	; 0
    14dc:	30 e0       	ldi	r19, 0x00	; 0
    14de:	f8 16       	cp	r15, r24
    14e0:	11 f4       	brne	.+4      	; 0x14e6 <memcpy_from_eeprom_with_checksum+0x6e>
    14e2:	21 e0       	ldi	r18, 0x01	; 1
    14e4:	30 e0       	ldi	r19, 0x00	; 0
}
    14e6:	c9 01       	movw	r24, r18
    14e8:	df 91       	pop	r29
    14ea:	cf 91       	pop	r28
    14ec:	1f 91       	pop	r17
    14ee:	0f 91       	pop	r16
    14f0:	ff 90       	pop	r15
    14f2:	df 90       	pop	r13
    14f4:	cf 90       	pop	r12
    14f6:	bf 90       	pop	r11
    14f8:	af 90       	pop	r10
    14fa:	9f 90       	pop	r9
    14fc:	8f 90       	pop	r8
    14fe:	08 95       	ret

00001500 <EEPROM_WaitForNVM>:
 */
void EEPROM_WaitForNVM( void )
{
	do {
		/* Block execution while waiting for the NVM to be ready. */
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    1500:	80 91 cf 01 	lds	r24, 0x01CF
    1504:	87 fd       	sbrc	r24, 7
    1506:	fc cf       	rjmp	.-8      	; 0x1500 <EEPROM_WaitForNVM>
}
    1508:	08 95       	ret

0000150a <EEPROM_FlushBuffer>:
 */
void EEPROM_WaitForNVM( void )
{
	do {
		/* Block execution while waiting for the NVM to be ready. */
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    150a:	80 91 cf 01 	lds	r24, 0x01CF
    150e:	87 fd       	sbrc	r24, 7
    1510:	fc cf       	rjmp	.-8      	; 0x150a <EEPROM_FlushBuffer>
{
	/* Wait until NVM is not busy. */
	EEPROM_WaitForNVM();

	/* Flush EEPROM page buffer if necessary. */
	if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
    1512:	80 91 cf 01 	lds	r24, 0x01CF
    1516:	81 ff       	sbrs	r24, 1
    1518:	12 c0       	rjmp	.+36     	; 0x153e <EEPROM_FlushBuffer+0x34>
		NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    151a:	86 e3       	ldi	r24, 0x36	; 54
    151c:	e0 ec       	ldi	r30, 0xC0	; 192
    151e:	f1 e0       	ldi	r31, 0x01	; 1
    1520:	82 87       	std	Z+10, r24	; 0x0a
		NVM_EXEC();
    1522:	ef 93       	push	r30
    1524:	ff 93       	push	r31
    1526:	0f 93       	push	r16
    1528:	2f 93       	push	r18
    152a:	eb ec       	ldi	r30, 0xCB	; 203
    152c:	f1 e0       	ldi	r31, 0x01	; 1
    152e:	08 ed       	ldi	r16, 0xD8	; 216
    1530:	21 e0       	ldi	r18, 0x01	; 1
    1532:	04 bf       	out	0x34, r16	; 52
    1534:	20 83       	st	Z, r18
    1536:	2f 91       	pop	r18
    1538:	0f 91       	pop	r16
    153a:	ff 91       	pop	r31
    153c:	ef 91       	pop	r30
    153e:	08 95       	ret

00001540 <EEPROM_WriteByte>:
 *  \param  pageAddr  EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGESIZE
 *  \param  byteAddr  EEPROM Byte address, between 0 and EEPROM_PAGESIZE.
 *  \param  value     Byte value to write to EEPROM.
 */
void EEPROM_WriteByte( uint8_t pageAddr, uint8_t byteAddr, uint8_t value )
{
    1540:	df 92       	push	r13
    1542:	ef 92       	push	r14
    1544:	ff 92       	push	r15
    1546:	0f 93       	push	r16
    1548:	1f 93       	push	r17
    154a:	e8 2e       	mov	r14, r24
    154c:	06 2f       	mov	r16, r22
    154e:	d4 2e       	mov	r13, r20
	/*  Flush buffer to make sure no unintetional data is written and load
	 *  the "Page Load" command into the command register.
	 */
	EEPROM_FlushBuffer();
    1550:	0e 94 85 0a 	call	0x150a	; 0x150a <EEPROM_FlushBuffer>
	NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    1554:	e0 ec       	ldi	r30, 0xC0	; 192
    1556:	f1 e0       	ldi	r31, 0x01	; 1
    1558:	83 e3       	ldi	r24, 0x33	; 51
    155a:	82 87       	std	Z+10, r24	; 0x0a

	/* Calculate address */
	uint16_t address = (uint16_t)(pageAddr*EEPROM_PAGESIZE)|(byteAddr & (EEPROM_PAGESIZE-1));
    155c:	10 e0       	ldi	r17, 0x00	; 0
    155e:	0f 71       	andi	r16, 0x1F	; 31
    1560:	10 70       	andi	r17, 0x00	; 0
    1562:	ff 24       	eor	r15, r15
    1564:	75 e0       	ldi	r23, 0x05	; 5
    1566:	ee 0c       	add	r14, r14
    1568:	ff 1c       	adc	r15, r15
    156a:	7a 95       	dec	r23
    156c:	e1 f7       	brne	.-8      	; 0x1566 <EEPROM_WriteByte+0x26>
    156e:	0e 29       	or	r16, r14
    1570:	1f 29       	or	r17, r15

	/* Set address to write to. */
	NVM.ADDR0 = address & 0xFF;
    1572:	00 83       	st	Z, r16
	NVM.ADDR1 = (address >> 8) & 0x1F;
    1574:	81 2f       	mov	r24, r17
    1576:	8f 71       	andi	r24, 0x1F	; 31
    1578:	81 83       	std	Z+1, r24	; 0x01
	NVM.ADDR2 = 0x00;
    157a:	12 82       	std	Z+2, r1	; 0x02

	/* Load data to write, which triggers the loading of EEPROM page buffer. */
	NVM.DATA0 = value;
    157c:	d4 82       	std	Z+4, r13	; 0x04

	/*  Issue EEPROM Atomic Write (Erase&Write) command. Load command, write
	 *  the protection signature and execute command.
	 */
	NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    157e:	85 e3       	ldi	r24, 0x35	; 53
    1580:	82 87       	std	Z+10, r24	; 0x0a
	NVM_EXEC();
    1582:	ef 93       	push	r30
    1584:	ff 93       	push	r31
    1586:	0f 93       	push	r16
    1588:	2f 93       	push	r18
    158a:	eb ec       	ldi	r30, 0xCB	; 203
    158c:	f1 e0       	ldi	r31, 0x01	; 1
    158e:	08 ed       	ldi	r16, 0xD8	; 216
    1590:	21 e0       	ldi	r18, 0x01	; 1
    1592:	04 bf       	out	0x34, r16	; 52
    1594:	20 83       	st	Z, r18
    1596:	2f 91       	pop	r18
    1598:	0f 91       	pop	r16
    159a:	ff 91       	pop	r31
    159c:	ef 91       	pop	r30
}
    159e:	1f 91       	pop	r17
    15a0:	0f 91       	pop	r16
    15a2:	ff 90       	pop	r15
    15a4:	ef 90       	pop	r14
    15a6:	df 90       	pop	r13
    15a8:	08 95       	ret

000015aa <eeprom_put_char>:
	uint8_t byteAddr = (uint8_t)(addr % EEPROM_PAGESIZE);
	return (EEPROM_ReadByte( pageAddr, byteAddr ));
}

void eeprom_put_char( unsigned int addr, char value )
{
    15aa:	46 2f       	mov	r20, r22
	uint8_t pageAddr = (uint8_t)(addr / EEPROM_PAGESIZE);
	uint8_t byteAddr = (uint8_t)(addr % EEPROM_PAGESIZE);

	EEPROM_WriteByte(pageAddr, byteAddr, value );
    15ac:	68 2f       	mov	r22, r24
    15ae:	6f 71       	andi	r22, 0x1F	; 31
    15b0:	e5 e0       	ldi	r30, 0x05	; 5
    15b2:	96 95       	lsr	r25
    15b4:	87 95       	ror	r24
    15b6:	ea 95       	dec	r30
    15b8:	e1 f7       	brne	.-8      	; 0x15b2 <eeprom_put_char+0x8>
    15ba:	0e 94 a0 0a 	call	0x1540	; 0x1540 <EEPROM_WriteByte>
}
    15be:	08 95       	ret

000015c0 <memcpy_to_eeprom_with_checksum>:

void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
    15c0:	8f 92       	push	r8
    15c2:	9f 92       	push	r9
    15c4:	af 92       	push	r10
    15c6:	bf 92       	push	r11
    15c8:	cf 92       	push	r12
    15ca:	df 92       	push	r13
    15cc:	ef 92       	push	r14
    15ce:	ff 92       	push	r15
    15d0:	0f 93       	push	r16
    15d2:	df 93       	push	r29
    15d4:	cf 93       	push	r28
    15d6:	0f 92       	push	r0
    15d8:	0f 92       	push	r0
    15da:	cd b7       	in	r28, 0x3d	; 61
    15dc:	de b7       	in	r29, 0x3e	; 62
    15de:	5c 01       	movw	r10, r24
    15e0:	6b 01       	movw	r12, r22
    15e2:	7a 01       	movw	r14, r20
    15e4:	4a 01       	movw	r8, r20
    15e6:	00 e0       	ldi	r16, 0x00	; 0
    15e8:	1e c0       	rjmp	.+60     	; 0x1626 <memcpy_to_eeprom_with_checksum+0x66>
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    checksum = (checksum << 1) || (checksum >> 7);
    15ea:	00 23       	and	r16, r16
    15ec:	19 f0       	breq	.+6      	; 0x15f4 <memcpy_to_eeprom_with_checksum+0x34>
    15ee:	21 e0       	ldi	r18, 0x01	; 1
    15f0:	30 e0       	ldi	r19, 0x00	; 0
    15f2:	08 c0       	rjmp	.+16     	; 0x1604 <memcpy_to_eeprom_with_checksum+0x44>
    15f4:	20 2f       	mov	r18, r16
    15f6:	33 27       	eor	r19, r19
    15f8:	27 fd       	sbrc	r18, 7
    15fa:	30 95       	com	r19
    15fc:	22 27       	eor	r18, r18
    15fe:	33 0f       	add	r19, r19
    1600:	22 1f       	adc	r18, r18
    1602:	33 27       	eor	r19, r19
    checksum += *source;
    1604:	f6 01       	movw	r30, r12
    1606:	61 91       	ld	r22, Z+
    1608:	6f 01       	movw	r12, r30
    160a:	06 2f       	mov	r16, r22
    160c:	02 0f       	add	r16, r18
    eeprom_put_char(destination++, *(source++)); 
    160e:	9c 01       	movw	r18, r24
    1610:	2f 5f       	subi	r18, 0xFF	; 255
    1612:	3f 4f       	sbci	r19, 0xFF	; 255
    1614:	29 83       	std	Y+1, r18	; 0x01
    1616:	3a 83       	std	Y+2, r19	; 0x02
    1618:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <eeprom_put_char>
	EEPROM_WriteByte(pageAddr, byteAddr, value );
}

void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    161c:	08 94       	sec
    161e:	81 08       	sbc	r8, r1
    1620:	91 08       	sbc	r9, r1
    1622:	89 81       	ldd	r24, Y+1	; 0x01
    1624:	9a 81       	ldd	r25, Y+2	; 0x02
    1626:	81 14       	cp	r8, r1
    1628:	91 04       	cpc	r9, r1
    162a:	f9 f6       	brne	.-66     	; 0x15ea <memcpy_to_eeprom_with_checksum+0x2a>
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += *source;
    eeprom_put_char(destination++, *(source++)); 
  }
  eeprom_put_char(destination, checksum);
    162c:	c7 01       	movw	r24, r14
    162e:	8a 0d       	add	r24, r10
    1630:	9b 1d       	adc	r25, r11
    1632:	60 2f       	mov	r22, r16
    1634:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <eeprom_put_char>
}
    1638:	0f 90       	pop	r0
    163a:	0f 90       	pop	r0
    163c:	cf 91       	pop	r28
    163e:	df 91       	pop	r29
    1640:	0f 91       	pop	r16
    1642:	ff 90       	pop	r15
    1644:	ef 90       	pop	r14
    1646:	df 90       	pop	r13
    1648:	cf 90       	pop	r12
    164a:	bf 90       	pop	r11
    164c:	af 90       	pop	r10
    164e:	9f 90       	pop	r9
    1650:	8f 90       	pop	r8
    1652:	08 95       	ret

00001654 <EEPROM_LoadByte>:
 *
 *  \param  byteAddr  EEPROM Byte address, between 0 and EEPROM_PAGESIZE.
 *  \param  value     Byte value to write to buffer.
 */
void EEPROM_LoadByte( uint8_t byteAddr, uint8_t value )
{
    1654:	98 2f       	mov	r25, r24
 */
void EEPROM_WaitForNVM( void )
{
	do {
		/* Block execution while waiting for the NVM to be ready. */
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    1656:	e0 ec       	ldi	r30, 0xC0	; 192
    1658:	f1 e0       	ldi	r31, 0x01	; 1
    165a:	80 91 cf 01 	lds	r24, 0x01CF
    165e:	87 fd       	sbrc	r24, 7
    1660:	fa cf       	rjmp	.-12     	; 0x1656 <EEPROM_LoadByte+0x2>
 */
void EEPROM_LoadByte( uint8_t byteAddr, uint8_t value )
{
	/* Wait until NVM is not busy and prepare NVM command.*/
	EEPROM_WaitForNVM();
	NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    1662:	83 e3       	ldi	r24, 0x33	; 51
    1664:	82 87       	std	Z+10, r24	; 0x0a

	/* Set address. */
	NVM.ADDR0 = byteAddr & 0xFF;
    1666:	90 93 c0 01 	sts	0x01C0, r25
	NVM.ADDR1 = 0x00;
    166a:	11 82       	std	Z+1, r1	; 0x01
	NVM.ADDR2 = 0x00;
    166c:	12 82       	std	Z+2, r1	; 0x02

	/* Set data, which triggers loading of EEPROM page buffer. */
	NVM.DATA0 = value;
    166e:	64 83       	std	Z+4, r22	; 0x04
}
    1670:	08 95       	ret

00001672 <EEPROM_LoadPage>:
 *        EEPROM write page operation.
 *
 *  \param  values   Pointer to SRAM buffer containing an entire page.
 */
void EEPROM_LoadPage( const uint8_t * values )
{
    1672:	dc 01       	movw	r26, r24
 */
void EEPROM_WaitForNVM( void )
{
	do {
		/* Block execution while waiting for the NVM to be ready. */
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    1674:	e0 ec       	ldi	r30, 0xC0	; 192
    1676:	f1 e0       	ldi	r31, 0x01	; 1
    1678:	80 91 cf 01 	lds	r24, 0x01CF
    167c:	87 fd       	sbrc	r24, 7
    167e:	fa cf       	rjmp	.-12     	; 0x1674 <EEPROM_LoadPage+0x2>
 */
void EEPROM_LoadPage( const uint8_t * values )
{
	/* Wait until NVM is not busy. */
	EEPROM_WaitForNVM();
	NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    1680:	83 e3       	ldi	r24, 0x33	; 51
    1682:	82 87       	std	Z+10, r24	; 0x0a

	/*  Set address to zero, as only the lower bits matters. ADDR0 is
	 *  maintained inside the loop below.
	 */
	NVM.ADDR1 = 0x00;
    1684:	11 82       	std	Z+1, r1	; 0x01
	NVM.ADDR2 = 0x00;
    1686:	12 82       	std	Z+2, r1	; 0x02
    1688:	90 e0       	ldi	r25, 0x00	; 0

	/* Load multible bytes into page buffer. */
	for (uint8_t i = 0; i < EEPROM_PAGESIZE; ++i) {
		NVM.ADDR0 = i;
    168a:	90 93 c0 01 	sts	0x01C0, r25
		NVM.DATA0 = *values;
    168e:	8d 91       	ld	r24, X+
    1690:	84 83       	std	Z+4, r24	; 0x04
	 */
	NVM.ADDR1 = 0x00;
	NVM.ADDR2 = 0x00;

	/* Load multible bytes into page buffer. */
	for (uint8_t i = 0; i < EEPROM_PAGESIZE; ++i) {
    1692:	9f 5f       	subi	r25, 0xFF	; 255
    1694:	90 32       	cpi	r25, 0x20	; 32
    1696:	c9 f7       	brne	.-14     	; 0x168a <EEPROM_LoadPage+0x18>
		NVM.ADDR0 = i;
		NVM.DATA0 = *values;
		++values;
	}
}
    1698:	08 95       	ret

0000169a <EEPROM_AtomicWritePage>:
 *  locations that have not been loaded will be left untouched in EEPROM.
 *
 *  \param  pageAddr  EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGESIZE
 */
void EEPROM_AtomicWritePage( uint8_t pageAddr )
{
    169a:	98 2f       	mov	r25, r24
 */
void EEPROM_WaitForNVM( void )
{
	do {
		/* Block execution while waiting for the NVM to be ready. */
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    169c:	e0 ec       	ldi	r30, 0xC0	; 192
    169e:	f1 e0       	ldi	r31, 0x01	; 1
    16a0:	80 91 cf 01 	lds	r24, 0x01CF
    16a4:	87 fd       	sbrc	r24, 7
    16a6:	fa cf       	rjmp	.-12     	; 0x169c <EEPROM_AtomicWritePage+0x2>
{
	/* Wait until NVM is not busy. */
	EEPROM_WaitForNVM();

	/* Calculate page address */
	uint16_t address = (uint16_t)(pageAddr*EEPROM_PAGESIZE);
    16a8:	89 2f       	mov	r24, r25
    16aa:	90 e0       	ldi	r25, 0x00	; 0
    16ac:	a5 e0       	ldi	r26, 0x05	; 5
    16ae:	88 0f       	add	r24, r24
    16b0:	99 1f       	adc	r25, r25
    16b2:	aa 95       	dec	r26
    16b4:	e1 f7       	brne	.-8      	; 0x16ae <EEPROM_AtomicWritePage+0x14>

	/* Set address. */
	NVM.ADDR0 = address & 0xFF;
    16b6:	80 93 c0 01 	sts	0x01C0, r24
	NVM.ADDR1 = (address >> 8) & 0x1F;
    16ba:	89 2f       	mov	r24, r25
    16bc:	8f 71       	andi	r24, 0x1F	; 31
    16be:	81 83       	std	Z+1, r24	; 0x01
	NVM.ADDR2 = 0x00;
    16c0:	12 82       	std	Z+2, r1	; 0x02

	/* Issue EEPROM Atomic Write (Erase&Write) command. */
	NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    16c2:	85 e3       	ldi	r24, 0x35	; 53
    16c4:	82 87       	std	Z+10, r24	; 0x0a
	NVM_EXEC();
    16c6:	ef 93       	push	r30
    16c8:	ff 93       	push	r31
    16ca:	0f 93       	push	r16
    16cc:	2f 93       	push	r18
    16ce:	eb ec       	ldi	r30, 0xCB	; 203
    16d0:	f1 e0       	ldi	r31, 0x01	; 1
    16d2:	08 ed       	ldi	r16, 0xD8	; 216
    16d4:	21 e0       	ldi	r18, 0x01	; 1
    16d6:	04 bf       	out	0x34, r16	; 52
    16d8:	20 83       	st	Z, r18
    16da:	2f 91       	pop	r18
    16dc:	0f 91       	pop	r16
    16de:	ff 91       	pop	r31
    16e0:	ef 91       	pop	r30
}
    16e2:	08 95       	ret

000016e4 <EEPROM_ErasePage>:
 *  This function erases one EEPROM page, so that every location reads 0xFF.
 *
 *  \param  pageAddr  EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGESIZE
 */
void EEPROM_ErasePage( uint8_t pageAddr )
{
    16e4:	98 2f       	mov	r25, r24
 */
void EEPROM_WaitForNVM( void )
{
	do {
		/* Block execution while waiting for the NVM to be ready. */
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    16e6:	e0 ec       	ldi	r30, 0xC0	; 192
    16e8:	f1 e0       	ldi	r31, 0x01	; 1
    16ea:	80 91 cf 01 	lds	r24, 0x01CF
    16ee:	87 fd       	sbrc	r24, 7
    16f0:	fa cf       	rjmp	.-12     	; 0x16e6 <EEPROM_ErasePage+0x2>
{
	/* Wait until NVM is not busy. */
	EEPROM_WaitForNVM();

	/* Calculate page address */
	uint16_t address = (uint16_t)(pageAddr*EEPROM_PAGESIZE);
    16f2:	89 2f       	mov	r24, r25
    16f4:	90 e0       	ldi	r25, 0x00	; 0
    16f6:	b5 e0       	ldi	r27, 0x05	; 5
    16f8:	88 0f       	add	r24, r24
    16fa:	99 1f       	adc	r25, r25
    16fc:	ba 95       	dec	r27
    16fe:	e1 f7       	brne	.-8      	; 0x16f8 <EEPROM_ErasePage+0x14>

	/* Set address. */
	NVM.ADDR0 = address & 0xFF;
    1700:	80 93 c0 01 	sts	0x01C0, r24
	NVM.ADDR1 = (address >> 8) & 0x1F;
    1704:	89 2f       	mov	r24, r25
    1706:	8f 71       	andi	r24, 0x1F	; 31
    1708:	81 83       	std	Z+1, r24	; 0x01
	NVM.ADDR2 = 0x00;
    170a:	12 82       	std	Z+2, r1	; 0x02

	/* Issue EEPROM Erase command. */
	NVM.CMD = NVM_CMD_ERASE_EEPROM_PAGE_gc;
    170c:	82 e3       	ldi	r24, 0x32	; 50
    170e:	82 87       	std	Z+10, r24	; 0x0a
	NVM_EXEC();
    1710:	ef 93       	push	r30
    1712:	ff 93       	push	r31
    1714:	0f 93       	push	r16
    1716:	2f 93       	push	r18
    1718:	eb ec       	ldi	r30, 0xCB	; 203
    171a:	f1 e0       	ldi	r31, 0x01	; 1
    171c:	08 ed       	ldi	r16, 0xD8	; 216
    171e:	21 e0       	ldi	r18, 0x01	; 1
    1720:	04 bf       	out	0x34, r16	; 52
    1722:	20 83       	st	Z, r18
    1724:	2f 91       	pop	r18
    1726:	0f 91       	pop	r16
    1728:	ff 91       	pop	r31
    172a:	ef 91       	pop	r30
}
    172c:	08 95       	ret

0000172e <EEPROM_SplitWritePage>:
 *  before writing.
 *
 *  \param  pageAddr  EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGESIZE
 */
void EEPROM_SplitWritePage( uint8_t pageAddr )
{
    172e:	98 2f       	mov	r25, r24
 */
void EEPROM_WaitForNVM( void )
{
	do {
		/* Block execution while waiting for the NVM to be ready. */
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    1730:	e0 ec       	ldi	r30, 0xC0	; 192
    1732:	f1 e0       	ldi	r31, 0x01	; 1
    1734:	80 91 cf 01 	lds	r24, 0x01CF
    1738:	87 fd       	sbrc	r24, 7
    173a:	fa cf       	rjmp	.-12     	; 0x1730 <EEPROM_SplitWritePage+0x2>
{
	/* Wait until NVM is not busy. */
	EEPROM_WaitForNVM();

	/* Calculate page address */
	uint16_t address = (uint16_t)(pageAddr*EEPROM_PAGESIZE);
    173c:	89 2f       	mov	r24, r25
    173e:	90 e0       	ldi	r25, 0x00	; 0
    1740:	25 e0       	ldi	r18, 0x05	; 5
    1742:	88 0f       	add	r24, r24
    1744:	99 1f       	adc	r25, r25
    1746:	2a 95       	dec	r18
    1748:	e1 f7       	brne	.-8      	; 0x1742 <EEPROM_SplitWritePage+0x14>

	/* Set address. */
	NVM.ADDR0 = address & 0xFF;
    174a:	80 93 c0 01 	sts	0x01C0, r24
	NVM.ADDR1 = (address >> 8) & 0x1F;
    174e:	89 2f       	mov	r24, r25
    1750:	8f 71       	andi	r24, 0x1F	; 31
    1752:	81 83       	std	Z+1, r24	; 0x01
	NVM.ADDR2 = 0x00;
    1754:	12 82       	std	Z+2, r1	; 0x02

	/* Issue EEPROM Split Write command. */
	NVM.CMD = NVM_CMD_WRITE_EEPROM_PAGE_gc;
    1756:	84 e3       	ldi	r24, 0x34	; 52
    1758:	82 87       	std	Z+10, r24	; 0x0a
	NVM_EXEC();
    175a:	ef 93       	push	r30
    175c:	ff 93       	push	r31
    175e:	0f 93       	push	r16
    1760:	2f 93       	push	r18
    1762:	eb ec       	ldi	r30, 0xCB	; 203
    1764:	f1 e0       	ldi	r31, 0x01	; 1
    1766:	08 ed       	ldi	r16, 0xD8	; 216
    1768:	21 e0       	ldi	r18, 0x01	; 1
    176a:	04 bf       	out	0x34, r16	; 52
    176c:	20 83       	st	Z, r18
    176e:	2f 91       	pop	r18
    1770:	0f 91       	pop	r16
    1772:	ff 91       	pop	r31
    1774:	ef 91       	pop	r30
}
    1776:	08 95       	ret

00001778 <EEPROM_EraseAll>:
 */
void EEPROM_WaitForNVM( void )
{
	do {
		/* Block execution while waiting for the NVM to be ready. */
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
    1778:	80 91 cf 01 	lds	r24, 0x01CF
    177c:	87 fd       	sbrc	r24, 7
    177e:	fc cf       	rjmp	.-8      	; 0x1778 <EEPROM_EraseAll>
{
	/* Wait until NVM is not busy. */
	EEPROM_WaitForNVM();

	/* Issue EEPROM Erase All command. */
	NVM.CMD = NVM_CMD_ERASE_EEPROM_gc;
    1780:	80 e3       	ldi	r24, 0x30	; 48
    1782:	e0 ec       	ldi	r30, 0xC0	; 192
    1784:	f1 e0       	ldi	r31, 0x01	; 1
    1786:	82 87       	std	Z+10, r24	; 0x0a
	NVM_EXEC();
    1788:	ef 93       	push	r30
    178a:	ff 93       	push	r31
    178c:	0f 93       	push	r16
    178e:	2f 93       	push	r18
    1790:	eb ec       	ldi	r30, 0xCB	; 203
    1792:	f1 e0       	ldi	r31, 0x01	; 1
    1794:	08 ed       	ldi	r16, 0xD8	; 216
    1796:	21 e0       	ldi	r18, 0x01	; 1
    1798:	04 bf       	out	0x34, r16	; 52
    179a:	20 83       	st	Z, r18
    179c:	2f 91       	pop	r18
    179e:	0f 91       	pop	r16
    17a0:	ff 91       	pop	r31
    17a2:	ef 91       	pop	r30
}
    17a4:	08 95       	ret

000017a6 <en_init>:

#include "encoder.h"

void en_init(void) {

}
    17a6:	08 95       	ret

000017a8 <config32MHzClock>:


/* Configure 32 MHz clock (xmega) */
void config32MHzClock(void) 
{
	CCP = CCP_IOREG_gc; 					// Security Signature to modify clk 
    17a8:	88 ed       	ldi	r24, 0xD8	; 216
    17aa:	84 bf       	out	0x34, r24	; 52

	// initialize clock source to be 32MHz internal oscillator (no PLL)
	OSC.CTRL = OSC_RC32MEN_bm; 				// enable internal 32MHz oscillator
    17ac:	82 e0       	ldi	r24, 0x02	; 2
    17ae:	80 93 50 00 	sts	0x0050, r24
	while(!(OSC.STATUS & OSC_RC32MRDY_bm)); // wait for oscillator ready
    17b2:	80 91 51 00 	lds	r24, 0x0051
    17b6:	81 ff       	sbrs	r24, 1
    17b8:	fc cf       	rjmp	.-8      	; 0x17b2 <config32MHzClock+0xa>
	CCP = CCP_IOREG_gc; 					// Security Signature to modify clk
    17ba:	88 ed       	ldi	r24, 0xD8	; 216
    17bc:	84 bf       	out	0x34, r24	; 52
	CLK.CTRL = 0x01; 						// select sysclock 32MHz osc
    17be:	81 e0       	ldi	r24, 0x01	; 1
    17c0:	80 93 40 00 	sts	0x0040, r24
};
    17c4:	08 95       	ret

000017c6 <xmega_init>:

#include <avr/io.h>
#include "xmega_support.h"

void xmega_init(void) {
	config32MHzClock();						// set system clock to 32 MHz
    17c6:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <config32MHzClock>
}
    17ca:	08 95       	ret

000017cc <mc_go_home>:
  	}
}

void mc_go_home()
{
	st_go_home();
    17cc:	0e 94 8d 14 	call	0x291a	; 0x291a <st_go_home>
	clear_vector(position); // By definition this is location [0, 0, 0]
    17d0:	8c e0       	ldi	r24, 0x0C	; 12
    17d2:	e0 e7       	ldi	r30, 0x70	; 112
    17d4:	f0 e2       	ldi	r31, 0x20	; 32
    17d6:	df 01       	movw	r26, r30
    17d8:	1d 92       	st	X+, r1
    17da:	8a 95       	dec	r24
    17dc:	e9 f7       	brne	.-6      	; 0x17d8 <mc_go_home+0xc>
}
    17de:	08 95       	ret

000017e0 <mc_init>:

/* mc_init() */

void mc_init()
{
	clear_vector(position);
    17e0:	8c e0       	ldi	r24, 0x0C	; 12
    17e2:	e0 e7       	ldi	r30, 0x70	; 112
    17e4:	f0 e2       	ldi	r31, 0x20	; 32
    17e6:	df 01       	movw	r26, r30
    17e8:	1d 92       	st	X+, r1
    17ea:	8a 95       	dec	r24
    17ec:	e9 f7       	brne	.-6      	; 0x17e8 <mc_init+0x8>
}
    17ee:	08 95       	ret

000017f0 <mc_line>:
	Feed rate given in millimeters/second unless invert_feed_rate is true. 
	Then the feed_rate means that the motion should be completed in 1/feed_rate minutes.
 */

void mc_line(double x, double y, double z, float feed_rate, int invert_feed_rate)
{
    17f0:	2f 92       	push	r2
    17f2:	3f 92       	push	r3
    17f4:	4f 92       	push	r4
    17f6:	5f 92       	push	r5
    17f8:	6f 92       	push	r6
    17fa:	7f 92       	push	r7
    17fc:	8f 92       	push	r8
    17fe:	9f 92       	push	r9
    1800:	af 92       	push	r10
    1802:	bf 92       	push	r11
    1804:	cf 92       	push	r12
    1806:	df 92       	push	r13
    1808:	ef 92       	push	r14
    180a:	ff 92       	push	r15
    180c:	0f 93       	push	r16
    180e:	1f 93       	push	r17
    1810:	df 93       	push	r29
    1812:	cf 93       	push	r28
    1814:	cd b7       	in	r28, 0x3d	; 61
    1816:	de b7       	in	r29, 0x3e	; 62
    1818:	a8 97       	sbiw	r28, 0x28	; 40
    181a:	cd bf       	out	0x3d, r28	; 61
    181c:	de bf       	out	0x3e, r29	; 62
    181e:	29 a3       	std	Y+33, r18	; 0x21
    1820:	3a a3       	std	Y+34, r19	; 0x22
    1822:	4b a3       	std	Y+35, r20	; 0x23
    1824:	5c a3       	std	Y+36, r21	; 0x24
    1826:	ad a2       	std	Y+37, r10	; 0x25
    1828:	be a2       	std	Y+38, r11	; 0x26
    182a:	cf a2       	std	Y+39, r12	; 0x27
    182c:	d8 a6       	std	Y+40, r13	; 0x28
	uint8_t axis; 					// loop variable
	int32_t target[3];				// target position in absolute steps
	int32_t steps[3];				// target line in relative steps
	double millimeters_of_travel;	// 
		
	target[X_AXIS] = lround(x*settings.steps_per_mm[0]);
    182e:	20 91 33 20 	lds	r18, 0x2033
    1832:	30 91 34 20 	lds	r19, 0x2034
    1836:	40 91 35 20 	lds	r20, 0x2035
    183a:	50 91 36 20 	lds	r21, 0x2036
    183e:	2d 8f       	std	Y+29, r18	; 0x1d
    1840:	3e 8f       	std	Y+30, r19	; 0x1e
    1842:	4f 8f       	std	Y+31, r20	; 0x1f
    1844:	58 a3       	std	Y+32, r21	; 0x20
    1846:	0e 94 a5 1b 	call	0x374a	; 0x374a <__mulsf3>
    184a:	0e 94 42 1b 	call	0x3684	; 0x3684 <lround>
    184e:	2b 01       	movw	r4, r22
    1850:	3c 01       	movw	r6, r24
    1852:	49 82       	std	Y+1, r4	; 0x01
    1854:	5a 82       	std	Y+2, r5	; 0x02
    1856:	6b 82       	std	Y+3, r6	; 0x03
    1858:	7c 82       	std	Y+4, r7	; 0x04
	target[Y_AXIS] = lround(y*settings.steps_per_mm[1]);
    185a:	80 91 37 20 	lds	r24, 0x2037
    185e:	90 91 38 20 	lds	r25, 0x2038
    1862:	a0 91 39 20 	lds	r26, 0x2039
    1866:	b0 91 3a 20 	lds	r27, 0x203A
    186a:	89 8f       	std	Y+25, r24	; 0x19
    186c:	9a 8f       	std	Y+26, r25	; 0x1a
    186e:	ab 8f       	std	Y+27, r26	; 0x1b
    1870:	bc 8f       	std	Y+28, r27	; 0x1c
    1872:	69 a1       	ldd	r22, Y+33	; 0x21
    1874:	7a a1       	ldd	r23, Y+34	; 0x22
    1876:	8b a1       	ldd	r24, Y+35	; 0x23
    1878:	9c a1       	ldd	r25, Y+36	; 0x24
    187a:	29 8d       	ldd	r18, Y+25	; 0x19
    187c:	3a 8d       	ldd	r19, Y+26	; 0x1a
    187e:	4b 8d       	ldd	r20, Y+27	; 0x1b
    1880:	5c 8d       	ldd	r21, Y+28	; 0x1c
    1882:	0e 94 a5 1b 	call	0x374a	; 0x374a <__mulsf3>
    1886:	0e 94 42 1b 	call	0x3684	; 0x3684 <lround>
    188a:	5b 01       	movw	r10, r22
    188c:	6c 01       	movw	r12, r24
    188e:	ad 82       	std	Y+5, r10	; 0x05
    1890:	be 82       	std	Y+6, r11	; 0x06
    1892:	cf 82       	std	Y+7, r12	; 0x07
    1894:	d8 86       	std	Y+8, r13	; 0x08
	target[Z_AXIS] = lround(z*settings.steps_per_mm[2]); 
    1896:	20 91 3b 20 	lds	r18, 0x203B
    189a:	30 91 3c 20 	lds	r19, 0x203C
    189e:	40 91 3d 20 	lds	r20, 0x203D
    18a2:	50 91 3e 20 	lds	r21, 0x203E
    18a6:	2d 8b       	std	Y+21, r18	; 0x15
    18a8:	3e 8b       	std	Y+22, r19	; 0x16
    18aa:	4f 8b       	std	Y+23, r20	; 0x17
    18ac:	58 8f       	std	Y+24, r21	; 0x18
    18ae:	c8 01       	movw	r24, r16
    18b0:	b7 01       	movw	r22, r14
    18b2:	0e 94 a5 1b 	call	0x374a	; 0x374a <__mulsf3>
    18b6:	0e 94 42 1b 	call	0x3684	; 0x3684 <lround>
    18ba:	9b 01       	movw	r18, r22
    18bc:	ac 01       	movw	r20, r24
    18be:	29 87       	std	Y+9, r18	; 0x09
    18c0:	3a 87       	std	Y+10, r19	; 0x0a
    18c2:	4b 87       	std	Y+11, r20	; 0x0b
    18c4:	5c 87       	std	Y+12, r21	; 0x0c

	for(axis = X_AXIS; axis <= Z_AXIS; axis++) {
		steps[axis] = target[axis]-position[axis];
    18c6:	80 91 70 20 	lds	r24, 0x2070
    18ca:	90 91 71 20 	lds	r25, 0x2071
    18ce:	a0 91 72 20 	lds	r26, 0x2072
    18d2:	b0 91 73 20 	lds	r27, 0x2073
    18d6:	83 01       	movw	r16, r6
    18d8:	72 01       	movw	r14, r4
    18da:	e8 1a       	sub	r14, r24
    18dc:	f9 0a       	sbc	r15, r25
    18de:	0a 0b       	sbc	r16, r26
    18e0:	1b 0b       	sbc	r17, r27
    18e2:	ed 86       	std	Y+13, r14	; 0x0d
    18e4:	fe 86       	std	Y+14, r15	; 0x0e
    18e6:	0f 87       	std	Y+15, r16	; 0x0f
    18e8:	18 8b       	std	Y+16, r17	; 0x10
    18ea:	80 91 74 20 	lds	r24, 0x2074
    18ee:	90 91 75 20 	lds	r25, 0x2075
    18f2:	a0 91 76 20 	lds	r26, 0x2076
    18f6:	b0 91 77 20 	lds	r27, 0x2077
    18fa:	15 01       	movw	r2, r10
    18fc:	26 01       	movw	r4, r12
    18fe:	28 1a       	sub	r2, r24
    1900:	39 0a       	sbc	r3, r25
    1902:	4a 0a       	sbc	r4, r26
    1904:	5b 0a       	sbc	r5, r27
    1906:	80 91 78 20 	lds	r24, 0x2078
    190a:	90 91 79 20 	lds	r25, 0x2079
    190e:	a0 91 7a 20 	lds	r26, 0x207A
    1912:	b0 91 7b 20 	lds	r27, 0x207B
    1916:	79 01       	movw	r14, r18
    1918:	8a 01       	movw	r16, r20
    191a:	e8 1a       	sub	r14, r24
    191c:	f9 0a       	sbc	r15, r25
    191e:	0a 0b       	sbc	r16, r26
    1920:	1b 0b       	sbc	r17, r27
    1922:	e9 8a       	std	Y+17, r14	; 0x11
    1924:	fa 8a       	std	Y+18, r15	; 0x12
    1926:	0b 8b       	std	Y+19, r16	; 0x13
    1928:	1c 8b       	std	Y+20, r17	; 0x14
	}
  
	if (invert_feed_rate) {
    192a:	89 28       	or	r8, r9
    192c:	a9 f0       	breq	.+42     	; 0x1958 <mc_line+0x168>
    	st_buffer_line(steps[X_AXIS], steps[Y_AXIS], steps[Z_AXIS], lround(ONE_MINUTE_OF_MICROSECONDS/feed_rate));
    192e:	60 ec       	ldi	r22, 0xC0	; 192
    1930:	71 ee       	ldi	r23, 0xE1	; 225
    1932:	84 e6       	ldi	r24, 0x64	; 100
    1934:	9c e4       	ldi	r25, 0x4C	; 76
    1936:	2d a1       	ldd	r18, Y+37	; 0x25
    1938:	3e a1       	ldd	r19, Y+38	; 0x26
    193a:	4f a1       	ldd	r20, Y+39	; 0x27
    193c:	58 a5       	ldd	r21, Y+40	; 0x28
    193e:	0e 94 b7 18 	call	0x316e	; 0x316e <__divsf3>
    1942:	0e 94 42 1b 	call	0x3684	; 0x3684 <lround>
    1946:	5b 01       	movw	r10, r22
    1948:	6c 01       	movw	r12, r24
    194a:	6d 85       	ldd	r22, Y+13	; 0x0d
    194c:	7e 85       	ldd	r23, Y+14	; 0x0e
    194e:	8f 85       	ldd	r24, Y+15	; 0x0f
    1950:	98 89       	ldd	r25, Y+16	; 0x10
    1952:	a2 01       	movw	r20, r4
    1954:	91 01       	movw	r18, r2
    1956:	54 c0       	rjmp	.+168    	; 0x1a00 <mc_line+0x210>
	} else {  // Ask old Phytagoras to estimate how many mm our next move is going to take us
 		millimeters_of_travel = sqrt(square(steps[X_AXIS]/settings.steps_per_mm[0]) + 
    1958:	6d 85       	ldd	r22, Y+13	; 0x0d
    195a:	7e 85       	ldd	r23, Y+14	; 0x0e
    195c:	8f 85       	ldd	r24, Y+15	; 0x0f
    195e:	98 89       	ldd	r25, Y+16	; 0x10
    1960:	0e 94 52 19 	call	0x32a4	; 0x32a4 <__floatsisf>
    1964:	2d 8d       	ldd	r18, Y+29	; 0x1d
    1966:	3e 8d       	ldd	r19, Y+30	; 0x1e
    1968:	4f 8d       	ldd	r20, Y+31	; 0x1f
    196a:	58 a1       	ldd	r21, Y+32	; 0x20
    196c:	0e 94 b7 18 	call	0x316e	; 0x316e <__divsf3>
    1970:	0e 94 70 1c 	call	0x38e0	; 0x38e0 <square>
    1974:	3b 01       	movw	r6, r22
    1976:	4c 01       	movw	r8, r24
    1978:	c2 01       	movw	r24, r4
    197a:	b1 01       	movw	r22, r2
    197c:	0e 94 52 19 	call	0x32a4	; 0x32a4 <__floatsisf>
    1980:	29 8d       	ldd	r18, Y+25	; 0x19
    1982:	3a 8d       	ldd	r19, Y+26	; 0x1a
    1984:	4b 8d       	ldd	r20, Y+27	; 0x1b
    1986:	5c 8d       	ldd	r21, Y+28	; 0x1c
    1988:	0e 94 b7 18 	call	0x316e	; 0x316e <__divsf3>
    198c:	0e 94 70 1c 	call	0x38e0	; 0x38e0 <square>
    1990:	5b 01       	movw	r10, r22
    1992:	6c 01       	movw	r12, r24
    1994:	69 89       	ldd	r22, Y+17	; 0x11
    1996:	7a 89       	ldd	r23, Y+18	; 0x12
    1998:	8b 89       	ldd	r24, Y+19	; 0x13
    199a:	9c 89       	ldd	r25, Y+20	; 0x14
    199c:	0e 94 52 19 	call	0x32a4	; 0x32a4 <__floatsisf>
    19a0:	2d 89       	ldd	r18, Y+21	; 0x15
    19a2:	3e 89       	ldd	r19, Y+22	; 0x16
    19a4:	4f 89       	ldd	r20, Y+23	; 0x17
    19a6:	58 8d       	ldd	r21, Y+24	; 0x18
    19a8:	0e 94 b7 18 	call	0x316e	; 0x316e <__divsf3>
    19ac:	0e 94 70 1c 	call	0x38e0	; 0x38e0 <square>
    19b0:	7b 01       	movw	r14, r22
    19b2:	8c 01       	movw	r16, r24
    19b4:	c4 01       	movw	r24, r8
    19b6:	b3 01       	movw	r22, r6
    19b8:	a6 01       	movw	r20, r12
    19ba:	95 01       	movw	r18, r10
    19bc:	0e 94 11 18 	call	0x3022	; 0x3022 <__addsf3>
    19c0:	a8 01       	movw	r20, r16
    19c2:	97 01       	movw	r18, r14
    19c4:	0e 94 11 18 	call	0x3022	; 0x3022 <__addsf3>
    19c8:	0e 94 32 1c 	call	0x3864	; 0x3864 <sqrt>
									 square(steps[Y_AXIS]/settings.steps_per_mm[1]) + 
									 square(steps[Z_AXIS]/settings.steps_per_mm[2]));
		st_buffer_line(steps[X_AXIS], steps[Y_AXIS], steps[Z_AXIS], lround((millimeters_of_travel/feed_rate)*1000000));
    19cc:	2d a1       	ldd	r18, Y+37	; 0x25
    19ce:	3e a1       	ldd	r19, Y+38	; 0x26
    19d0:	4f a1       	ldd	r20, Y+39	; 0x27
    19d2:	58 a5       	ldd	r21, Y+40	; 0x28
    19d4:	0e 94 b7 18 	call	0x316e	; 0x316e <__divsf3>
    19d8:	20 e0       	ldi	r18, 0x00	; 0
    19da:	34 e2       	ldi	r19, 0x24	; 36
    19dc:	44 e7       	ldi	r20, 0x74	; 116
    19de:	59 e4       	ldi	r21, 0x49	; 73
    19e0:	0e 94 a5 1b 	call	0x374a	; 0x374a <__mulsf3>
    19e4:	0e 94 42 1b 	call	0x3684	; 0x3684 <lround>
    19e8:	5b 01       	movw	r10, r22
    19ea:	6c 01       	movw	r12, r24
    19ec:	6d 85       	ldd	r22, Y+13	; 0x0d
    19ee:	7e 85       	ldd	r23, Y+14	; 0x0e
    19f0:	8f 85       	ldd	r24, Y+15	; 0x0f
    19f2:	98 89       	ldd	r25, Y+16	; 0x10
    19f4:	a2 01       	movw	r20, r4
    19f6:	91 01       	movw	r18, r2
    19f8:	e9 88       	ldd	r14, Y+17	; 0x11
    19fa:	fa 88       	ldd	r15, Y+18	; 0x12
    19fc:	0b 89       	ldd	r16, Y+19	; 0x13
    19fe:	1c 89       	ldd	r17, Y+20	; 0x14
    1a00:	0e 94 bd 13 	call	0x277a	; 0x277a <st_buffer_line>
	}
	memcpy(position, target, sizeof(target)); 	// position[] = target[] 
    1a04:	a0 e7       	ldi	r26, 0x70	; 112
    1a06:	b0 e2       	ldi	r27, 0x20	; 32
    1a08:	fe 01       	movw	r30, r28
    1a0a:	31 96       	adiw	r30, 0x01	; 1
    1a0c:	8c e0       	ldi	r24, 0x0C	; 12
    1a0e:	01 90       	ld	r0, Z+
    1a10:	0d 92       	st	X+, r0
    1a12:	81 50       	subi	r24, 0x01	; 1
    1a14:	e1 f7       	brne	.-8      	; 0x1a0e <mc_line+0x21e>
}
    1a16:	a8 96       	adiw	r28, 0x28	; 40
    1a18:	cd bf       	out	0x3d, r28	; 61
    1a1a:	de bf       	out	0x3e, r29	; 62
    1a1c:	cf 91       	pop	r28
    1a1e:	df 91       	pop	r29
    1a20:	1f 91       	pop	r17
    1a22:	0f 91       	pop	r16
    1a24:	ff 90       	pop	r15
    1a26:	ef 90       	pop	r14
    1a28:	df 90       	pop	r13
    1a2a:	cf 90       	pop	r12
    1a2c:	bf 90       	pop	r11
    1a2e:	af 90       	pop	r10
    1a30:	9f 90       	pop	r9
    1a32:	8f 90       	pop	r8
    1a34:	7f 90       	pop	r7
    1a36:	6f 90       	pop	r6
    1a38:	5f 90       	pop	r5
    1a3a:	4f 90       	pop	r4
    1a3c:	3f 90       	pop	r3
    1a3e:	2f 90       	pop	r2
    1a40:	08 95       	ret

00001a42 <mc_arc>:
	The length of each segment is configured in config.h by setting MM_PER_ARC_SEGMENT.  
*/

void mc_arc(double theta, double angular_travel, double radius, double linear_travel, int axis_1, int axis_2, 
  int axis_linear, double feed_rate, int invert_feed_rate)
{
    1a42:	2f 92       	push	r2
    1a44:	3f 92       	push	r3
    1a46:	4f 92       	push	r4
    1a48:	5f 92       	push	r5
    1a4a:	6f 92       	push	r6
    1a4c:	7f 92       	push	r7
    1a4e:	8f 92       	push	r8
    1a50:	9f 92       	push	r9
    1a52:	af 92       	push	r10
    1a54:	bf 92       	push	r11
    1a56:	cf 92       	push	r12
    1a58:	df 92       	push	r13
    1a5a:	ef 92       	push	r14
    1a5c:	ff 92       	push	r15
    1a5e:	0f 93       	push	r16
    1a60:	1f 93       	push	r17
    1a62:	df 93       	push	r29
    1a64:	cf 93       	push	r28
    1a66:	cd b7       	in	r28, 0x3d	; 61
    1a68:	de b7       	in	r29, 0x3e	; 62
    1a6a:	ac 97       	sbiw	r28, 0x2c	; 44
    1a6c:	cd bf       	out	0x3d, r28	; 61
    1a6e:	de bf       	out	0x3e, r29	; 62
    1a70:	1b 01       	movw	r2, r22
    1a72:	2c 01       	movw	r4, r24
    1a74:	29 a3       	std	Y+33, r18	; 0x21
    1a76:	3a a3       	std	Y+34, r19	; 0x22
    1a78:	4b a3       	std	Y+35, r20	; 0x23
    1a7a:	5c a3       	std	Y+36, r21	; 0x24
    1a7c:	ed a2       	std	Y+37, r14	; 0x25
    1a7e:	fe a2       	std	Y+38, r15	; 0x26
    1a80:	0f a3       	std	Y+39, r16	; 0x27
    1a82:	18 a7       	std	Y+40, r17	; 0x28
	double center_x;				// center of this circle
	double center_y;				// center of this circle
	double target[3];
	int i;

	millimeters_of_travel = hypot(angular_travel*radius, labs(linear_travel));
    1a84:	ca 01       	movw	r24, r20
    1a86:	b9 01       	movw	r22, r18
    1a88:	a8 01       	movw	r20, r16
    1a8a:	97 01       	movw	r18, r14
    1a8c:	0e 94 a5 1b 	call	0x374a	; 0x374a <__mulsf3>
    1a90:	7b 01       	movw	r14, r22
    1a92:	8c 01       	movw	r16, r24
    1a94:	c6 01       	movw	r24, r12
    1a96:	b5 01       	movw	r22, r10
    1a98:	0e 94 1f 19 	call	0x323e	; 0x323e <__fixsfsi>
    1a9c:	97 ff       	sbrs	r25, 7
    1a9e:	07 c0       	rjmp	.+14     	; 0x1aae <mc_arc+0x6c>
    1aa0:	90 95       	com	r25
    1aa2:	80 95       	com	r24
    1aa4:	70 95       	com	r23
    1aa6:	61 95       	neg	r22
    1aa8:	7f 4f       	sbci	r23, 0xFF	; 255
    1aaa:	8f 4f       	sbci	r24, 0xFF	; 255
    1aac:	9f 4f       	sbci	r25, 0xFF	; 255
    1aae:	0e 94 52 19 	call	0x32a4	; 0x32a4 <__floatsisf>
    1ab2:	9b 01       	movw	r18, r22
    1ab4:	ac 01       	movw	r20, r24
    1ab6:	c8 01       	movw	r24, r16
    1ab8:	b7 01       	movw	r22, r14
    1aba:	0e 94 ad 1a 	call	0x355a	; 0x355a <hypot>
    1abe:	7b 01       	movw	r14, r22
    1ac0:	8c 01       	movw	r16, r24
	
	if (millimeters_of_travel == 0.0) { 
    1ac2:	20 e0       	ldi	r18, 0x00	; 0
    1ac4:	30 e0       	ldi	r19, 0x00	; 0
    1ac6:	40 e0       	ldi	r20, 0x00	; 0
    1ac8:	50 e0       	ldi	r21, 0x00	; 0
    1aca:	0e 94 b0 18 	call	0x3160	; 0x3160 <__cmpsf2>
    1ace:	88 23       	and	r24, r24
    1ad0:	09 f4       	brne	.+2      	; 0x1ad4 <mc_arc+0x92>
    1ad2:	4e c1       	rjmp	.+668    	; 0x1d70 <mc_arc+0x32e>
		return; 
	}
	uint16_t segments = ceil(millimeters_of_travel/settings.mm_per_arc_segment);
    1ad4:	c8 01       	movw	r24, r16
    1ad6:	b7 01       	movw	r22, r14
    1ad8:	20 91 4a 20 	lds	r18, 0x204A
    1adc:	30 91 4b 20 	lds	r19, 0x204B
    1ae0:	40 91 4c 20 	lds	r20, 0x204C
    1ae4:	50 91 4d 20 	lds	r21, 0x204D
    1ae8:	0e 94 b7 18 	call	0x316e	; 0x316e <__divsf3>
    1aec:	0e 94 9d 18 	call	0x313a	; 0x313a <ceil>
    1af0:	0e 94 24 19 	call	0x3248	; 0x3248 <__fixunssfsi>
    1af4:	6d 87       	std	Y+13, r22	; 0x0d
    1af6:	7e 87       	std	Y+14, r23	; 0x0e
  
  	/*  Multiply inverse feed_rate to compensate for the fact that this movement 
		is approximated by a number of discrete segments. 
		The inverse feed_rate should be correct for the sum of all segments.*/

	if (invert_feed_rate) { 
    1af8:	2c 96       	adiw	r28, 0x0c	; 12
    1afa:	2e ad       	ldd	r18, Y+62	; 0x3e
    1afc:	3f ad       	ldd	r19, Y+63	; 0x3f
    1afe:	2c 97       	sbiw	r28, 0x0c	; 12
    1b00:	23 2b       	or	r18, r19
    1b02:	a1 f0       	breq	.+40     	; 0x1b2c <mc_arc+0xea>
		feed_rate *= segments; 
    1b04:	80 e0       	ldi	r24, 0x00	; 0
    1b06:	90 e0       	ldi	r25, 0x00	; 0
    1b08:	0e 94 50 19 	call	0x32a0	; 0x32a0 <__floatunsisf>
    1b0c:	9b 01       	movw	r18, r22
    1b0e:	ac 01       	movw	r20, r24
    1b10:	2a 96       	adiw	r28, 0x0a	; 10
    1b12:	6c ad       	ldd	r22, Y+60	; 0x3c
    1b14:	7d ad       	ldd	r23, Y+61	; 0x3d
    1b16:	8e ad       	ldd	r24, Y+62	; 0x3e
    1b18:	9f ad       	ldd	r25, Y+63	; 0x3f
    1b1a:	2a 97       	sbiw	r28, 0x0a	; 10
    1b1c:	0e 94 a5 1b 	call	0x374a	; 0x374a <__mulsf3>
    1b20:	2a 96       	adiw	r28, 0x0a	; 10
    1b22:	6c af       	std	Y+60, r22	; 0x3c
    1b24:	7d af       	std	Y+61, r23	; 0x3d
    1b26:	8e af       	std	Y+62, r24	; 0x3e
    1b28:	9f af       	std	Y+63, r25	; 0x3f
    1b2a:	2a 97       	sbiw	r28, 0x0a	; 10
	}
  
	theta_per_segment = angular_travel/segments;
    1b2c:	ed 85       	ldd	r30, Y+13	; 0x0d
    1b2e:	fe 85       	ldd	r31, Y+14	; 0x0e
    1b30:	bf 01       	movw	r22, r30
    1b32:	80 e0       	ldi	r24, 0x00	; 0
    1b34:	90 e0       	ldi	r25, 0x00	; 0
    1b36:	0e 94 50 19 	call	0x32a0	; 0x32a0 <__floatunsisf>
    1b3a:	7b 01       	movw	r14, r22
    1b3c:	8c 01       	movw	r16, r24
    1b3e:	69 a1       	ldd	r22, Y+33	; 0x21
    1b40:	7a a1       	ldd	r23, Y+34	; 0x22
    1b42:	8b a1       	ldd	r24, Y+35	; 0x23
    1b44:	9c a1       	ldd	r25, Y+36	; 0x24
    1b46:	a8 01       	movw	r20, r16
    1b48:	97 01       	movw	r18, r14
    1b4a:	0e 94 b7 18 	call	0x316e	; 0x316e <__divsf3>
    1b4e:	6d 8f       	std	Y+29, r22	; 0x1d
    1b50:	7e 8f       	std	Y+30, r23	; 0x1e
    1b52:	8f 8f       	std	Y+31, r24	; 0x1f
    1b54:	98 a3       	std	Y+32, r25	; 0x20
	linear_per_segment = linear_travel/segments;
    1b56:	c6 01       	movw	r24, r12
    1b58:	b5 01       	movw	r22, r10
    1b5a:	a8 01       	movw	r20, r16
    1b5c:	97 01       	movw	r18, r14
    1b5e:	0e 94 b7 18 	call	0x316e	; 0x316e <__divsf3>
    1b62:	69 8f       	std	Y+25, r22	; 0x19
    1b64:	7a 8f       	std	Y+26, r23	; 0x1a
    1b66:	8b 8f       	std	Y+27, r24	; 0x1b
    1b68:	9c 8f       	std	Y+28, r25	; 0x1c
	
	center_x = (position[axis_1]/settings.steps_per_mm[axis_1])-sin(theta)*radius;
    1b6a:	c2 01       	movw	r24, r4
    1b6c:	b1 01       	movw	r22, r2
    1b6e:	0e 94 28 1c 	call	0x3850	; 0x3850 <sin>
    1b72:	5b 01       	movw	r10, r22
    1b74:	6c 01       	movw	r12, r24
    1b76:	88 0c       	add	r8, r8
    1b78:	99 1c       	adc	r9, r9
    1b7a:	88 0c       	add	r8, r8
    1b7c:	99 1c       	adc	r9, r9
    1b7e:	f4 01       	movw	r30, r8
    1b80:	e0 59       	subi	r30, 0x90	; 144
    1b82:	ff 4d       	sbci	r31, 0xDF	; 223
    1b84:	60 81       	ld	r22, Z
    1b86:	71 81       	ldd	r23, Z+1	; 0x01
    1b88:	82 81       	ldd	r24, Z+2	; 0x02
    1b8a:	93 81       	ldd	r25, Z+3	; 0x03
    1b8c:	0e 94 52 19 	call	0x32a4	; 0x32a4 <__floatsisf>
    1b90:	f4 01       	movw	r30, r8
    1b92:	ed 5c       	subi	r30, 0xCD	; 205
    1b94:	ff 4d       	sbci	r31, 0xDF	; 223
    1b96:	20 81       	ld	r18, Z
    1b98:	31 81       	ldd	r19, Z+1	; 0x01
    1b9a:	42 81       	ldd	r20, Z+2	; 0x02
    1b9c:	53 81       	ldd	r21, Z+3	; 0x03
    1b9e:	0e 94 b7 18 	call	0x316e	; 0x316e <__divsf3>
    1ba2:	7b 01       	movw	r14, r22
    1ba4:	8c 01       	movw	r16, r24
    1ba6:	c6 01       	movw	r24, r12
    1ba8:	b5 01       	movw	r22, r10
    1baa:	2d a1       	ldd	r18, Y+37	; 0x25
    1bac:	3e a1       	ldd	r19, Y+38	; 0x26
    1bae:	4f a1       	ldd	r20, Y+39	; 0x27
    1bb0:	58 a5       	ldd	r21, Y+40	; 0x28
    1bb2:	0e 94 a5 1b 	call	0x374a	; 0x374a <__mulsf3>
    1bb6:	9b 01       	movw	r18, r22
    1bb8:	ac 01       	movw	r20, r24
    1bba:	c8 01       	movw	r24, r16
    1bbc:	b7 01       	movw	r22, r14
    1bbe:	0e 94 10 18 	call	0x3020	; 0x3020 <__subsf3>
    1bc2:	6d 8b       	std	Y+21, r22	; 0x15
    1bc4:	7e 8b       	std	Y+22, r23	; 0x16
    1bc6:	8f 8b       	std	Y+23, r24	; 0x17
    1bc8:	98 8f       	std	Y+24, r25	; 0x18
	center_y = (position[axis_2]/settings.steps_per_mm[axis_2])-cos(theta)*radius;
    1bca:	c2 01       	movw	r24, r4
    1bcc:	b1 01       	movw	r22, r2
    1bce:	0e 94 b4 18 	call	0x3168	; 0x3168 <cos>
    1bd2:	5b 01       	movw	r10, r22
    1bd4:	6c 01       	movw	r12, r24
    1bd6:	24 96       	adiw	r28, 0x04	; 4
    1bd8:	ee ad       	ldd	r30, Y+62	; 0x3e
    1bda:	ff ad       	ldd	r31, Y+63	; 0x3f
    1bdc:	24 97       	sbiw	r28, 0x04	; 4
    1bde:	3f 01       	movw	r6, r30
    1be0:	66 0c       	add	r6, r6
    1be2:	77 1c       	adc	r7, r7
    1be4:	66 0c       	add	r6, r6
    1be6:	77 1c       	adc	r7, r7
    1be8:	f3 01       	movw	r30, r6
    1bea:	e0 59       	subi	r30, 0x90	; 144
    1bec:	ff 4d       	sbci	r31, 0xDF	; 223
    1bee:	60 81       	ld	r22, Z
    1bf0:	71 81       	ldd	r23, Z+1	; 0x01
    1bf2:	82 81       	ldd	r24, Z+2	; 0x02
    1bf4:	93 81       	ldd	r25, Z+3	; 0x03
    1bf6:	0e 94 52 19 	call	0x32a4	; 0x32a4 <__floatsisf>
    1bfa:	f3 01       	movw	r30, r6
    1bfc:	ed 5c       	subi	r30, 0xCD	; 205
    1bfe:	ff 4d       	sbci	r31, 0xDF	; 223
    1c00:	20 81       	ld	r18, Z
    1c02:	31 81       	ldd	r19, Z+1	; 0x01
    1c04:	42 81       	ldd	r20, Z+2	; 0x02
    1c06:	53 81       	ldd	r21, Z+3	; 0x03
    1c08:	0e 94 b7 18 	call	0x316e	; 0x316e <__divsf3>
    1c0c:	7b 01       	movw	r14, r22
    1c0e:	8c 01       	movw	r16, r24
    1c10:	c6 01       	movw	r24, r12
    1c12:	b5 01       	movw	r22, r10
    1c14:	2d a1       	ldd	r18, Y+37	; 0x25
    1c16:	3e a1       	ldd	r19, Y+38	; 0x26
    1c18:	4f a1       	ldd	r20, Y+39	; 0x27
    1c1a:	58 a5       	ldd	r21, Y+40	; 0x28
    1c1c:	0e 94 a5 1b 	call	0x374a	; 0x374a <__mulsf3>
    1c20:	9b 01       	movw	r18, r22
    1c22:	ac 01       	movw	r20, r24
    1c24:	c8 01       	movw	r24, r16
    1c26:	b7 01       	movw	r22, r14
    1c28:	0e 94 10 18 	call	0x3020	; 0x3020 <__subsf3>
    1c2c:	69 8b       	std	Y+17, r22	; 0x11
    1c2e:	7a 8b       	std	Y+18, r23	; 0x12
    1c30:	8b 8b       	std	Y+19, r24	; 0x13
    1c32:	9c 8b       	std	Y+20, r25	; 0x14

  	/* 	A vector to track the end point of each segment
		Initialize the linear axis */
	
	target[axis_linear] = position[axis_linear]/Z_STEPS_PER_MM;
    1c34:	26 96       	adiw	r28, 0x06	; 6
    1c36:	ee ad       	ldd	r30, Y+62	; 0x3e
    1c38:	ff ad       	ldd	r31, Y+63	; 0x3f
    1c3a:	26 97       	sbiw	r28, 0x06	; 6
    1c3c:	ee 0f       	add	r30, r30
    1c3e:	ff 1f       	adc	r31, r31
    1c40:	ee 0f       	add	r30, r30
    1c42:	ff 1f       	adc	r31, r31
    1c44:	8e 01       	movw	r16, r28
    1c46:	0f 5f       	subi	r16, 0xFF	; 255
    1c48:	1f 4f       	sbci	r17, 0xFF	; 255
    1c4a:	78 01       	movw	r14, r16
    1c4c:	ee 0e       	add	r14, r30
    1c4e:	ff 1e       	adc	r15, r31
    1c50:	e0 59       	subi	r30, 0x90	; 144
    1c52:	ff 4d       	sbci	r31, 0xDF	; 223
    1c54:	60 81       	ld	r22, Z
    1c56:	71 81       	ldd	r23, Z+1	; 0x01
    1c58:	82 81       	ldd	r24, Z+2	; 0x02
    1c5a:	93 81       	ldd	r25, Z+3	; 0x03
    1c5c:	0e 94 52 19 	call	0x32a4	; 0x32a4 <__floatsisf>
    1c60:	26 ef       	ldi	r18, 0xF6	; 246
    1c62:	3a e7       	ldi	r19, 0x7A	; 122
    1c64:	4d e1       	ldi	r20, 0x1D	; 29
    1c66:	54 e4       	ldi	r21, 0x44	; 68
    1c68:	0e 94 b7 18 	call	0x316e	; 0x316e <__divsf3>
    1c6c:	d7 01       	movw	r26, r14
    1c6e:	6d 93       	st	X+, r22
    1c70:	7d 93       	st	X+, r23
    1c72:	8d 93       	st	X+, r24
    1c74:	9c 93       	st	X, r25
    1c76:	13 97       	sbiw	r26, 0x03	; 3
    1c78:	1f 86       	std	Y+15, r1	; 0x0f
    1c7a:	18 8a       	std	Y+16, r1	; 0x10
  	for (i=0; i<=segments; i++) {
		target[axis_linear] += linear_per_segment;
    1c7c:	e9 a6       	std	Y+41, r14	; 0x29
    1c7e:	fa a6       	std	Y+42, r15	; 0x2a
		theta += theta_per_segment;
		target[axis_1] = center_x+sin(theta)*radius;
    1c80:	f8 01       	movw	r30, r16
    1c82:	e8 0d       	add	r30, r8
    1c84:	f9 1d       	adc	r31, r9
    1c86:	eb a7       	std	Y+43, r30	; 0x2b
    1c88:	fc a7       	std	Y+44, r31	; 0x2c
		target[axis_2] = center_y+cos(theta)*radius;
    1c8a:	60 0e       	add	r6, r16
    1c8c:	71 1e       	adc	r7, r17
    1c8e:	68 c0       	rjmp	.+208    	; 0x1d60 <mc_arc+0x31e>
  	/* 	A vector to track the end point of each segment
		Initialize the linear axis */
	
	target[axis_linear] = position[axis_linear]/Z_STEPS_PER_MM;
  	for (i=0; i<=segments; i++) {
		target[axis_linear] += linear_per_segment;
    1c90:	a9 a5       	ldd	r26, Y+41	; 0x29
    1c92:	ba a5       	ldd	r27, Y+42	; 0x2a
    1c94:	6d 91       	ld	r22, X+
    1c96:	7d 91       	ld	r23, X+
    1c98:	8d 91       	ld	r24, X+
    1c9a:	9c 91       	ld	r25, X
    1c9c:	29 8d       	ldd	r18, Y+25	; 0x19
    1c9e:	3a 8d       	ldd	r19, Y+26	; 0x1a
    1ca0:	4b 8d       	ldd	r20, Y+27	; 0x1b
    1ca2:	5c 8d       	ldd	r21, Y+28	; 0x1c
    1ca4:	0e 94 11 18 	call	0x3022	; 0x3022 <__addsf3>
    1ca8:	e9 a5       	ldd	r30, Y+41	; 0x29
    1caa:	fa a5       	ldd	r31, Y+42	; 0x2a
    1cac:	60 83       	st	Z, r22
    1cae:	71 83       	std	Z+1, r23	; 0x01
    1cb0:	82 83       	std	Z+2, r24	; 0x02
    1cb2:	93 83       	std	Z+3, r25	; 0x03
		theta += theta_per_segment;
    1cb4:	c2 01       	movw	r24, r4
    1cb6:	b1 01       	movw	r22, r2
    1cb8:	2d 8d       	ldd	r18, Y+29	; 0x1d
    1cba:	3e 8d       	ldd	r19, Y+30	; 0x1e
    1cbc:	4f 8d       	ldd	r20, Y+31	; 0x1f
    1cbe:	58 a1       	ldd	r21, Y+32	; 0x20
    1cc0:	0e 94 11 18 	call	0x3022	; 0x3022 <__addsf3>
    1cc4:	1b 01       	movw	r2, r22
    1cc6:	2c 01       	movw	r4, r24
		target[axis_1] = center_x+sin(theta)*radius;
    1cc8:	0e 94 28 1c 	call	0x3850	; 0x3850 <sin>
    1ccc:	2d a1       	ldd	r18, Y+37	; 0x25
    1cce:	3e a1       	ldd	r19, Y+38	; 0x26
    1cd0:	4f a1       	ldd	r20, Y+39	; 0x27
    1cd2:	58 a5       	ldd	r21, Y+40	; 0x28
    1cd4:	0e 94 a5 1b 	call	0x374a	; 0x374a <__mulsf3>
    1cd8:	9b 01       	movw	r18, r22
    1cda:	ac 01       	movw	r20, r24
    1cdc:	6d 89       	ldd	r22, Y+21	; 0x15
    1cde:	7e 89       	ldd	r23, Y+22	; 0x16
    1ce0:	8f 89       	ldd	r24, Y+23	; 0x17
    1ce2:	98 8d       	ldd	r25, Y+24	; 0x18
    1ce4:	0e 94 11 18 	call	0x3022	; 0x3022 <__addsf3>
    1ce8:	ab a5       	ldd	r26, Y+43	; 0x2b
    1cea:	bc a5       	ldd	r27, Y+44	; 0x2c
    1cec:	6d 93       	st	X+, r22
    1cee:	7d 93       	st	X+, r23
    1cf0:	8d 93       	st	X+, r24
    1cf2:	9c 93       	st	X, r25
    1cf4:	13 97       	sbiw	r26, 0x03	; 3
		target[axis_2] = center_y+cos(theta)*radius;
    1cf6:	c2 01       	movw	r24, r4
    1cf8:	b1 01       	movw	r22, r2
    1cfa:	0e 94 b4 18 	call	0x3168	; 0x3168 <cos>
    1cfe:	2d a1       	ldd	r18, Y+37	; 0x25
    1d00:	3e a1       	ldd	r19, Y+38	; 0x26
    1d02:	4f a1       	ldd	r20, Y+39	; 0x27
    1d04:	58 a5       	ldd	r21, Y+40	; 0x28
    1d06:	0e 94 a5 1b 	call	0x374a	; 0x374a <__mulsf3>
    1d0a:	9b 01       	movw	r18, r22
    1d0c:	ac 01       	movw	r20, r24
    1d0e:	69 89       	ldd	r22, Y+17	; 0x11
    1d10:	7a 89       	ldd	r23, Y+18	; 0x12
    1d12:	8b 89       	ldd	r24, Y+19	; 0x13
    1d14:	9c 89       	ldd	r25, Y+20	; 0x14
    1d16:	0e 94 11 18 	call	0x3022	; 0x3022 <__addsf3>
    1d1a:	f3 01       	movw	r30, r6
    1d1c:	60 83       	st	Z, r22
    1d1e:	71 83       	std	Z+1, r23	; 0x01
    1d20:	82 83       	std	Z+2, r24	; 0x02
    1d22:	93 83       	std	Z+3, r25	; 0x03
		mc_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], feed_rate, invert_feed_rate);
    1d24:	69 81       	ldd	r22, Y+1	; 0x01
    1d26:	7a 81       	ldd	r23, Y+2	; 0x02
    1d28:	8b 81       	ldd	r24, Y+3	; 0x03
    1d2a:	9c 81       	ldd	r25, Y+4	; 0x04
    1d2c:	2d 81       	ldd	r18, Y+5	; 0x05
    1d2e:	3e 81       	ldd	r19, Y+6	; 0x06
    1d30:	4f 81       	ldd	r20, Y+7	; 0x07
    1d32:	58 85       	ldd	r21, Y+8	; 0x08
    1d34:	e9 84       	ldd	r14, Y+9	; 0x09
    1d36:	fa 84       	ldd	r15, Y+10	; 0x0a
    1d38:	0b 85       	ldd	r16, Y+11	; 0x0b
    1d3a:	1c 85       	ldd	r17, Y+12	; 0x0c
    1d3c:	2a 96       	adiw	r28, 0x0a	; 10
    1d3e:	ac ac       	ldd	r10, Y+60	; 0x3c
    1d40:	bd ac       	ldd	r11, Y+61	; 0x3d
    1d42:	ce ac       	ldd	r12, Y+62	; 0x3e
    1d44:	df ac       	ldd	r13, Y+63	; 0x3f
    1d46:	2a 97       	sbiw	r28, 0x0a	; 10
    1d48:	2c 96       	adiw	r28, 0x0c	; 12
    1d4a:	8e ac       	ldd	r8, Y+62	; 0x3e
    1d4c:	9f ac       	ldd	r9, Y+63	; 0x3f
    1d4e:	2c 97       	sbiw	r28, 0x0c	; 12
    1d50:	0e 94 f8 0b 	call	0x17f0	; 0x17f0 <mc_line>

  	/* 	A vector to track the end point of each segment
		Initialize the linear axis */
	
	target[axis_linear] = position[axis_linear]/Z_STEPS_PER_MM;
  	for (i=0; i<=segments; i++) {
    1d54:	2f 85       	ldd	r18, Y+15	; 0x0f
    1d56:	38 89       	ldd	r19, Y+16	; 0x10
    1d58:	2f 5f       	subi	r18, 0xFF	; 255
    1d5a:	3f 4f       	sbci	r19, 0xFF	; 255
    1d5c:	2f 87       	std	Y+15, r18	; 0x0f
    1d5e:	38 8b       	std	Y+16, r19	; 0x10
    1d60:	8f 85       	ldd	r24, Y+15	; 0x0f
    1d62:	98 89       	ldd	r25, Y+16	; 0x10
    1d64:	ad 85       	ldd	r26, Y+13	; 0x0d
    1d66:	be 85       	ldd	r27, Y+14	; 0x0e
    1d68:	a8 17       	cp	r26, r24
    1d6a:	b9 07       	cpc	r27, r25
    1d6c:	08 f0       	brcs	.+2      	; 0x1d70 <mc_arc+0x32e>
    1d6e:	90 cf       	rjmp	.-224    	; 0x1c90 <mc_arc+0x24e>
		theta += theta_per_segment;
		target[axis_1] = center_x+sin(theta)*radius;
		target[axis_2] = center_y+cos(theta)*radius;
		mc_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], feed_rate, invert_feed_rate);
  	}
}
    1d70:	ac 96       	adiw	r28, 0x2c	; 44
    1d72:	cd bf       	out	0x3d, r28	; 61
    1d74:	de bf       	out	0x3e, r29	; 62
    1d76:	cf 91       	pop	r28
    1d78:	df 91       	pop	r29
    1d7a:	1f 91       	pop	r17
    1d7c:	0f 91       	pop	r16
    1d7e:	ff 90       	pop	r15
    1d80:	ef 90       	pop	r14
    1d82:	df 90       	pop	r13
    1d84:	cf 90       	pop	r12
    1d86:	bf 90       	pop	r11
    1d88:	af 90       	pop	r10
    1d8a:	9f 90       	pop	r9
    1d8c:	8f 90       	pop	r8
    1d8e:	7f 90       	pop	r7
    1d90:	6f 90       	pop	r6
    1d92:	5f 90       	pop	r5
    1d94:	4f 90       	pop	r4
    1d96:	3f 90       	pop	r3
    1d98:	2f 90       	pop	r2
    1d9a:	08 95       	ret

00001d9c <mc_dwell>:


/* mc_dwell() */

void mc_dwell(uint32_t milliseconds) 
{
    1d9c:	af 92       	push	r10
    1d9e:	bf 92       	push	r11
    1da0:	cf 92       	push	r12
    1da2:	df 92       	push	r13
    1da4:	ef 92       	push	r14
    1da6:	ff 92       	push	r15
    1da8:	0f 93       	push	r16
    1daa:	1f 93       	push	r17
    1dac:	7b 01       	movw	r14, r22
    1dae:	8c 01       	movw	r16, r24
	st_synchronize();
    1db0:	0e 94 96 13 	call	0x272c	; 0x272c <st_synchronize>
	_delay_ms(milliseconds);
    1db4:	c8 01       	movw	r24, r16
    1db6:	b7 01       	movw	r22, r14
    1db8:	0e 94 50 19 	call	0x32a0	; 0x32a0 <__floatunsisf>
    1dbc:	5b 01       	movw	r10, r22
    1dbe:	6c 01       	movw	r12, r24
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1dc0:	20 e0       	ldi	r18, 0x00	; 0
    1dc2:	30 e0       	ldi	r19, 0x00	; 0
    1dc4:	4a ef       	ldi	r20, 0xFA	; 250
    1dc6:	55 e4       	ldi	r21, 0x45	; 69
    1dc8:	0e 94 a5 1b 	call	0x374a	; 0x374a <__mulsf3>
    1dcc:	7b 01       	movw	r14, r22
    1dce:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    1dd0:	20 e0       	ldi	r18, 0x00	; 0
    1dd2:	30 e0       	ldi	r19, 0x00	; 0
    1dd4:	40 e8       	ldi	r20, 0x80	; 128
    1dd6:	5f e3       	ldi	r21, 0x3F	; 63
    1dd8:	0e 94 b0 18 	call	0x3160	; 0x3160 <__cmpsf2>
    1ddc:	88 23       	and	r24, r24
    1dde:	1c f4       	brge	.+6      	; 0x1de6 <mc_dwell+0x4a>
    1de0:	61 e0       	ldi	r22, 0x01	; 1
    1de2:	70 e0       	ldi	r23, 0x00	; 0
    1de4:	24 c0       	rjmp	.+72     	; 0x1e2e <mc_dwell+0x92>
		__ticks = 1;
	else if (__tmp > 65535)
    1de6:	c8 01       	movw	r24, r16
    1de8:	b7 01       	movw	r22, r14
    1dea:	20 e0       	ldi	r18, 0x00	; 0
    1dec:	3f ef       	ldi	r19, 0xFF	; 255
    1dee:	4f e7       	ldi	r20, 0x7F	; 127
    1df0:	57 e4       	ldi	r21, 0x47	; 71
    1df2:	0e 94 a0 1a 	call	0x3540	; 0x3540 <__gesf2>
    1df6:	18 16       	cp	r1, r24
    1df8:	b4 f4       	brge	.+44     	; 0x1e26 <mc_dwell+0x8a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1dfa:	c6 01       	movw	r24, r12
    1dfc:	b5 01       	movw	r22, r10
    1dfe:	20 e0       	ldi	r18, 0x00	; 0
    1e00:	30 e0       	ldi	r19, 0x00	; 0
    1e02:	40 e2       	ldi	r20, 0x20	; 32
    1e04:	51 e4       	ldi	r21, 0x41	; 65
    1e06:	0e 94 a5 1b 	call	0x374a	; 0x374a <__mulsf3>
    1e0a:	0e 94 24 19 	call	0x3248	; 0x3248 <__fixunssfsi>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1e0e:	80 e2       	ldi	r24, 0x20	; 32
    1e10:	93 e0       	ldi	r25, 0x03	; 3
    1e12:	05 c0       	rjmp	.+10     	; 0x1e1e <mc_dwell+0x82>
    1e14:	fc 01       	movw	r30, r24
    1e16:	31 97       	sbiw	r30, 0x01	; 1
    1e18:	f1 f7       	brne	.-4      	; 0x1e16 <mc_dwell+0x7a>
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1e1a:	61 50       	subi	r22, 0x01	; 1
    1e1c:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1e1e:	61 15       	cp	r22, r1
    1e20:	71 05       	cpc	r23, r1
    1e22:	c1 f7       	brne	.-16     	; 0x1e14 <mc_dwell+0x78>
    1e24:	07 c0       	rjmp	.+14     	; 0x1e34 <mc_dwell+0x98>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1e26:	c8 01       	movw	r24, r16
    1e28:	b7 01       	movw	r22, r14
    1e2a:	0e 94 24 19 	call	0x3248	; 0x3248 <__fixunssfsi>
    1e2e:	cb 01       	movw	r24, r22
    1e30:	01 97       	sbiw	r24, 0x01	; 1
    1e32:	f1 f7       	brne	.-4      	; 0x1e30 <mc_dwell+0x94>
}
    1e34:	1f 91       	pop	r17
    1e36:	0f 91       	pop	r16
    1e38:	ff 90       	pop	r15
    1e3a:	ef 90       	pop	r14
    1e3c:	df 90       	pop	r13
    1e3e:	cf 90       	pop	r12
    1e40:	bf 90       	pop	r11
    1e42:	af 90       	pop	r10
    1e44:	08 95       	ret

00001e46 <PMIC_SetVectorLocationToBoot>:
 *  Change Protection register before writing the CTRL register. Interrupts are
 *  automatically ignored during the change enable period.
 */
void PMIC_SetVectorLocationToBoot( void )
{
	uint8_t temp = PMIC.CTRL | PMIC_IVSEL_bm;
    1e46:	e0 ea       	ldi	r30, 0xA0	; 160
    1e48:	f0 e0       	ldi	r31, 0x00	; 0
    1e4a:	82 81       	ldd	r24, Z+2	; 0x02
    1e4c:	80 64       	ori	r24, 0x40	; 64
	CCP = CCP_IOREG_gc;
    1e4e:	98 ed       	ldi	r25, 0xD8	; 216
    1e50:	94 bf       	out	0x34, r25	; 52
	PMIC.CTRL = temp;
    1e52:	82 83       	std	Z+2, r24	; 0x02
}
    1e54:	08 95       	ret

00001e56 <PMIC_SetVectorLocationToApplication>:
 *  Change Protection register before writing the CTRL register. Interrupts are
 *  automatically ignored during the change enable period.
 */
void PMIC_SetVectorLocationToApplication( void )
{
	uint8_t temp = PMIC.CTRL & ~PMIC_IVSEL_bm;
    1e56:	e0 ea       	ldi	r30, 0xA0	; 160
    1e58:	f0 e0       	ldi	r31, 0x00	; 0
    1e5a:	82 81       	ldd	r24, Z+2	; 0x02
    1e5c:	8f 7b       	andi	r24, 0xBF	; 191
	CCP = CCP_IOREG_gc;
    1e5e:	98 ed       	ldi	r25, 0xD8	; 216
    1e60:	94 bf       	out	0x34, r25	; 52
	PMIC.CTRL = temp;
    1e62:	82 83       	std	Z+2, r24	; 0x02
}
    1e64:	08 95       	ret

00001e66 <prompt>:
char textline[LINE_BUFFER_SIZE];
uint8_t char_counter = 0;

void prompt() 
{
	printPgmString(PSTR("TinyG>> "));
    1e66:	81 ee       	ldi	r24, 0xE1	; 225
    1e68:	93 e0       	ldi	r25, 0x03	; 3
    1e6a:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
}
    1e6e:	08 95       	ret

00001e70 <sp_process>:
}

/* sp_process() - process serial prototol */

void sp_process()
{
    1e70:	1f 93       	push	r17
    1e72:	4c c0       	rjmp	.+152    	; 0x1f0c <sp_process+0x9c>
	char c;

	while((c = serialRead()) != 0x04) {
		if (TRUE) {							// echo mode
			printByte(c);
    1e74:	81 2f       	mov	r24, r17
    1e76:	0e 94 ea 16 	call	0x2dd4	; 0x2dd4 <serialWrite>
		}			
		if((c == '\r') || (c == '\n') || (c == ';')) {  // Line complete. Execute!
    1e7a:	1d 30       	cpi	r17, 0x0D	; 13
    1e7c:	21 f0       	breq	.+8      	; 0x1e86 <sp_process+0x16>
    1e7e:	1a 30       	cpi	r17, 0x0A	; 10
    1e80:	11 f0       	breq	.+4      	; 0x1e86 <sp_process+0x16>
    1e82:	1b 33       	cpi	r17, 0x3B	; 59
    1e84:	f9 f4       	brne	.+62     	; 0x1ec4 <sp_process+0x54>
			textline[char_counter] = 0;				// terminate and echo the string
    1e86:	e0 91 2a 20 	lds	r30, 0x202A
    1e8a:	f0 e0       	ldi	r31, 0x00	; 0
    1e8c:	e4 58       	subi	r30, 0x84	; 132
    1e8e:	ff 4d       	sbci	r31, 0xDF	; 223
    1e90:	10 82       	st	Z, r1
			printPgmString(PSTR("\r\n EXEC>> "));
    1e92:	8f ea       	ldi	r24, 0xAF	; 175
    1e94:	93 e0       	ldi	r25, 0x03	; 3
    1e96:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
			printString(textline);
    1e9a:	8c e7       	ldi	r24, 0x7C	; 124
    1e9c:	90 e2       	ldi	r25, 0x20	; 32
    1e9e:	0e 94 13 17 	call	0x2e26	; 0x2e26 <printString>
			printPgmString(PSTR("\r\n"));
    1ea2:	8c ea       	ldi	r24, 0xAC	; 172
    1ea4:	93 e0       	ldi	r25, 0x03	; 3
    1ea6:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
			gc_execute_line(textline);				// execute the command
    1eaa:	8c e7       	ldi	r24, 0x7C	; 124
    1eac:	90 e2       	ldi	r25, 0x20	; 32
    1eae:	0e 94 7f 03 	call	0x6fe	; 0x6fe <gc_execute_line>
			char_counter = 0;
    1eb2:	10 92 2a 20 	sts	0x202A, r1
			textline[char_counter] = 0;				// reset the buffer
    1eb6:	10 92 7c 20 	sts	0x207C, r1
char textline[LINE_BUFFER_SIZE];
uint8_t char_counter = 0;

void prompt() 
{
	printPgmString(PSTR("TinyG>> "));
    1eba:	81 ee       	ldi	r24, 0xE1	; 225
    1ebc:	93 e0       	ldi	r25, 0x03	; 3
    1ebe:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
    1ec2:	24 c0       	rjmp	.+72     	; 0x1f0c <sp_process+0x9c>
			printPgmString(PSTR("\r\n"));
			gc_execute_line(textline);				// execute the command
			char_counter = 0;
			textline[char_counter] = 0;				// reset the buffer
      		prompt();							
		} else if ((c == 0x08) || (c == 0x7F)) {  	// backspace or delete
    1ec4:	18 30       	cpi	r17, 0x08	; 8
    1ec6:	11 f0       	breq	.+4      	; 0x1ecc <sp_process+0x5c>
    1ec8:	1f 37       	cpi	r17, 0x7F	; 127
    1eca:	51 f4       	brne	.+20     	; 0x1ee0 <sp_process+0x70>
			textline[--char_counter] = 0;
    1ecc:	e0 91 2a 20 	lds	r30, 0x202A
    1ed0:	e1 50       	subi	r30, 0x01	; 1
    1ed2:	e0 93 2a 20 	sts	0x202A, r30
    1ed6:	f0 e0       	ldi	r31, 0x00	; 0
    1ed8:	e4 58       	subi	r30, 0x84	; 132
    1eda:	ff 4d       	sbci	r31, 0xDF	; 223
    1edc:	10 82       	st	Z, r1
    1ede:	16 c0       	rjmp	.+44     	; 0x1f0c <sp_process+0x9c>
		} else if (c <= ' ') { 						// throw away WS & ctrl chars
    1ee0:	11 32       	cpi	r17, 0x21	; 33
    1ee2:	a0 f0       	brcs	.+40     	; 0x1f0c <sp_process+0x9c>
		} else if (c >= 'a' && c <= 'z') {			// convert lower to upper
    1ee4:	81 2f       	mov	r24, r17
    1ee6:	81 56       	subi	r24, 0x61	; 97
    1ee8:	90 91 2a 20 	lds	r25, 0x202A
    1eec:	8a 31       	cpi	r24, 0x1A	; 26
    1eee:	30 f4       	brcc	.+12     	; 0x1efc <sp_process+0x8c>
			textline[char_counter++] = c-'a'+'A';
    1ef0:	e9 2f       	mov	r30, r25
    1ef2:	f0 e0       	ldi	r31, 0x00	; 0
    1ef4:	e4 58       	subi	r30, 0x84	; 132
    1ef6:	ff 4d       	sbci	r31, 0xDF	; 223
    1ef8:	10 52       	subi	r17, 0x20	; 32
    1efa:	04 c0       	rjmp	.+8      	; 0x1f04 <sp_process+0x94>
		} else {
			textline[char_counter++] = c;
    1efc:	e9 2f       	mov	r30, r25
    1efe:	f0 e0       	ldi	r31, 0x00	; 0
    1f00:	e4 58       	subi	r30, 0x84	; 132
    1f02:	ff 4d       	sbci	r31, 0xDF	; 223
    1f04:	10 83       	st	Z, r17
    1f06:	9f 5f       	subi	r25, 0xFF	; 255
    1f08:	90 93 2a 20 	sts	0x202A, r25

void sp_process()
{
	char c;

	while((c = serialRead()) != 0x04) {
    1f0c:	0e 94 f9 16 	call	0x2df2	; 0x2df2 <serialRead>
    1f10:	18 2f       	mov	r17, r24
    1f12:	84 30       	cpi	r24, 0x04	; 4
    1f14:	09 f0       	breq	.+2      	; 0x1f18 <sp_process+0xa8>
    1f16:	ae cf       	rjmp	.-164    	; 0x1e74 <sp_process+0x4>
			textline[char_counter++] = c-'a'+'A';
		} else {
			textline[char_counter++] = c;
		}
	}
}
    1f18:	1f 91       	pop	r17
    1f1a:	08 95       	ret

00001f1c <sp_init>:
	printPgmString(PSTR("TinyG>> "));
}

void sp_init() 
{
	beginSerial(USB_BAUD_RATE);
    1f1c:	60 e0       	ldi	r22, 0x00	; 0
    1f1e:	72 ec       	ldi	r23, 0xC2	; 194
    1f20:	81 e0       	ldi	r24, 0x01	; 1
    1f22:	90 e0       	ldi	r25, 0x00	; 0
    1f24:	0e 94 6a 16 	call	0x2cd4	; 0x2cd4 <beginSerial>
	printPgmString(PSTR("\r\nTinyG [TEST MODE] - Version "));
    1f28:	82 ec       	ldi	r24, 0xC2	; 194
    1f2a:	93 e0       	ldi	r25, 0x03	; 3
    1f2c:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
	printPgmString(PSTR(TINYG_VERSION));
    1f30:	8d eb       	ldi	r24, 0xBD	; 189
    1f32:	93 e0       	ldi	r25, 0x03	; 3
    1f34:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
	printPgmString(PSTR("\r\n"));
    1f38:	8a eb       	ldi	r24, 0xBA	; 186
    1f3a:	93 e0       	ldi	r25, 0x03	; 3
    1f3c:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
	textline[0] = 0;		// initialize line buffer
    1f40:	10 92 7c 20 	sts	0x207C, r1
char textline[LINE_BUFFER_SIZE];
uint8_t char_counter = 0;

void prompt() 
{
	printPgmString(PSTR("TinyG>> "));
    1f44:	81 ee       	ldi	r24, 0xE1	; 225
    1f46:	93 e0       	ldi	r25, 0x03	; 3
    1f48:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
	printPgmString(PSTR("\r\nTinyG [TEST MODE] - Version "));
	printPgmString(PSTR(TINYG_VERSION));
	printPgmString(PSTR("\r\n"));
	textline[0] = 0;		// initialize line buffer
	prompt();
}
    1f4c:	08 95       	ret

00001f4e <spindle_init>:
	See config.h for settings
*/

void spindle_init()
{
	SPINDLE_ENABLE_PORT.DIRSET = SPINDLE_ENABLE_BIT_bm;
    1f4e:	e0 e6       	ldi	r30, 0x60	; 96
    1f50:	f6 e0       	ldi	r31, 0x06	; 6
    1f52:	80 e4       	ldi	r24, 0x40	; 64
    1f54:	81 83       	std	Z+1, r24	; 0x01
	SPINDLE_DIRECTION_PORT.DIRSET = SPINDLE_DIRECTION_BIT_bm;
    1f56:	80 e8       	ldi	r24, 0x80	; 128
    1f58:	81 83       	std	Z+1, r24	; 0x01
}
    1f5a:	08 95       	ret

00001f5c <spindle_run>:

void spindle_run(int direction, uint32_t rpm) 
{
	if(direction >= 0) {
    1f5c:	97 fd       	sbrc	r25, 7
    1f5e:	05 c0       	rjmp	.+10     	; 0x1f6a <spindle_run+0xe>
    	SPINDLE_DIRECTION_PORT.OUTSET = SPINDLE_DIRECTION_BIT_bm;
    1f60:	80 e8       	ldi	r24, 0x80	; 128
    1f62:	e0 e6       	ldi	r30, 0x60	; 96
    1f64:	f6 e0       	ldi	r31, 0x06	; 6
    1f66:	85 83       	std	Z+5, r24	; 0x05
    1f68:	04 c0       	rjmp	.+8      	; 0x1f72 <spindle_run+0x16>
	} else {
    	SPINDLE_DIRECTION_PORT.OUTCLR = SPINDLE_DIRECTION_BIT_bm;
    1f6a:	80 e8       	ldi	r24, 0x80	; 128
    1f6c:	e0 e6       	ldi	r30, 0x60	; 96
    1f6e:	f6 e0       	ldi	r31, 0x06	; 6
    1f70:	86 83       	std	Z+6, r24	; 0x06
	}
	SPINDLE_ENABLE_PORT.OUTSET = SPINDLE_ENABLE_BIT_bm;
    1f72:	80 e4       	ldi	r24, 0x40	; 64
    1f74:	e0 e6       	ldi	r30, 0x60	; 96
    1f76:	f6 e0       	ldi	r31, 0x06	; 6
    1f78:	85 83       	std	Z+5, r24	; 0x05
}
    1f7a:	08 95       	ret

00001f7c <spindle_stop>:

void spindle_stop()
{
	SPINDLE_ENABLE_PORT.OUTCLR = SPINDLE_ENABLE_BIT_bm;
    1f7c:	80 e4       	ldi	r24, 0x40	; 64
    1f7e:	e0 e6       	ldi	r30, 0x60	; 96
    1f80:	f6 e0       	ldi	r31, 0x06	; 6
    1f82:	86 83       	std	Z+6, r24	; 0x06
}
    1f84:	08 95       	ret

00001f86 <st_motor_test>:


/* st_motor_test() - test motor subsystem */

void st_motor_test() {
	ax.x.counter = 0x00000100;					// number of steps
    1f86:	20 e0       	ldi	r18, 0x00	; 0
    1f88:	31 e0       	ldi	r19, 0x01	; 1
    1f8a:	40 e0       	ldi	r20, 0x00	; 0
    1f8c:	50 e0       	ldi	r21, 0x00	; 0
    1f8e:	20 93 fd 20 	sts	0x20FD, r18
    1f92:	30 93 fe 20 	sts	0x20FE, r19
    1f96:	40 93 ff 20 	sts	0x20FF, r20
    1f9a:	50 93 00 21 	sts	0x2100, r21
	ax.x.timer->CTRLA = TC_CLK_DIV_1;			// clock division ratio
    1f9e:	e0 91 18 21 	lds	r30, 0x2118
    1fa2:	f0 91 19 21 	lds	r31, 0x2119
    1fa6:	91 e0       	ldi	r25, 0x01	; 1
    1fa8:	90 83       	st	Z, r25
	ax.x.timer->PERH = 0x10;					// step rate (period) high
    1faa:	e0 91 18 21 	lds	r30, 0x2118
    1fae:	f0 91 19 21 	lds	r31, 0x2119
    1fb2:	80 e1       	ldi	r24, 0x10	; 16
    1fb4:	87 a3       	std	Z+39, r24	; 0x27
	ax.x.timer->PERL = 0x00;					// step rate (period) low
    1fb6:	16 a2       	std	Z+38, r1	; 0x26

	ax.y.counter = 0x00000100;					// number of steps
    1fb8:	20 93 1a 21 	sts	0x211A, r18
    1fbc:	30 93 1b 21 	sts	0x211B, r19
    1fc0:	40 93 1c 21 	sts	0x211C, r20
    1fc4:	50 93 1d 21 	sts	0x211D, r21
	ax.y.timer->CTRLA = TC_CLK_DIV_1;			// clock division ratio
    1fc8:	e0 91 35 21 	lds	r30, 0x2135
    1fcc:	f0 91 36 21 	lds	r31, 0x2136
    1fd0:	90 83       	st	Z, r25
	ax.y.timer->PERH = 0x20;					// step rate (period) high
    1fd2:	e0 91 35 21 	lds	r30, 0x2135
    1fd6:	f0 91 36 21 	lds	r31, 0x2136
    1fda:	80 e2       	ldi	r24, 0x20	; 32
    1fdc:	87 a3       	std	Z+39, r24	; 0x27
	ax.y.timer->PERL = 0x00;					// step rate (period) low
    1fde:	16 a2       	std	Z+38, r1	; 0x26

	ax.z.counter = 0x00000100;					// number of steps
    1fe0:	20 93 37 21 	sts	0x2137, r18
    1fe4:	30 93 38 21 	sts	0x2138, r19
    1fe8:	40 93 39 21 	sts	0x2139, r20
    1fec:	50 93 3a 21 	sts	0x213A, r21
	ax.z.timer->CTRLA = TC_CLK_DIV_1;			// clock division ratio
    1ff0:	e0 91 52 21 	lds	r30, 0x2152
    1ff4:	f0 91 53 21 	lds	r31, 0x2153
    1ff8:	90 83       	st	Z, r25
	ax.z.timer->PERH = 0x30;					// step rate (period) high
    1ffa:	e0 91 52 21 	lds	r30, 0x2152
    1ffe:	f0 91 53 21 	lds	r31, 0x2153
    2002:	80 e3       	ldi	r24, 0x30	; 48
    2004:	87 a3       	std	Z+39, r24	; 0x27
	ax.z.timer->PERL = 0x00;					// step rate (period) low
    2006:	16 a2       	std	Z+38, r1	; 0x26

	ax.a.counter = 0x00000100;					// number of steps
    2008:	20 93 54 21 	sts	0x2154, r18
    200c:	30 93 55 21 	sts	0x2155, r19
    2010:	40 93 56 21 	sts	0x2156, r20
    2014:	50 93 57 21 	sts	0x2157, r21
	ax.a.timer->CTRLA = TC_CLK_DIV_1;			// clock division ratio
    2018:	e0 91 6f 21 	lds	r30, 0x216F
    201c:	f0 91 70 21 	lds	r31, 0x2170
    2020:	90 83       	st	Z, r25
	ax.a.timer->PERH = 0x40;					// step rate (period) high
    2022:	e0 91 6f 21 	lds	r30, 0x216F
    2026:	f0 91 70 21 	lds	r31, 0x2170
    202a:	80 e4       	ldi	r24, 0x40	; 64
    202c:	87 a3       	std	Z+39, r24	; 0x27
	ax.a.timer->PERL = 0x00;					// step rate (period) low
    202e:	16 a2       	std	Z+38, r1	; 0x26

	ax.active_axes |= (X_BIT_bm | Y_BIT_bm | Z_BIT_bm | A_BIT_bm);
    2030:	80 91 71 21 	lds	r24, 0x2171
    2034:	8f 60       	ori	r24, 0x0F	; 15
    2036:	80 93 71 21 	sts	0x2171, r24

}
    203a:	08 95       	ret

0000203c <st_init>:
	- each axis is enabled (

*/

void st_init()
{
    203c:	6f 92       	push	r6
    203e:	7f 92       	push	r7
    2040:	8f 92       	push	r8
    2042:	9f 92       	push	r9
    2044:	af 92       	push	r10
    2046:	bf 92       	push	r11
    2048:	cf 92       	push	r12
    204a:	df 92       	push	r13
    204c:	ef 92       	push	r14
    204e:	ff 92       	push	r15
    2050:	0f 93       	push	r16
    2052:	1f 93       	push	r17
	ax.active_axes = 0;							// clear all active bits
    2054:	10 92 71 21 	sts	0x2171, r1

 /* initialize X axis */
 	// operating variables
	ax.x.counter = 0;							// down counts timer steps 
    2058:	10 92 fd 20 	sts	0x20FD, r1
    205c:	10 92 fe 20 	sts	0x20FE, r1
    2060:	10 92 ff 20 	sts	0x20FF, r1
    2064:	10 92 00 21 	sts	0x2100, r1

	// configuration variables
	ax.x.microsteps = X_MICROSTEPS;
    2068:	78 e0       	ldi	r23, 0x08	; 8
    206a:	70 93 01 21 	sts	0x2101, r23
	ax.x.max_seek_rate = X_SEEK_WHOLE_STEPS_PER_SEC;
    206e:	0f 2e       	mov	r0, r31
    2070:	f0 e0       	ldi	r31, 0x00	; 0
    2072:	6f 2e       	mov	r6, r31
    2074:	f0 e0       	ldi	r31, 0x00	; 0
    2076:	7f 2e       	mov	r7, r31
    2078:	f8 ec       	ldi	r31, 0xC8	; 200
    207a:	8f 2e       	mov	r8, r31
    207c:	f4 e4       	ldi	r31, 0x44	; 68
    207e:	9f 2e       	mov	r9, r31
    2080:	f0 2d       	mov	r31, r0
    2082:	60 92 02 21 	sts	0x2102, r6
    2086:	70 92 03 21 	sts	0x2103, r7
    208a:	80 92 04 21 	sts	0x2104, r8
    208e:	90 92 05 21 	sts	0x2105, r9
	ax.x.max_seek_steps = X_STEPS_PER_MM / DEFAULT_FEEDRATE;
    2092:	2a e1       	ldi	r18, 0x1A	; 26
    2094:	32 e6       	ldi	r19, 0x62	; 98
    2096:	46 e0       	ldi	r20, 0x06	; 6
    2098:	50 e4       	ldi	r21, 0x40	; 64
    209a:	20 93 06 21 	sts	0x2106, r18
    209e:	30 93 07 21 	sts	0x2107, r19
    20a2:	40 93 08 21 	sts	0x2108, r20
    20a6:	50 93 09 21 	sts	0x2109, r21
	ax.x.max_feed_rate = DEFAULT_FEEDRATE;
    20aa:	0f 2e       	mov	r0, r31
    20ac:	f0 e0       	ldi	r31, 0x00	; 0
    20ae:	af 2e       	mov	r10, r31
    20b0:	f0 e0       	ldi	r31, 0x00	; 0
    20b2:	bf 2e       	mov	r11, r31
    20b4:	f6 e9       	ldi	r31, 0x96	; 150
    20b6:	cf 2e       	mov	r12, r31
    20b8:	f3 e4       	ldi	r31, 0x43	; 67
    20ba:	df 2e       	mov	r13, r31
    20bc:	f0 2d       	mov	r31, r0
    20be:	a0 92 0a 21 	sts	0x210A, r10
    20c2:	b0 92 0b 21 	sts	0x210B, r11
    20c6:	c0 92 0c 21 	sts	0x210C, r12
    20ca:	d0 92 0d 21 	sts	0x210D, r13
	ax.x.max_feed_steps = X_STEPS_PER_MM / DEFAULT_FEEDRATE;
    20ce:	20 93 0e 21 	sts	0x210E, r18
    20d2:	30 93 0f 21 	sts	0x210F, r19
    20d6:	40 93 10 21 	sts	0x2110, r20
    20da:	50 93 11 21 	sts	0x2111, r21
	ax.x.steps_per_mm = X_STEPS_PER_MM;
    20de:	0f 2e       	mov	r0, r31
    20e0:	f6 ef       	ldi	r31, 0xF6	; 246
    20e2:	ef 2e       	mov	r14, r31
    20e4:	fa e7       	ldi	r31, 0x7A	; 122
    20e6:	ff 2e       	mov	r15, r31
    20e8:	fd e1       	ldi	r31, 0x1D	; 29
    20ea:	0f 2f       	mov	r16, r31
    20ec:	f4 e4       	ldi	r31, 0x44	; 68
    20ee:	1f 2f       	mov	r17, r31
    20f0:	f0 2d       	mov	r31, r0
    20f2:	e0 92 12 21 	sts	0x2112, r14
    20f6:	f0 92 13 21 	sts	0x2113, r15
    20fa:	00 93 14 21 	sts	0x2114, r16
    20fe:	10 93 15 21 	sts	0x2115, r17

	// motor control port bound to structure 
	ax.x.port = &X_MOTOR_PORT;
    2102:	e0 e0       	ldi	r30, 0x00	; 0
    2104:	f6 e0       	ldi	r31, 0x06	; 6
    2106:	e0 93 16 21 	sts	0x2116, r30
    210a:	f0 93 17 21 	sts	0x2117, r31
	ax.x.port->DIR = X_MOTOR_PORT_DIR_gm;		// set inputs and outputs
    210e:	6f e3       	ldi	r22, 0x3F	; 63
    2110:	60 83       	st	Z, r22
	ax.x.port->OUT = 0;							// set port bits to zero initially
    2112:	14 82       	std	Z+4, r1	; 0x04
	ax.x.port->OUT |= MICROSTEP_EIGHTH_bm;		// set microstep bits to eighth
    2114:	84 81       	ldd	r24, Z+4	; 0x04
    2116:	88 61       	ori	r24, 0x18	; 24
    2118:	84 83       	std	Z+4, r24	; 0x04

	// motor control timer channel bound to structure
	ax.x.timer = &X_TIMER;
    211a:	e0 e0       	ldi	r30, 0x00	; 0
    211c:	f8 e0       	ldi	r31, 0x08	; 8
    211e:	e0 93 18 21 	sts	0x2118, r30
    2122:	f0 93 19 21 	sts	0x2119, r31
	ax.x.timer->CTRLA = TC_CLK_OFF;				// turn motor off
    2126:	10 82       	st	Z, r1
	ax.x.timer->CTRLB = TC_WGMODE;				// waveform generation mode
    2128:	11 82       	std	Z+1, r1	; 0x01
	ax.x.timer->INTCTRLA = TC_OVFINTLVL;		// interrupt mode
    212a:	93 e0       	ldi	r25, 0x03	; 3
    212c:	96 83       	std	Z+6, r25	; 0x06
	ax.x.timer->PERH = 0x00;					// period high
    212e:	17 a2       	std	Z+39, r1	; 0x27
	ax.x.timer->PERL = 0x00;					// period low
    2130:	16 a2       	std	Z+38, r1	; 0x26

 /* initialize Y axis */
	ax.y.counter = 0;
    2132:	10 92 1a 21 	sts	0x211A, r1
    2136:	10 92 1b 21 	sts	0x211B, r1
    213a:	10 92 1c 21 	sts	0x211C, r1
    213e:	10 92 1d 21 	sts	0x211D, r1

	ax.y.microsteps = Y_MICROSTEPS;
    2142:	70 93 1e 21 	sts	0x211E, r23
	ax.y.max_seek_rate = Y_SEEK_WHOLE_STEPS_PER_SEC;
    2146:	60 92 1f 21 	sts	0x211F, r6
    214a:	70 92 20 21 	sts	0x2120, r7
    214e:	80 92 21 21 	sts	0x2121, r8
    2152:	90 92 22 21 	sts	0x2122, r9
	ax.y.max_seek_steps = Y_STEPS_PER_MM / DEFAULT_FEEDRATE;
    2156:	20 93 23 21 	sts	0x2123, r18
    215a:	30 93 24 21 	sts	0x2124, r19
    215e:	40 93 25 21 	sts	0x2125, r20
    2162:	50 93 26 21 	sts	0x2126, r21
	ax.y.max_feed_rate = DEFAULT_FEEDRATE;
    2166:	a0 92 27 21 	sts	0x2127, r10
    216a:	b0 92 28 21 	sts	0x2128, r11
    216e:	c0 92 29 21 	sts	0x2129, r12
    2172:	d0 92 2a 21 	sts	0x212A, r13
	ax.y.max_feed_steps = Y_STEPS_PER_MM / DEFAULT_FEEDRATE;
    2176:	20 93 2b 21 	sts	0x212B, r18
    217a:	30 93 2c 21 	sts	0x212C, r19
    217e:	40 93 2d 21 	sts	0x212D, r20
    2182:	50 93 2e 21 	sts	0x212E, r21
	ax.y.steps_per_mm = Y_STEPS_PER_MM;
    2186:	e0 92 2f 21 	sts	0x212F, r14
    218a:	f0 92 30 21 	sts	0x2130, r15
    218e:	00 93 31 21 	sts	0x2131, r16
    2192:	10 93 32 21 	sts	0x2132, r17

	ax.y.port = &Y_MOTOR_PORT;					// bind port to structure 
    2196:	e0 ea       	ldi	r30, 0xA0	; 160
    2198:	f6 e0       	ldi	r31, 0x06	; 6
    219a:	e0 93 33 21 	sts	0x2133, r30
    219e:	f0 93 34 21 	sts	0x2134, r31
	ax.y.port->DIR = Y_MOTOR_PORT_DIR_gm;
    21a2:	60 83       	st	Z, r22
	ax.y.port->OUT = 0;							// set port bits to zero initially
    21a4:	14 82       	std	Z+4, r1	; 0x04
	ax.y.port->OUT |= MICROSTEP_EIGHTH_bm;		// set microstep bits to eighth
    21a6:	84 81       	ldd	r24, Z+4	; 0x04
    21a8:	88 61       	ori	r24, 0x18	; 24
    21aa:	84 83       	std	Z+4, r24	; 0x04

	ax.y.timer = &Y_TIMER;
    21ac:	e0 e0       	ldi	r30, 0x00	; 0
    21ae:	f9 e0       	ldi	r31, 0x09	; 9
    21b0:	e0 93 35 21 	sts	0x2135, r30
    21b4:	f0 93 36 21 	sts	0x2136, r31
	ax.y.timer->CTRLA = TC_CLK_OFF;				// default division ratio
    21b8:	10 82       	st	Z, r1
	ax.y.timer->CTRLB = TC_WGMODE;				// waveform generation mode
    21ba:	11 82       	std	Z+1, r1	; 0x01
	ax.y.timer->INTCTRLA = TC_OVFINTLVL;		// interrupt mode
    21bc:	96 83       	std	Z+6, r25	; 0x06
	ax.y.timer->PERH = 0x00;					// period high
    21be:	17 a2       	std	Z+39, r1	; 0x27
	ax.y.timer->PERL = 0x00;					// period low
    21c0:	16 a2       	std	Z+38, r1	; 0x26

/* initialize Z axis */
	ax.z.counter = 0;
    21c2:	10 92 37 21 	sts	0x2137, r1
    21c6:	10 92 38 21 	sts	0x2138, r1
    21ca:	10 92 39 21 	sts	0x2139, r1
    21ce:	10 92 3a 21 	sts	0x213A, r1

	ax.z.microsteps = Z_MICROSTEPS;
    21d2:	ed ef       	ldi	r30, 0xFD	; 253
    21d4:	f0 e2       	ldi	r31, 0x20	; 32
    21d6:	76 af       	std	Z+62, r23	; 0x3e
	ax.z.max_seek_rate = Z_SEEK_WHOLE_STEPS_PER_SEC;
    21d8:	60 92 3c 21 	sts	0x213C, r6
    21dc:	70 92 3d 21 	sts	0x213D, r7
    21e0:	80 92 3e 21 	sts	0x213E, r8
    21e4:	90 92 3f 21 	sts	0x213F, r9
	ax.z.max_seek_steps = Z_STEPS_PER_MM / DEFAULT_FEEDRATE;
    21e8:	20 93 40 21 	sts	0x2140, r18
    21ec:	30 93 41 21 	sts	0x2141, r19
    21f0:	40 93 42 21 	sts	0x2142, r20
    21f4:	50 93 43 21 	sts	0x2143, r21
	ax.z.max_feed_rate = DEFAULT_FEEDRATE;
    21f8:	a0 92 44 21 	sts	0x2144, r10
    21fc:	b0 92 45 21 	sts	0x2145, r11
    2200:	c0 92 46 21 	sts	0x2146, r12
    2204:	d0 92 47 21 	sts	0x2147, r13
	ax.z.max_feed_steps = Z_STEPS_PER_MM / DEFAULT_FEEDRATE;
    2208:	20 93 48 21 	sts	0x2148, r18
    220c:	30 93 49 21 	sts	0x2149, r19
    2210:	40 93 4a 21 	sts	0x214A, r20
    2214:	50 93 4b 21 	sts	0x214B, r21
	ax.z.steps_per_mm = Z_STEPS_PER_MM;
    2218:	e0 92 4c 21 	sts	0x214C, r14
    221c:	f0 92 4d 21 	sts	0x214D, r15
    2220:	00 93 4e 21 	sts	0x214E, r16
    2224:	10 93 4f 21 	sts	0x214F, r17

	ax.z.port = &Z_MOTOR_PORT;
    2228:	e0 e8       	ldi	r30, 0x80	; 128
    222a:	f6 e0       	ldi	r31, 0x06	; 6
    222c:	e0 93 50 21 	sts	0x2150, r30
    2230:	f0 93 51 21 	sts	0x2151, r31
	ax.z.port->DIR = Z_MOTOR_PORT_DIR_gm;
    2234:	60 83       	st	Z, r22
	ax.z.port->OUT = 0;							// set port bits to zero initially
    2236:	14 82       	std	Z+4, r1	; 0x04
	ax.z.port->OUT |= MICROSTEP_EIGHTH_bm;		// set microstep bits to eighth
    2238:	84 81       	ldd	r24, Z+4	; 0x04
    223a:	88 61       	ori	r24, 0x18	; 24
    223c:	84 83       	std	Z+4, r24	; 0x04

	ax.z.timer = &Z_TIMER;
    223e:	e0 e0       	ldi	r30, 0x00	; 0
    2240:	fa e0       	ldi	r31, 0x0A	; 10
    2242:	e0 93 52 21 	sts	0x2152, r30
    2246:	f0 93 53 21 	sts	0x2153, r31
	ax.z.timer->CTRLA = TC_CLK_OFF;				// timer clock control or division
    224a:	10 82       	st	Z, r1
	ax.z.timer->CTRLB = TC_WGMODE;				// waveform generation mode
    224c:	11 82       	std	Z+1, r1	; 0x01
	ax.z.timer->INTCTRLA = TC_OVFINTLVL;		// interrupt mode
    224e:	96 83       	std	Z+6, r25	; 0x06
	ax.z.timer->PERH = 0x00;					// period high
    2250:	17 a2       	std	Z+39, r1	; 0x27
	ax.z.timer->PERL = 0x00;					// period low
    2252:	16 a2       	std	Z+38, r1	; 0x26

/* initialize A axis */
	ax.a.counter = 0;
    2254:	10 92 54 21 	sts	0x2154, r1
    2258:	10 92 55 21 	sts	0x2155, r1
    225c:	10 92 56 21 	sts	0x2156, r1
    2260:	10 92 57 21 	sts	0x2157, r1

	ax.a.microsteps = A_MICROSTEPS;
    2264:	70 93 58 21 	sts	0x2158, r23
	ax.a.max_seek_rate = A_SEEK_WHOLE_STEPS_PER_SEC;
    2268:	60 92 59 21 	sts	0x2159, r6
    226c:	70 92 5a 21 	sts	0x215A, r7
    2270:	80 92 5b 21 	sts	0x215B, r8
    2274:	90 92 5c 21 	sts	0x215C, r9
	ax.a.max_seek_steps = A_STEPS_PER_MM / DEFAULT_FEEDRATE;
    2278:	20 93 5d 21 	sts	0x215D, r18
    227c:	30 93 5e 21 	sts	0x215E, r19
    2280:	40 93 5f 21 	sts	0x215F, r20
    2284:	50 93 60 21 	sts	0x2160, r21
	ax.a.max_feed_rate = DEFAULT_FEEDRATE;
    2288:	a0 92 61 21 	sts	0x2161, r10
    228c:	b0 92 62 21 	sts	0x2162, r11
    2290:	c0 92 63 21 	sts	0x2163, r12
    2294:	d0 92 64 21 	sts	0x2164, r13
	ax.a.max_feed_steps = A_STEPS_PER_MM / DEFAULT_FEEDRATE;
    2298:	20 93 65 21 	sts	0x2165, r18
    229c:	30 93 66 21 	sts	0x2166, r19
    22a0:	40 93 67 21 	sts	0x2167, r20
    22a4:	50 93 68 21 	sts	0x2168, r21
	ax.a.steps_per_mm = A_STEPS_PER_MM;
    22a8:	e0 92 69 21 	sts	0x2169, r14
    22ac:	f0 92 6a 21 	sts	0x216A, r15
    22b0:	00 93 6b 21 	sts	0x216B, r16
    22b4:	10 93 6c 21 	sts	0x216C, r17

	ax.a.port = &A_MOTOR_PORT;
    22b8:	e0 e6       	ldi	r30, 0x60	; 96
    22ba:	f6 e0       	ldi	r31, 0x06	; 6
    22bc:	e0 93 6d 21 	sts	0x216D, r30
    22c0:	f0 93 6e 21 	sts	0x216E, r31
	ax.a.port->DIR = A_MOTOR_PORT_DIR_gm;
    22c4:	60 83       	st	Z, r22
	ax.a.port->OUT = 0;							// set port bits to zero initially
    22c6:	14 82       	std	Z+4, r1	; 0x04
	ax.a.port->OUT |= MICROSTEP_EIGHTH_bm;		// set microstep bits to eighth
    22c8:	84 81       	ldd	r24, Z+4	; 0x04
    22ca:	88 61       	ori	r24, 0x18	; 24
    22cc:	84 83       	std	Z+4, r24	; 0x04

	ax.a.timer = &A_TIMER;
    22ce:	e0 e0       	ldi	r30, 0x00	; 0
    22d0:	fb e0       	ldi	r31, 0x0B	; 11
    22d2:	e0 93 6f 21 	sts	0x216F, r30
    22d6:	f0 93 70 21 	sts	0x2170, r31
	ax.a.timer->CTRLA = TC_CLK_OFF;				
    22da:	10 82       	st	Z, r1
	ax.a.timer->CTRLB = TC_WGMODE;				// waveform generation mode
    22dc:	11 82       	std	Z+1, r1	; 0x01
	ax.a.timer->INTCTRLA = TC_OVFINTLVL;		// interrupt mode
    22de:	96 83       	std	Z+6, r25	; 0x06
	ax.a.timer->PERH = 0x00;					// period high
    22e0:	17 a2       	std	Z+39, r1	; 0x27
	ax.a.timer->PERL = 0x00;					// period low
    22e2:	16 a2       	std	Z+38, r1	; 0x26

	// high level interrupts must be enabled in main()

	st_motor_test();							// run the motor test
    22e4:	0e 94 c3 0f 	call	0x1f86	; 0x1f86 <st_motor_test>
}
    22e8:	1f 91       	pop	r17
    22ea:	0f 91       	pop	r16
    22ec:	ff 90       	pop	r15
    22ee:	ef 90       	pop	r14
    22f0:	df 90       	pop	r13
    22f2:	cf 90       	pop	r12
    22f4:	bf 90       	pop	r11
    22f6:	af 90       	pop	r10
    22f8:	9f 90       	pop	r9
    22fa:	8f 90       	pop	r8
    22fc:	7f 90       	pop	r7
    22fe:	6f 90       	pop	r6
    2300:	08 95       	ret

00002302 <__vector_14>:
/*******************************************************************************
 Motor timer interrupt service routines - service a tick from the axis timer
*******************************************************************************/

ISR(X_TIMER_vect)
{
    2302:	1f 92       	push	r1
    2304:	0f 92       	push	r0
    2306:	0f b6       	in	r0, 0x3f	; 63
    2308:	0f 92       	push	r0
    230a:	0b b6       	in	r0, 0x3b	; 59
    230c:	0f 92       	push	r0
    230e:	11 24       	eor	r1, r1
    2310:	8f 93       	push	r24
    2312:	9f 93       	push	r25
    2314:	af 93       	push	r26
    2316:	bf 93       	push	r27
    2318:	ef 93       	push	r30
    231a:	ff 93       	push	r31
	ax.x.port->OUTSET = STEP_BIT_bm;			// turn X step bit on
    231c:	e0 91 16 21 	lds	r30, 0x2116
    2320:	f0 91 17 21 	lds	r31, 0x2117
    2324:	81 e0       	ldi	r24, 0x01	; 1
    2326:	85 83       	std	Z+5, r24	; 0x05
	if (--ax.x.counter == 0) {
    2328:	80 91 fd 20 	lds	r24, 0x20FD
    232c:	90 91 fe 20 	lds	r25, 0x20FE
    2330:	a0 91 ff 20 	lds	r26, 0x20FF
    2334:	b0 91 00 21 	lds	r27, 0x2100
    2338:	01 97       	sbiw	r24, 0x01	; 1
    233a:	a1 09       	sbc	r26, r1
    233c:	b1 09       	sbc	r27, r1
    233e:	80 93 fd 20 	sts	0x20FD, r24
    2342:	90 93 fe 20 	sts	0x20FE, r25
    2346:	a0 93 ff 20 	sts	0x20FF, r26
    234a:	b0 93 00 21 	sts	0x2100, r27
    234e:	00 97       	sbiw	r24, 0x00	; 0
    2350:	a1 05       	cpc	r26, r1
    2352:	b1 05       	cpc	r27, r1
    2354:	51 f4       	brne	.+20     	; 0x236a <__vector_14+0x68>
		ax.x.timer->CTRLA = TC_CLK_OFF;			// stop the clock
    2356:	e0 91 18 21 	lds	r30, 0x2118
    235a:	f0 91 19 21 	lds	r31, 0x2119
    235e:	10 82       	st	Z, r1
		ax.active_axes &= ~X_BIT_bm;			// clear the X active bit
    2360:	80 91 71 21 	lds	r24, 0x2171
    2364:	8e 7f       	andi	r24, 0xFE	; 254
    2366:	80 93 71 21 	sts	0x2171, r24
	}
//	_delay_us(STEP_PULSE_MICROSECONDS);			// delay for correct pulse width
	ax.x.port->OUTCLR = STEP_BIT_bm;			// turn X step bit off
    236a:	e0 91 16 21 	lds	r30, 0x2116
    236e:	f0 91 17 21 	lds	r31, 0x2117
    2372:	81 e0       	ldi	r24, 0x01	; 1
    2374:	86 83       	std	Z+6, r24	; 0x06
}
    2376:	ff 91       	pop	r31
    2378:	ef 91       	pop	r30
    237a:	bf 91       	pop	r27
    237c:	af 91       	pop	r26
    237e:	9f 91       	pop	r25
    2380:	8f 91       	pop	r24
    2382:	0f 90       	pop	r0
    2384:	0b be       	out	0x3b, r0	; 59
    2386:	0f 90       	pop	r0
    2388:	0f be       	out	0x3f, r0	; 63
    238a:	0f 90       	pop	r0
    238c:	1f 90       	pop	r1
    238e:	18 95       	reti

00002390 <__vector_77>:

ISR(Y_TIMER_vect)
{
    2390:	1f 92       	push	r1
    2392:	0f 92       	push	r0
    2394:	0f b6       	in	r0, 0x3f	; 63
    2396:	0f 92       	push	r0
    2398:	0b b6       	in	r0, 0x3b	; 59
    239a:	0f 92       	push	r0
    239c:	11 24       	eor	r1, r1
    239e:	8f 93       	push	r24
    23a0:	9f 93       	push	r25
    23a2:	af 93       	push	r26
    23a4:	bf 93       	push	r27
    23a6:	ef 93       	push	r30
    23a8:	ff 93       	push	r31
	ax.y.port->OUTSET = STEP_BIT_bm;
    23aa:	e0 91 33 21 	lds	r30, 0x2133
    23ae:	f0 91 34 21 	lds	r31, 0x2134
    23b2:	81 e0       	ldi	r24, 0x01	; 1
    23b4:	85 83       	std	Z+5, r24	; 0x05
	Y_MOTOR_PORT.OUTSET	= STEP_BIT_bm;
    23b6:	e0 ea       	ldi	r30, 0xA0	; 160
    23b8:	f6 e0       	ldi	r31, 0x06	; 6
    23ba:	85 83       	std	Z+5, r24	; 0x05
	if (--ax.y.counter == 0) {
    23bc:	80 91 1a 21 	lds	r24, 0x211A
    23c0:	90 91 1b 21 	lds	r25, 0x211B
    23c4:	a0 91 1c 21 	lds	r26, 0x211C
    23c8:	b0 91 1d 21 	lds	r27, 0x211D
    23cc:	01 97       	sbiw	r24, 0x01	; 1
    23ce:	a1 09       	sbc	r26, r1
    23d0:	b1 09       	sbc	r27, r1
    23d2:	80 93 1a 21 	sts	0x211A, r24
    23d6:	90 93 1b 21 	sts	0x211B, r25
    23da:	a0 93 1c 21 	sts	0x211C, r26
    23de:	b0 93 1d 21 	sts	0x211D, r27
    23e2:	00 97       	sbiw	r24, 0x00	; 0
    23e4:	a1 05       	cpc	r26, r1
    23e6:	b1 05       	cpc	r27, r1
    23e8:	51 f4       	brne	.+20     	; 0x23fe <__vector_77+0x6e>
		ax.y.timer->CTRLA = TC_CLK_OFF;			// stop the clock
    23ea:	e0 91 35 21 	lds	r30, 0x2135
    23ee:	f0 91 36 21 	lds	r31, 0x2136
    23f2:	10 82       	st	Z, r1
		ax.active_axes &= ~Y_BIT_bm;			// clear the Y active bit
    23f4:	80 91 71 21 	lds	r24, 0x2171
    23f8:	8d 7f       	andi	r24, 0xFD	; 253
    23fa:	80 93 71 21 	sts	0x2171, r24
	}
//	_delay_us(STEP_PULSE_MICROSECONDS);
	Y_MOTOR_PORT.OUTCLR	= STEP_BIT_bm;
    23fe:	81 e0       	ldi	r24, 0x01	; 1
    2400:	e0 ea       	ldi	r30, 0xA0	; 160
    2402:	f6 e0       	ldi	r31, 0x06	; 6
    2404:	86 83       	std	Z+6, r24	; 0x06
}
    2406:	ff 91       	pop	r31
    2408:	ef 91       	pop	r30
    240a:	bf 91       	pop	r27
    240c:	af 91       	pop	r26
    240e:	9f 91       	pop	r25
    2410:	8f 91       	pop	r24
    2412:	0f 90       	pop	r0
    2414:	0b be       	out	0x3b, r0	; 59
    2416:	0f 90       	pop	r0
    2418:	0f be       	out	0x3f, r0	; 63
    241a:	0f 90       	pop	r0
    241c:	1f 90       	pop	r1
    241e:	18 95       	reti

00002420 <__vector_47>:

ISR(Z_TIMER_vect)
{
    2420:	1f 92       	push	r1
    2422:	0f 92       	push	r0
    2424:	0f b6       	in	r0, 0x3f	; 63
    2426:	0f 92       	push	r0
    2428:	0b b6       	in	r0, 0x3b	; 59
    242a:	0f 92       	push	r0
    242c:	11 24       	eor	r1, r1
    242e:	8f 93       	push	r24
    2430:	9f 93       	push	r25
    2432:	af 93       	push	r26
    2434:	bf 93       	push	r27
    2436:	ef 93       	push	r30
    2438:	ff 93       	push	r31
	Z_MOTOR_PORT.OUTSET	= STEP_BIT_bm;
    243a:	81 e0       	ldi	r24, 0x01	; 1
    243c:	e0 e8       	ldi	r30, 0x80	; 128
    243e:	f6 e0       	ldi	r31, 0x06	; 6
    2440:	85 83       	std	Z+5, r24	; 0x05
	if (--ax.z.counter == 0) {
    2442:	80 91 37 21 	lds	r24, 0x2137
    2446:	90 91 38 21 	lds	r25, 0x2138
    244a:	a0 91 39 21 	lds	r26, 0x2139
    244e:	b0 91 3a 21 	lds	r27, 0x213A
    2452:	01 97       	sbiw	r24, 0x01	; 1
    2454:	a1 09       	sbc	r26, r1
    2456:	b1 09       	sbc	r27, r1
    2458:	80 93 37 21 	sts	0x2137, r24
    245c:	90 93 38 21 	sts	0x2138, r25
    2460:	a0 93 39 21 	sts	0x2139, r26
    2464:	b0 93 3a 21 	sts	0x213A, r27
    2468:	00 97       	sbiw	r24, 0x00	; 0
    246a:	a1 05       	cpc	r26, r1
    246c:	b1 05       	cpc	r27, r1
    246e:	51 f4       	brne	.+20     	; 0x2484 <__vector_47+0x64>
		ax.z.timer->CTRLA = TC_CLK_OFF;			// stop the clock
    2470:	e0 91 52 21 	lds	r30, 0x2152
    2474:	f0 91 53 21 	lds	r31, 0x2153
    2478:	10 82       	st	Z, r1
		ax.active_axes &= ~Z_BIT_bm;			// clear the Z active bit
    247a:	80 91 71 21 	lds	r24, 0x2171
    247e:	8b 7f       	andi	r24, 0xFB	; 251
    2480:	80 93 71 21 	sts	0x2171, r24
	}
//	_delay_us(STEP_PULSE_MICROSECONDS);
	Z_MOTOR_PORT.OUTCLR	= STEP_BIT_bm;
    2484:	81 e0       	ldi	r24, 0x01	; 1
    2486:	e0 e8       	ldi	r30, 0x80	; 128
    2488:	f6 e0       	ldi	r31, 0x06	; 6
    248a:	86 83       	std	Z+6, r24	; 0x06
}
    248c:	ff 91       	pop	r31
    248e:	ef 91       	pop	r30
    2490:	bf 91       	pop	r27
    2492:	af 91       	pop	r26
    2494:	9f 91       	pop	r25
    2496:	8f 91       	pop	r24
    2498:	0f 90       	pop	r0
    249a:	0b be       	out	0x3b, r0	; 59
    249c:	0f 90       	pop	r0
    249e:	0f be       	out	0x3f, r0	; 63
    24a0:	0f 90       	pop	r0
    24a2:	1f 90       	pop	r1
    24a4:	18 95       	reti

000024a6 <__vector_108>:

ISR(A_TIMER_vect)
{
    24a6:	1f 92       	push	r1
    24a8:	0f 92       	push	r0
    24aa:	0f b6       	in	r0, 0x3f	; 63
    24ac:	0f 92       	push	r0
    24ae:	0b b6       	in	r0, 0x3b	; 59
    24b0:	0f 92       	push	r0
    24b2:	11 24       	eor	r1, r1
    24b4:	8f 93       	push	r24
    24b6:	9f 93       	push	r25
    24b8:	af 93       	push	r26
    24ba:	bf 93       	push	r27
    24bc:	ef 93       	push	r30
    24be:	ff 93       	push	r31
	A_MOTOR_PORT.OUTSET	= STEP_BIT_bm;
    24c0:	81 e0       	ldi	r24, 0x01	; 1
    24c2:	e0 e6       	ldi	r30, 0x60	; 96
    24c4:	f6 e0       	ldi	r31, 0x06	; 6
    24c6:	85 83       	std	Z+5, r24	; 0x05
	if (--ax.a.counter == 0) {
    24c8:	80 91 54 21 	lds	r24, 0x2154
    24cc:	90 91 55 21 	lds	r25, 0x2155
    24d0:	a0 91 56 21 	lds	r26, 0x2156
    24d4:	b0 91 57 21 	lds	r27, 0x2157
    24d8:	01 97       	sbiw	r24, 0x01	; 1
    24da:	a1 09       	sbc	r26, r1
    24dc:	b1 09       	sbc	r27, r1
    24de:	80 93 54 21 	sts	0x2154, r24
    24e2:	90 93 55 21 	sts	0x2155, r25
    24e6:	a0 93 56 21 	sts	0x2156, r26
    24ea:	b0 93 57 21 	sts	0x2157, r27
    24ee:	00 97       	sbiw	r24, 0x00	; 0
    24f0:	a1 05       	cpc	r26, r1
    24f2:	b1 05       	cpc	r27, r1
    24f4:	51 f4       	brne	.+20     	; 0x250a <__vector_108+0x64>
		ax.a.timer->CTRLA = TC_CLK_OFF;			// stop the clock
    24f6:	e0 91 6f 21 	lds	r30, 0x216F
    24fa:	f0 91 70 21 	lds	r31, 0x2170
    24fe:	10 82       	st	Z, r1
		ax.active_axes &= ~A_BIT_bm;			// clear the A active bit
    2500:	80 91 71 21 	lds	r24, 0x2171
    2504:	87 7f       	andi	r24, 0xF7	; 247
    2506:	80 93 71 21 	sts	0x2171, r24
	}
//	_delay_us(STEP_PULSE_MICROSECONDS);
	A_MOTOR_PORT.OUTCLR	= STEP_BIT_bm;
    250a:	81 e0       	ldi	r24, 0x01	; 1
    250c:	e0 e6       	ldi	r30, 0x60	; 96
    250e:	f6 e0       	ldi	r31, 0x06	; 6
    2510:	86 83       	std	Z+6, r24	; 0x06
}
    2512:	ff 91       	pop	r31
    2514:	ef 91       	pop	r30
    2516:	bf 91       	pop	r27
    2518:	af 91       	pop	r26
    251a:	9f 91       	pop	r25
    251c:	8f 91       	pop	r24
    251e:	0f 90       	pop	r0
    2520:	0b be       	out	0x3b, r0	; 59
    2522:	0f 90       	pop	r0
    2524:	0f be       	out	0x3f, r0	; 63
    2526:	0f 90       	pop	r0
    2528:	1f 90       	pop	r1
    252a:	18 95       	reti

0000252c <_st_load_timer>:
}

/* st_load_timer() - helper routine for st_execute line */

void _st_load_timer(struct axis *a, uint32_t step_rate, uint32_t microseconds) 
{
    252c:	cf 92       	push	r12
    252e:	df 92       	push	r13
    2530:	ef 92       	push	r14
    2532:	ff 92       	push	r15
    2534:	0f 93       	push	r16
    2536:	1f 93       	push	r17
    2538:	cf 93       	push	r28
    253a:	df 93       	push	r29
    253c:	ec 01       	movw	r28, r24
    253e:	6a 01       	movw	r12, r20
    2540:	7b 01       	movw	r14, r22
//	st_print_four_ints( a->counter, step_rate, a->timer->CTRLA, microseconds);

	if (step_rate < DIV1_RANGE) {				// short timer - up to 2000 uSec
    2542:	40 30       	cpi	r20, 0x00	; 0
    2544:	88 e0       	ldi	r24, 0x08	; 8
    2546:	58 07       	cpc	r21, r24
    2548:	80 e0       	ldi	r24, 0x00	; 0
    254a:	68 07       	cpc	r22, r24
    254c:	80 e0       	ldi	r24, 0x00	; 0
    254e:	78 07       	cpc	r23, r24
    2550:	b0 f4       	brcc	.+44     	; 0x257e <_st_load_timer+0x52>
		a->timer->CTRLA = TC_CLK_DIV_1;			// set clock divisor
    2552:	eb 8d       	ldd	r30, Y+27	; 0x1b
    2554:	fc 8d       	ldd	r31, Y+28	; 0x1c
    2556:	81 e0       	ldi	r24, 0x01	; 1
    2558:	80 83       	st	Z, r24
		a->counter = (microseconds/step_rate);	// # of steps to make at this rate
    255a:	c9 01       	movw	r24, r18
    255c:	b8 01       	movw	r22, r16
    255e:	a7 01       	movw	r20, r14
    2560:	96 01       	movw	r18, r12
    2562:	0e 94 a9 1c 	call	0x3952	; 0x3952 <__udivmodsi4>
    2566:	28 83       	st	Y, r18
    2568:	39 83       	std	Y+1, r19	; 0x01
    256a:	4a 83       	std	Y+2, r20	; 0x02
    256c:	5b 83       	std	Y+3, r21	; 0x03
		step_rate = (step_rate * 32);			// normalize step rate to timer clock
    256e:	65 e0       	ldi	r22, 0x05	; 5
    2570:	cc 0c       	add	r12, r12
    2572:	dd 1c       	adc	r13, r13
    2574:	ee 1c       	adc	r14, r14
    2576:	ff 1c       	adc	r15, r15
    2578:	6a 95       	dec	r22
    257a:	d1 f7       	brne	.-12     	; 0x2570 <_st_load_timer+0x44>
    257c:	92 c0       	rjmp	.+292    	; 0x26a2 <_st_load_timer+0x176>
	} else if (step_rate < DIV2_RANGE) {
    257e:	40 30       	cpi	r20, 0x00	; 0
    2580:	80 e1       	ldi	r24, 0x10	; 16
    2582:	58 07       	cpc	r21, r24
    2584:	80 e0       	ldi	r24, 0x00	; 0
    2586:	68 07       	cpc	r22, r24
    2588:	80 e0       	ldi	r24, 0x00	; 0
    258a:	78 07       	cpc	r23, r24
    258c:	b0 f4       	brcc	.+44     	; 0x25ba <_st_load_timer+0x8e>
		a->timer->CTRLA = TC_CLK_DIV_2;	
    258e:	eb 8d       	ldd	r30, Y+27	; 0x1b
    2590:	fc 8d       	ldd	r31, Y+28	; 0x1c
    2592:	82 e0       	ldi	r24, 0x02	; 2
    2594:	80 83       	st	Z, r24
		a->counter = (microseconds/step_rate);
    2596:	c9 01       	movw	r24, r18
    2598:	b8 01       	movw	r22, r16
    259a:	a7 01       	movw	r20, r14
    259c:	96 01       	movw	r18, r12
    259e:	0e 94 a9 1c 	call	0x3952	; 0x3952 <__udivmodsi4>
    25a2:	28 83       	st	Y, r18
    25a4:	39 83       	std	Y+1, r19	; 0x01
    25a6:	4a 83       	std	Y+2, r20	; 0x02
    25a8:	5b 83       	std	Y+3, r21	; 0x03
		step_rate = (step_rate * 16);
    25aa:	54 e0       	ldi	r21, 0x04	; 4
    25ac:	cc 0c       	add	r12, r12
    25ae:	dd 1c       	adc	r13, r13
    25b0:	ee 1c       	adc	r14, r14
    25b2:	ff 1c       	adc	r15, r15
    25b4:	5a 95       	dec	r21
    25b6:	d1 f7       	brne	.-12     	; 0x25ac <_st_load_timer+0x80>
    25b8:	74 c0       	rjmp	.+232    	; 0x26a2 <_st_load_timer+0x176>
	} else if (step_rate < DIV4_RANGE) {
    25ba:	40 30       	cpi	r20, 0x00	; 0
    25bc:	80 e2       	ldi	r24, 0x20	; 32
    25be:	58 07       	cpc	r21, r24
    25c0:	80 e0       	ldi	r24, 0x00	; 0
    25c2:	68 07       	cpc	r22, r24
    25c4:	80 e0       	ldi	r24, 0x00	; 0
    25c6:	78 07       	cpc	r23, r24
    25c8:	b0 f4       	brcc	.+44     	; 0x25f6 <_st_load_timer+0xca>
		a->timer->CTRLA = TC_CLK_DIV_4;	
    25ca:	eb 8d       	ldd	r30, Y+27	; 0x1b
    25cc:	fc 8d       	ldd	r31, Y+28	; 0x1c
    25ce:	83 e0       	ldi	r24, 0x03	; 3
    25d0:	80 83       	st	Z, r24
		a->counter = (microseconds/step_rate);
    25d2:	c9 01       	movw	r24, r18
    25d4:	b8 01       	movw	r22, r16
    25d6:	a7 01       	movw	r20, r14
    25d8:	96 01       	movw	r18, r12
    25da:	0e 94 a9 1c 	call	0x3952	; 0x3952 <__udivmodsi4>
    25de:	28 83       	st	Y, r18
    25e0:	39 83       	std	Y+1, r19	; 0x01
    25e2:	4a 83       	std	Y+2, r20	; 0x02
    25e4:	5b 83       	std	Y+3, r21	; 0x03
		step_rate = (step_rate * 8);
    25e6:	43 e0       	ldi	r20, 0x03	; 3
    25e8:	cc 0c       	add	r12, r12
    25ea:	dd 1c       	adc	r13, r13
    25ec:	ee 1c       	adc	r14, r14
    25ee:	ff 1c       	adc	r15, r15
    25f0:	4a 95       	dec	r20
    25f2:	d1 f7       	brne	.-12     	; 0x25e8 <_st_load_timer+0xbc>
    25f4:	56 c0       	rjmp	.+172    	; 0x26a2 <_st_load_timer+0x176>
	} else if (step_rate < DIV8_RANGE) {
    25f6:	40 30       	cpi	r20, 0x00	; 0
    25f8:	80 e4       	ldi	r24, 0x40	; 64
    25fa:	58 07       	cpc	r21, r24
    25fc:	80 e0       	ldi	r24, 0x00	; 0
    25fe:	68 07       	cpc	r22, r24
    2600:	80 e0       	ldi	r24, 0x00	; 0
    2602:	78 07       	cpc	r23, r24
    2604:	b0 f4       	brcc	.+44     	; 0x2632 <_st_load_timer+0x106>
		a->timer->CTRLA = TC_CLK_DIV_8;	
    2606:	eb 8d       	ldd	r30, Y+27	; 0x1b
    2608:	fc 8d       	ldd	r31, Y+28	; 0x1c
    260a:	84 e0       	ldi	r24, 0x04	; 4
    260c:	80 83       	st	Z, r24
		a->counter = (microseconds/step_rate);
    260e:	c9 01       	movw	r24, r18
    2610:	b8 01       	movw	r22, r16
    2612:	a7 01       	movw	r20, r14
    2614:	96 01       	movw	r18, r12
    2616:	0e 94 a9 1c 	call	0x3952	; 0x3952 <__udivmodsi4>
    261a:	28 83       	st	Y, r18
    261c:	39 83       	std	Y+1, r19	; 0x01
    261e:	4a 83       	std	Y+2, r20	; 0x02
    2620:	5b 83       	std	Y+3, r21	; 0x03
		step_rate = (step_rate * 4);
    2622:	32 e0       	ldi	r19, 0x02	; 2
    2624:	cc 0c       	add	r12, r12
    2626:	dd 1c       	adc	r13, r13
    2628:	ee 1c       	adc	r14, r14
    262a:	ff 1c       	adc	r15, r15
    262c:	3a 95       	dec	r19
    262e:	d1 f7       	brne	.-12     	; 0x2624 <_st_load_timer+0xf8>
    2630:	38 c0       	rjmp	.+112    	; 0x26a2 <_st_load_timer+0x176>
	} else if (step_rate < DIV64_RANGE) {
    2632:	40 30       	cpi	r20, 0x00	; 0
    2634:	80 e0       	ldi	r24, 0x00	; 0
    2636:	58 07       	cpc	r21, r24
    2638:	82 e0       	ldi	r24, 0x02	; 2
    263a:	68 07       	cpc	r22, r24
    263c:	80 e0       	ldi	r24, 0x00	; 0
    263e:	78 07       	cpc	r23, r24
    2640:	98 f4       	brcc	.+38     	; 0x2668 <_st_load_timer+0x13c>
		a->timer->CTRLA = TC_CLK_DIV_64;	
    2642:	eb 8d       	ldd	r30, Y+27	; 0x1b
    2644:	fc 8d       	ldd	r31, Y+28	; 0x1c
    2646:	85 e0       	ldi	r24, 0x05	; 5
    2648:	80 83       	st	Z, r24
		a->counter = (microseconds/step_rate);
    264a:	c9 01       	movw	r24, r18
    264c:	b8 01       	movw	r22, r16
    264e:	a7 01       	movw	r20, r14
    2650:	96 01       	movw	r18, r12
    2652:	0e 94 a9 1c 	call	0x3952	; 0x3952 <__udivmodsi4>
    2656:	28 83       	st	Y, r18
    2658:	39 83       	std	Y+1, r19	; 0x01
    265a:	4a 83       	std	Y+2, r20	; 0x02
    265c:	5b 83       	std	Y+3, r21	; 0x03
		step_rate = (step_rate / 2);
    265e:	f6 94       	lsr	r15
    2660:	e7 94       	ror	r14
    2662:	d7 94       	ror	r13
    2664:	c7 94       	ror	r12
    2666:	1d c0       	rjmp	.+58     	; 0x26a2 <_st_load_timer+0x176>
	} else if (step_rate < DIV256_RANGE) {
    2668:	40 32       	cpi	r20, 0x20	; 32
    266a:	8e e4       	ldi	r24, 0x4E	; 78
    266c:	58 07       	cpc	r21, r24
    266e:	88 e0       	ldi	r24, 0x08	; 8
    2670:	68 07       	cpc	r22, r24
    2672:	80 e0       	ldi	r24, 0x00	; 0
    2674:	78 07       	cpc	r23, r24
    2676:	a8 f4       	brcc	.+42     	; 0x26a2 <_st_load_timer+0x176>
		a->timer->CTRLA = TC_CLK_DIV_256;	
    2678:	eb 8d       	ldd	r30, Y+27	; 0x1b
    267a:	fc 8d       	ldd	r31, Y+28	; 0x1c
    267c:	86 e0       	ldi	r24, 0x06	; 6
    267e:	80 83       	st	Z, r24
		a->counter = (microseconds/step_rate);
    2680:	c9 01       	movw	r24, r18
    2682:	b8 01       	movw	r22, r16
    2684:	a7 01       	movw	r20, r14
    2686:	96 01       	movw	r18, r12
    2688:	0e 94 a9 1c 	call	0x3952	; 0x3952 <__udivmodsi4>
    268c:	28 83       	st	Y, r18
    268e:	39 83       	std	Y+1, r19	; 0x01
    2690:	4a 83       	std	Y+2, r20	; 0x02
    2692:	5b 83       	std	Y+3, r21	; 0x03
		step_rate = (step_rate / 8);
    2694:	93 e0       	ldi	r25, 0x03	; 3
    2696:	f6 94       	lsr	r15
    2698:	e7 94       	ror	r14
    269a:	d7 94       	ror	r13
    269c:	c7 94       	ror	r12
    269e:	9a 95       	dec	r25
    26a0:	d1 f7       	brne	.-12     	; 0x2696 <_st_load_timer+0x16a>
	}
	a->timer->PERH = (uint8_t)((step_rate >> 8) & 0x000000FF);	// period high
    26a2:	eb 8d       	ldd	r30, Y+27	; 0x1b
    26a4:	fc 8d       	ldd	r31, Y+28	; 0x1c
    26a6:	bb 27       	eor	r27, r27
    26a8:	af 2d       	mov	r26, r15
    26aa:	9e 2d       	mov	r25, r14
    26ac:	8d 2d       	mov	r24, r13
    26ae:	87 a3       	std	Z+39, r24	; 0x27
	a->timer->PERL = (uint8_t)(step_rate & 0x000000FF);			// period low
    26b0:	eb 8d       	ldd	r30, Y+27	; 0x1b
    26b2:	fc 8d       	ldd	r31, Y+28	; 0x1c
    26b4:	c6 a2       	std	Z+38, r12	; 0x26

}
    26b6:	df 91       	pop	r29
    26b8:	cf 91       	pop	r28
    26ba:	1f 91       	pop	r17
    26bc:	0f 91       	pop	r16
    26be:	ff 90       	pop	r15
    26c0:	ef 90       	pop	r14
    26c2:	df 90       	pop	r13
    26c4:	cf 90       	pop	r12
    26c6:	08 95       	ret

000026c8 <st_get_next_line>:

struct Line *st_get_next_line()
{
	struct Line *ln;
	 
	if (line_buffer_head == line_buffer_tail) {	// buffer empty
    26c8:	20 91 2d 20 	lds	r18, 0x202D
    26cc:	30 91 2e 20 	lds	r19, 0x202E
    26d0:	80 91 2f 20 	lds	r24, 0x202F
    26d4:	90 91 30 20 	lds	r25, 0x2030
    26d8:	28 17       	cp	r18, r24
    26da:	39 07       	cpc	r19, r25
    26dc:	19 f4       	brne	.+6      	; 0x26e4 <st_get_next_line+0x1c>
    26de:	40 e0       	ldi	r20, 0x00	; 0
    26e0:	50 e0       	ldi	r21, 0x00	; 0
    26e2:	22 c0       	rjmp	.+68     	; 0x2728 <st_get_next_line+0x60>
		return (NULL);
	}
	ln = &line_buffer[line_buffer_tail];		 // get and save the current pointer
    26e4:	20 91 2f 20 	lds	r18, 0x202F
    26e8:	30 91 30 20 	lds	r19, 0x2030
    26ec:	85 e1       	ldi	r24, 0x15	; 21
    26ee:	90 e0       	ldi	r25, 0x00	; 0
    26f0:	28 9f       	mul	r18, r24
    26f2:	a0 01       	movw	r20, r0
    26f4:	29 9f       	mul	r18, r25
    26f6:	50 0d       	add	r21, r0
    26f8:	38 9f       	mul	r19, r24
    26fa:	50 0d       	add	r21, r0
    26fc:	11 24       	eor	r1, r1
    26fe:	4e 58       	subi	r20, 0x8E	; 142
    2700:	5e 4d       	sbci	r21, 0xDE	; 222
	if (++line_buffer_tail > LINE_BUFFER_SIZE) { // increment and wrap
    2702:	80 91 2f 20 	lds	r24, 0x202F
    2706:	90 91 30 20 	lds	r25, 0x2030
    270a:	01 96       	adiw	r24, 0x01	; 1
    270c:	80 93 2f 20 	sts	0x202F, r24
    2710:	90 93 30 20 	sts	0x2030, r25
    2714:	80 91 2f 20 	lds	r24, 0x202F
    2718:	90 91 30 20 	lds	r25, 0x2030
    271c:	89 97       	sbiw	r24, 0x29	; 41
    271e:	24 f0       	brlt	.+8      	; 0x2728 <st_get_next_line+0x60>
		line_buffer_tail = 0;
    2720:	10 92 2f 20 	sts	0x202F, r1
    2724:	10 92 30 20 	sts	0x2030, r1
	}
	return (ln); 
}
    2728:	ca 01       	movw	r24, r20
    272a:	08 95       	ret

0000272c <st_synchronize>:


/* st_synchronize() - block until all buffered steps are executed */

void st_synchronize()
{
    272c:	0b c0       	rjmp	.+22     	; 0x2744 <st_synchronize+0x18>
	while(line_buffer_tail != line_buffer_head) {
		sleep_mode();
    272e:	80 91 48 00 	lds	r24, 0x0048
    2732:	81 60       	ori	r24, 0x01	; 1
    2734:	80 93 48 00 	sts	0x0048, r24
    2738:	88 95       	sleep
    273a:	80 91 48 00 	lds	r24, 0x0048
    273e:	8e 7f       	andi	r24, 0xFE	; 254
    2740:	80 93 48 00 	sts	0x0048, r24

/* st_synchronize() - block until all buffered steps are executed */

void st_synchronize()
{
	while(line_buffer_tail != line_buffer_head) {
    2744:	20 91 2f 20 	lds	r18, 0x202F
    2748:	30 91 30 20 	lds	r19, 0x2030
    274c:	80 91 2d 20 	lds	r24, 0x202D
    2750:	90 91 2e 20 	lds	r25, 0x202E
    2754:	28 17       	cp	r18, r24
    2756:	39 07       	cpc	r19, r25
    2758:	51 f7       	brne	.-44     	; 0x272e <st_synchronize+0x2>
		sleep_mode();
	}    
}
    275a:	08 95       	ret

0000275c <st_flush>:

/* st_flush() - cancel all buffered steps */

void st_flush()
{
	cli();
    275c:	f8 94       	cli
	line_buffer_tail = line_buffer_head;
    275e:	80 91 2d 20 	lds	r24, 0x202D
    2762:	90 91 2e 20 	lds	r25, 0x202E
    2766:	80 93 2f 20 	sts	0x202F, r24
    276a:	90 93 30 20 	sts	0x2030, r25
	ln = NULL;
    276e:	10 92 2b 20 	sts	0x202B, r1
    2772:	10 92 2c 20 	sts	0x202C, r1
	sei();
    2776:	78 94       	sei
}
    2778:	08 95       	ret

0000277a <st_buffer_line>:
	steps_x, _y and _z is the signed, relative motion in steps. 
	Microseconds specify how many microseconds the move should take to perform.
*/

void st_buffer_line(int32_t steps_x, int32_t steps_y, int32_t steps_z, uint32_t microseconds) 
{
    277a:	2f 92       	push	r2
    277c:	3f 92       	push	r3
    277e:	4f 92       	push	r4
    2780:	5f 92       	push	r5
    2782:	6f 92       	push	r6
    2784:	7f 92       	push	r7
    2786:	8f 92       	push	r8
    2788:	9f 92       	push	r9
    278a:	af 92       	push	r10
    278c:	bf 92       	push	r11
    278e:	cf 92       	push	r12
    2790:	df 92       	push	r13
    2792:	ef 92       	push	r14
    2794:	ff 92       	push	r15
    2796:	0f 93       	push	r16
    2798:	1f 93       	push	r17
    279a:	df 93       	push	r29
    279c:	cf 93       	push	r28
    279e:	00 d0       	rcall	.+0      	; 0x27a0 <st_buffer_line+0x26>
    27a0:	00 d0       	rcall	.+0      	; 0x27a2 <st_buffer_line+0x28>
    27a2:	cd b7       	in	r28, 0x3d	; 61
    27a4:	de b7       	in	r29, 0x3e	; 62
    27a6:	3b 01       	movw	r6, r22
    27a8:	4c 01       	movw	r8, r24
    27aa:	19 01       	movw	r2, r18
    27ac:	2a 01       	movw	r4, r20
    27ae:	e9 82       	std	Y+1, r14	; 0x01
    27b0:	fa 82       	std	Y+2, r15	; 0x02
    27b2:	0b 83       	std	Y+3, r16	; 0x03
    27b4:	1c 83       	std	Y+4, r17	; 0x04
	// Calculate the buffer head after we push this byte
	int next_buffer_head = (line_buffer_head + 1) % LINE_BUFFER_SIZE;	
    27b6:	80 91 2d 20 	lds	r24, 0x202D
    27ba:	90 91 2e 20 	lds	r25, 0x202E
    27be:	01 96       	adiw	r24, 0x01	; 1
    27c0:	68 e2       	ldi	r22, 0x28	; 40
    27c2:	70 e0       	ldi	r23, 0x00	; 0
    27c4:	0e 94 96 1c 	call	0x392c	; 0x392c <__divmodhi4>
    27c8:	8d 83       	std	Y+5, r24	; 0x05
    27ca:	9e 83       	std	Y+6, r25	; 0x06
    27cc:	0b c0       	rjmp	.+22     	; 0x27e4 <st_buffer_line+0x6a>

	// If the buffer is full: good! That means we are well ahead of the robot. 
	// Nap until there is room in the buffer.
	while(line_buffer_tail == next_buffer_head) { 
		sleep_mode(); 
    27ce:	80 91 48 00 	lds	r24, 0x0048
    27d2:	81 60       	ori	r24, 0x01	; 1
    27d4:	80 93 48 00 	sts	0x0048, r24
    27d8:	88 95       	sleep
    27da:	80 91 48 00 	lds	r24, 0x0048
    27de:	8e 7f       	andi	r24, 0xFE	; 254
    27e0:	80 93 48 00 	sts	0x0048, r24
	// Calculate the buffer head after we push this byte
	int next_buffer_head = (line_buffer_head + 1) % LINE_BUFFER_SIZE;	

	// If the buffer is full: good! That means we are well ahead of the robot. 
	// Nap until there is room in the buffer.
	while(line_buffer_tail == next_buffer_head) { 
    27e4:	80 91 2f 20 	lds	r24, 0x202F
    27e8:	90 91 30 20 	lds	r25, 0x2030
    27ec:	2d 81       	ldd	r18, Y+5	; 0x05
    27ee:	3e 81       	ldd	r19, Y+6	; 0x06
    27f0:	82 17       	cp	r24, r18
    27f2:	93 07       	cpc	r25, r19
    27f4:	61 f3       	breq	.-40     	; 0x27ce <st_buffer_line+0x54>
		sleep_mode(); 
	};

	struct Line *line = &line_buffer[line_buffer_head];  	// Setup line record
    27f6:	20 91 2d 20 	lds	r18, 0x202D
    27fa:	30 91 2e 20 	lds	r19, 0x202E
    27fe:	85 e1       	ldi	r24, 0x15	; 21
    2800:	90 e0       	ldi	r25, 0x00	; 0
    2802:	28 9f       	mul	r18, r24
    2804:	f0 01       	movw	r30, r0
    2806:	29 9f       	mul	r18, r25
    2808:	f0 0d       	add	r31, r0
    280a:	38 9f       	mul	r19, r24
    280c:	f0 0d       	add	r31, r0
    280e:	11 24       	eor	r1, r1
    2810:	ee 58       	subi	r30, 0x8E	; 142
    2812:	fe 4d       	sbci	r31, 0xDE	; 222
	line->steps_x = labs(steps_x);
    2814:	60 86       	std	Z+8, r6	; 0x08
    2816:	71 86       	std	Z+9, r7	; 0x09
    2818:	82 86       	std	Z+10, r8	; 0x0a
    281a:	93 86       	std	Z+11, r9	; 0x0b
    281c:	97 fe       	sbrs	r9, 7
    281e:	0b c0       	rjmp	.+22     	; 0x2836 <st_buffer_line+0xbc>
    2820:	88 27       	eor	r24, r24
    2822:	99 27       	eor	r25, r25
    2824:	dc 01       	movw	r26, r24
    2826:	86 19       	sub	r24, r6
    2828:	97 09       	sbc	r25, r7
    282a:	a8 09       	sbc	r26, r8
    282c:	b9 09       	sbc	r27, r9
    282e:	80 87       	std	Z+8, r24	; 0x08
    2830:	91 87       	std	Z+9, r25	; 0x09
    2832:	a2 87       	std	Z+10, r26	; 0x0a
    2834:	b3 87       	std	Z+11, r27	; 0x0b
	line->steps_y = labs(steps_y);
    2836:	24 86       	std	Z+12, r2	; 0x0c
    2838:	35 86       	std	Z+13, r3	; 0x0d
    283a:	46 86       	std	Z+14, r4	; 0x0e
    283c:	57 86       	std	Z+15, r5	; 0x0f
    283e:	57 fe       	sbrs	r5, 7
    2840:	0b c0       	rjmp	.+22     	; 0x2858 <st_buffer_line+0xde>
    2842:	88 27       	eor	r24, r24
    2844:	99 27       	eor	r25, r25
    2846:	dc 01       	movw	r26, r24
    2848:	82 19       	sub	r24, r2
    284a:	93 09       	sbc	r25, r3
    284c:	a4 09       	sbc	r26, r4
    284e:	b5 09       	sbc	r27, r5
    2850:	84 87       	std	Z+12, r24	; 0x0c
    2852:	95 87       	std	Z+13, r25	; 0x0d
    2854:	a6 87       	std	Z+14, r26	; 0x0e
    2856:	b7 87       	std	Z+15, r27	; 0x0f
	line->steps_z = labs(steps_z);  
    2858:	29 81       	ldd	r18, Y+1	; 0x01
    285a:	3a 81       	ldd	r19, Y+2	; 0x02
    285c:	4b 81       	ldd	r20, Y+3	; 0x03
    285e:	5c 81       	ldd	r21, Y+4	; 0x04
    2860:	57 ff       	sbrs	r21, 7
    2862:	07 c0       	rjmp	.+14     	; 0x2872 <st_buffer_line+0xf8>
    2864:	50 95       	com	r21
    2866:	40 95       	com	r20
    2868:	30 95       	com	r19
    286a:	21 95       	neg	r18
    286c:	3f 4f       	sbci	r19, 0xFF	; 255
    286e:	4f 4f       	sbci	r20, 0xFF	; 255
    2870:	5f 4f       	sbci	r21, 0xFF	; 255
    2872:	20 8b       	std	Z+16, r18	; 0x10
    2874:	31 8b       	std	Z+17, r19	; 0x11
    2876:	42 8b       	std	Z+18, r20	; 0x12
    2878:	53 8b       	std	Z+19, r21	; 0x13
	line->steps_max = max(line->steps_x, max(line->steps_y, line->steps_z));
    287a:	e4 84       	ldd	r14, Z+12	; 0x0c
    287c:	f5 84       	ldd	r15, Z+13	; 0x0d
    287e:	06 85       	ldd	r16, Z+14	; 0x0e
    2880:	17 85       	ldd	r17, Z+15	; 0x0f
    2882:	80 85       	ldd	r24, Z+8	; 0x08
    2884:	91 85       	ldd	r25, Z+9	; 0x09
    2886:	a2 85       	ldd	r26, Z+10	; 0x0a
    2888:	b3 85       	ldd	r27, Z+11	; 0x0b
    288a:	8e 15       	cp	r24, r14
    288c:	9f 05       	cpc	r25, r15
    288e:	a0 07       	cpc	r26, r16
    2890:	b1 07       	cpc	r27, r17
    2892:	10 f4       	brcc	.+4      	; 0x2898 <st_buffer_line+0x11e>
    2894:	d8 01       	movw	r26, r16
    2896:	c7 01       	movw	r24, r14
    2898:	82 17       	cp	r24, r18
    289a:	93 07       	cpc	r25, r19
    289c:	a4 07       	cpc	r26, r20
    289e:	b5 07       	cpc	r27, r21
    28a0:	10 f4       	brcc	.+4      	; 0x28a6 <st_buffer_line+0x12c>
    28a2:	da 01       	movw	r26, r20
    28a4:	c9 01       	movw	r24, r18
    28a6:	84 83       	std	Z+4, r24	; 0x04
    28a8:	95 83       	std	Z+5, r25	; 0x05
    28aa:	a6 83       	std	Z+6, r26	; 0x06
    28ac:	b7 83       	std	Z+7, r27	; 0x07

  	if (line->steps_max == 0) { 		// Bail if this is a zero-length line
    28ae:	00 97       	sbiw	r24, 0x00	; 0
    28b0:	a1 05       	cpc	r26, r1
    28b2:	b1 05       	cpc	r27, r1
    28b4:	e1 f0       	breq	.+56     	; 0x28ee <st_buffer_line+0x174>
		return;
	};

//	line->rate = microseconds/line->maximum_steps;
	line->microseconds = microseconds;
    28b6:	a0 82       	st	Z, r10
    28b8:	b1 82       	std	Z+1, r11	; 0x01
    28ba:	c2 82       	std	Z+2, r12	; 0x02
    28bc:	d3 82       	std	Z+3, r13	; 0x03

	uint8_t direction_bits = 0;
	if (steps_x < 0) { 
    28be:	66 24       	eor	r6, r6
    28c0:	97 fc       	sbrc	r9, 7
    28c2:	63 94       	inc	r6
    28c4:	77 24       	eor	r7, r7
    28c6:	88 24       	eor	r8, r8
    28c8:	99 24       	eor	r9, r9
    28ca:	66 2d       	mov	r22, r6
    28cc:	62 95       	swap	r22
    28ce:	60 7f       	andi	r22, 0xF0	; 240
		direction_bits |= X_DIRECTION_BIT_bm; 
	}
	if (steps_y < 0) { 
    28d0:	57 fc       	sbrc	r5, 7
		direction_bits |= Y_DIRECTION_BIT_bm; 
    28d2:	60 62       	ori	r22, 0x20	; 32
	}
	if (steps_z < 0) { 
    28d4:	89 81       	ldd	r24, Y+1	; 0x01
    28d6:	9a 81       	ldd	r25, Y+2	; 0x02
    28d8:	ab 81       	ldd	r26, Y+3	; 0x03
    28da:	bc 81       	ldd	r27, Y+4	; 0x04
    28dc:	b7 fd       	sbrc	r27, 7
		direction_bits |= Z_DIRECTION_BIT_bm; 
    28de:	60 64       	ori	r22, 0x40	; 64
	}
	line->direction_bits = direction_bits;
    28e0:	64 8b       	std	Z+20, r22	; 0x14
	line_buffer_head = next_buffer_head;		// Move buffer head
    28e2:	ad 81       	ldd	r26, Y+5	; 0x05
    28e4:	be 81       	ldd	r27, Y+6	; 0x06
    28e6:	a0 93 2d 20 	sts	0x202D, r26
    28ea:	b0 93 2e 20 	sts	0x202E, r27

//	st_print_line(*line);						// ++++ DEBUG CODE

}
    28ee:	26 96       	adiw	r28, 0x06	; 6
    28f0:	cd bf       	out	0x3d, r28	; 61
    28f2:	de bf       	out	0x3e, r29	; 62
    28f4:	cf 91       	pop	r28
    28f6:	df 91       	pop	r29
    28f8:	1f 91       	pop	r17
    28fa:	0f 91       	pop	r16
    28fc:	ff 90       	pop	r15
    28fe:	ef 90       	pop	r14
    2900:	df 90       	pop	r13
    2902:	cf 90       	pop	r12
    2904:	bf 90       	pop	r11
    2906:	af 90       	pop	r10
    2908:	9f 90       	pop	r9
    290a:	8f 90       	pop	r8
    290c:	7f 90       	pop	r7
    290e:	6f 90       	pop	r6
    2910:	5f 90       	pop	r5
    2912:	4f 90       	pop	r4
    2914:	3f 90       	pop	r3
    2916:	2f 90       	pop	r2
    2918:	08 95       	ret

0000291a <st_go_home>:
/* st_go_home() - perform the homing cycle */

void st_go_home()
{
  // Todo: Perform the homing cycle
}
    291a:	08 95       	ret

0000291c <st_print_four_ints>:

// ++++ DEBUG CODE
void st_print_four_ints(long x, long y, long z, long u) {
    291c:	2f 92       	push	r2
    291e:	3f 92       	push	r3
    2920:	4f 92       	push	r4
    2922:	5f 92       	push	r5
    2924:	6f 92       	push	r6
    2926:	7f 92       	push	r7
    2928:	8f 92       	push	r8
    292a:	9f 92       	push	r9
    292c:	af 92       	push	r10
    292e:	bf 92       	push	r11
    2930:	cf 92       	push	r12
    2932:	df 92       	push	r13
    2934:	ef 92       	push	r14
    2936:	ff 92       	push	r15
    2938:	0f 93       	push	r16
    293a:	1f 93       	push	r17
    293c:	3b 01       	movw	r6, r22
    293e:	4c 01       	movw	r8, r24
    2940:	19 01       	movw	r2, r18
    2942:	2a 01       	movw	r4, r20
	printPgmString(PSTR("Line: X="));
    2944:	80 e3       	ldi	r24, 0x30	; 48
    2946:	94 e0       	ldi	r25, 0x04	; 4
    2948:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
	printInteger(x);
    294c:	c4 01       	movw	r24, r8
    294e:	b3 01       	movw	r22, r6
    2950:	0e 94 b6 17 	call	0x2f6c	; 0x2f6c <printInteger>
	printPgmString(PSTR(" Y="));
    2954:	8c e2       	ldi	r24, 0x2C	; 44
    2956:	94 e0       	ldi	r25, 0x04	; 4
    2958:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
	printInteger(y);
    295c:	c2 01       	movw	r24, r4
    295e:	b1 01       	movw	r22, r2
    2960:	0e 94 b6 17 	call	0x2f6c	; 0x2f6c <printInteger>
	printPgmString(PSTR(" Z="));
    2964:	88 e2       	ldi	r24, 0x28	; 40
    2966:	94 e0       	ldi	r25, 0x04	; 4
    2968:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
	printInteger(z);
    296c:	c8 01       	movw	r24, r16
    296e:	b7 01       	movw	r22, r14
    2970:	0e 94 b6 17 	call	0x2f6c	; 0x2f6c <printInteger>
	printPgmString(PSTR(" uS="));
    2974:	83 e2       	ldi	r24, 0x23	; 35
    2976:	94 e0       	ldi	r25, 0x04	; 4
    2978:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
	printInteger(u);
    297c:	c6 01       	movw	r24, r12
    297e:	b5 01       	movw	r22, r10
    2980:	0e 94 b6 17 	call	0x2f6c	; 0x2f6c <printInteger>
	printPgmString(PSTR("\r\n"));
    2984:	80 e2       	ldi	r24, 0x20	; 32
    2986:	94 e0       	ldi	r25, 0x04	; 4
    2988:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
}
    298c:	1f 91       	pop	r17
    298e:	0f 91       	pop	r16
    2990:	ff 90       	pop	r15
    2992:	ef 90       	pop	r14
    2994:	df 90       	pop	r13
    2996:	cf 90       	pop	r12
    2998:	bf 90       	pop	r11
    299a:	af 90       	pop	r10
    299c:	9f 90       	pop	r9
    299e:	8f 90       	pop	r8
    29a0:	7f 90       	pop	r7
    29a2:	6f 90       	pop	r6
    29a4:	5f 90       	pop	r5
    29a6:	4f 90       	pop	r4
    29a8:	3f 90       	pop	r3
    29aa:	2f 90       	pop	r2
    29ac:	08 95       	ret

000029ae <st_print_line>:
	printPgmString(PSTR("ACTIVE = "));		// ++++ DEBUG CODE
	printHex(ax.active_axes);
	printPgmString(PSTR("\r\n"));		// ++++ DEBUG CODE
}

void st_print_line(struct Line line) {
    29ae:	2f 92       	push	r2
    29b0:	3f 92       	push	r3
    29b2:	4f 92       	push	r4
    29b4:	5f 92       	push	r5
    29b6:	6f 92       	push	r6
    29b8:	7f 92       	push	r7
    29ba:	8f 92       	push	r8
    29bc:	9f 92       	push	r9
    29be:	af 92       	push	r10
    29c0:	bf 92       	push	r11
    29c2:	cf 92       	push	r12
    29c4:	df 92       	push	r13
    29c6:	ef 92       	push	r14
    29c8:	ff 92       	push	r15
    29ca:	0f 93       	push	r16
    29cc:	1f 93       	push	r17
    29ce:	df 93       	push	r29
    29d0:	cf 93       	push	r28
    29d2:	cd b7       	in	r28, 0x3d	; 61
    29d4:	de b7       	in	r29, 0x3e	; 62
    29d6:	28 97       	sbiw	r28, 0x08	; 8
    29d8:	cd bf       	out	0x3d, r28	; 61
    29da:	de bf       	out	0x3e, r29	; 62
    29dc:	ae a0       	ldd	r10, Y+38	; 0x26
    29de:	bf a0       	ldd	r11, Y+39	; 0x27
    29e0:	c8 a4       	ldd	r12, Y+40	; 0x28
    29e2:	d9 a4       	ldd	r13, Y+41	; 0x29
    29e4:	6a a4       	ldd	r6, Y+42	; 0x2a
    29e6:	7b a4       	ldd	r7, Y+43	; 0x2b
    29e8:	8c a4       	ldd	r8, Y+44	; 0x2c
    29ea:	9d a4       	ldd	r9, Y+45	; 0x2d
    29ec:	2e a4       	ldd	r2, Y+46	; 0x2e
    29ee:	3f a4       	ldd	r3, Y+47	; 0x2f
    29f0:	48 a8       	ldd	r4, Y+48	; 0x30
    29f2:	59 a8       	ldd	r5, Y+49	; 0x31
    29f4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    29f6:	9f 8d       	ldd	r25, Y+31	; 0x1f
    29f8:	a8 a1       	ldd	r26, Y+32	; 0x20
    29fa:	b9 a1       	ldd	r27, Y+33	; 0x21
    29fc:	8d 83       	std	Y+5, r24	; 0x05
    29fe:	9e 83       	std	Y+6, r25	; 0x06
    2a00:	af 83       	std	Y+7, r26	; 0x07
    2a02:	b8 87       	std	Y+8, r27	; 0x08
    2a04:	ea a8       	ldd	r14, Y+50	; 0x32
    2a06:	8a a1       	ldd	r24, Y+34	; 0x22
    2a08:	9b a1       	ldd	r25, Y+35	; 0x23
    2a0a:	ac a1       	ldd	r26, Y+36	; 0x24
    2a0c:	bd a1       	ldd	r27, Y+37	; 0x25
    2a0e:	89 83       	std	Y+1, r24	; 0x01
    2a10:	9a 83       	std	Y+2, r25	; 0x02
    2a12:	ab 83       	std	Y+3, r26	; 0x03
    2a14:	bc 83       	std	Y+4, r27	; 0x04
	printPgmString(PSTR("Line X="));		// ++++ DEBUG CODE
    2a16:	8b e0       	ldi	r24, 0x0B	; 11
    2a18:	94 e0       	ldi	r25, 0x04	; 4
    2a1a:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
	printInteger(line.steps_x);
    2a1e:	c6 01       	movw	r24, r12
    2a20:	b5 01       	movw	r22, r10
    2a22:	0e 94 b6 17 	call	0x2f6c	; 0x2f6c <printInteger>
	printPgmString(PSTR(", Y="));
    2a26:	86 e0       	ldi	r24, 0x06	; 6
    2a28:	94 e0       	ldi	r25, 0x04	; 4
    2a2a:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
	printInteger(line.steps_y);
    2a2e:	c4 01       	movw	r24, r8
    2a30:	b3 01       	movw	r22, r6
    2a32:	0e 94 b6 17 	call	0x2f6c	; 0x2f6c <printInteger>
	printPgmString(PSTR(", Z="));
    2a36:	81 e0       	ldi	r24, 0x01	; 1
    2a38:	94 e0       	ldi	r25, 0x04	; 4
    2a3a:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
	printInteger(line.steps_z);
    2a3e:	c2 01       	movw	r24, r4
    2a40:	b1 01       	movw	r22, r2
    2a42:	0e 94 b6 17 	call	0x2f6c	; 0x2f6c <printInteger>
	printPgmString(PSTR(", uS="));
    2a46:	8b ef       	ldi	r24, 0xFB	; 251
    2a48:	93 e0       	ldi	r25, 0x03	; 3
    2a4a:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
	printInteger(line.microseconds);
    2a4e:	6d 81       	ldd	r22, Y+5	; 0x05
    2a50:	7e 81       	ldd	r23, Y+6	; 0x06
    2a52:	8f 81       	ldd	r24, Y+7	; 0x07
    2a54:	98 85       	ldd	r25, Y+8	; 0x08
    2a56:	0e 94 b6 17 	call	0x2f6c	; 0x2f6c <printInteger>
	printPgmString(PSTR(", D="));
    2a5a:	86 ef       	ldi	r24, 0xF6	; 246
    2a5c:	93 e0       	ldi	r25, 0x03	; 3
    2a5e:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
	printHex(line.direction_bits);
    2a62:	ff 24       	eor	r15, r15
    2a64:	00 e0       	ldi	r16, 0x00	; 0
    2a66:	10 e0       	ldi	r17, 0x00	; 0
    2a68:	c8 01       	movw	r24, r16
    2a6a:	b7 01       	movw	r22, r14
    2a6c:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <printHex>
	printPgmString(PSTR(", Steps="));
    2a70:	8d ee       	ldi	r24, 0xED	; 237
    2a72:	93 e0       	ldi	r25, 0x03	; 3
    2a74:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
	printInteger(line.steps_max);
    2a78:	69 81       	ldd	r22, Y+1	; 0x01
    2a7a:	7a 81       	ldd	r23, Y+2	; 0x02
    2a7c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a7e:	9c 81       	ldd	r25, Y+4	; 0x04
    2a80:	0e 94 b6 17 	call	0x2f6c	; 0x2f6c <printInteger>
 	printPgmString(PSTR("\r\n"));
    2a84:	8a ee       	ldi	r24, 0xEA	; 234
    2a86:	93 e0       	ldi	r25, 0x03	; 3
    2a88:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
}
    2a8c:	28 96       	adiw	r28, 0x08	; 8
    2a8e:	cd bf       	out	0x3d, r28	; 61
    2a90:	de bf       	out	0x3e, r29	; 62
    2a92:	cf 91       	pop	r28
    2a94:	df 91       	pop	r29
    2a96:	1f 91       	pop	r17
    2a98:	0f 91       	pop	r16
    2a9a:	ff 90       	pop	r15
    2a9c:	ef 90       	pop	r14
    2a9e:	df 90       	pop	r13
    2aa0:	cf 90       	pop	r12
    2aa2:	bf 90       	pop	r11
    2aa4:	af 90       	pop	r10
    2aa6:	9f 90       	pop	r9
    2aa8:	8f 90       	pop	r8
    2aaa:	7f 90       	pop	r7
    2aac:	6f 90       	pop	r6
    2aae:	5f 90       	pop	r5
    2ab0:	4f 90       	pop	r4
    2ab2:	3f 90       	pop	r3
    2ab4:	2f 90       	pop	r2
    2ab6:	08 95       	ret

00002ab8 <st_execute_line>:
			ln->steps_x = steps to take 
*/
/*******************************************************************************/

void st_execute_line()
{
    2ab8:	2f 92       	push	r2
    2aba:	3f 92       	push	r3
    2abc:	4f 92       	push	r4
    2abe:	5f 92       	push	r5
    2ac0:	6f 92       	push	r6
    2ac2:	7f 92       	push	r7
    2ac4:	8f 92       	push	r8
    2ac6:	9f 92       	push	r9
    2ac8:	af 92       	push	r10
    2aca:	bf 92       	push	r11
    2acc:	cf 92       	push	r12
    2ace:	df 92       	push	r13
    2ad0:	ef 92       	push	r14
    2ad2:	ff 92       	push	r15
    2ad4:	0f 93       	push	r16
    2ad6:	1f 93       	push	r17
    2ad8:	df 93       	push	r29
    2ada:	cf 93       	push	r28
    2adc:	00 d0       	rcall	.+0      	; 0x2ade <st_execute_line+0x26>
    2ade:	00 d0       	rcall	.+0      	; 0x2ae0 <st_execute_line+0x28>
    2ae0:	cd b7       	in	r28, 0x3d	; 61
    2ae2:	de b7       	in	r29, 0x3e	; 62

	uint32_t step_rate_x; 					// step rate in microseconds per step
	uint32_t step_rate_y; 
	uint32_t step_rate_z; 

	if (ax.active_axes != 0) {
    2ae4:	80 91 71 21 	lds	r24, 0x2171
    2ae8:	88 23       	and	r24, r24
    2aea:	09 f0       	breq	.+2      	; 0x2aee <st_execute_line+0x36>
    2aec:	cd c0       	rjmp	.+410    	; 0x2c88 <st_execute_line+0x1d0>
		return;								// if any bit is set the robot is active
	}
	if ((ln = st_get_next_line()) == NULL) {
    2aee:	0e 94 64 13 	call	0x26c8	; 0x26c8 <st_get_next_line>
    2af2:	8d 83       	std	Y+5, r24	; 0x05
    2af4:	9e 83       	std	Y+6, r25	; 0x06
    2af6:	89 2b       	or	r24, r25
    2af8:	09 f4       	brne	.+2      	; 0x2afc <st_execute_line+0x44>
    2afa:	c6 c0       	rjmp	.+396    	; 0x2c88 <st_execute_line+0x1d0>
		return;
  	} 
	st_print_line(*ln);						// ++++ DEBUG CODE
    2afc:	8d b7       	in	r24, 0x3d	; 61
    2afe:	9e b7       	in	r25, 0x3e	; 62
    2b00:	45 97       	sbiw	r24, 0x15	; 21
    2b02:	8d bf       	out	0x3d, r24	; 61
    2b04:	9e bf       	out	0x3e, r25	; 62
    2b06:	ad b7       	in	r26, 0x3d	; 61
    2b08:	be b7       	in	r27, 0x3e	; 62
    2b0a:	11 96       	adiw	r26, 0x01	; 1
    2b0c:	ed 81       	ldd	r30, Y+5	; 0x05
    2b0e:	fe 81       	ldd	r31, Y+6	; 0x06
    2b10:	85 e1       	ldi	r24, 0x15	; 21
    2b12:	01 90       	ld	r0, Z+
    2b14:	0d 92       	st	X+, r0
    2b16:	81 50       	subi	r24, 0x01	; 1
    2b18:	e1 f7       	brne	.-8      	; 0x2b12 <st_execute_line+0x5a>
    2b1a:	0e 94 d7 14 	call	0x29ae	; 0x29ae <st_print_line>
	st_print_four_ints(ln->steps_x, ln->steps_y, ln->steps_z, ln->microseconds);
    2b1e:	ed b7       	in	r30, 0x3d	; 61
    2b20:	fe b7       	in	r31, 0x3e	; 62
    2b22:	75 96       	adiw	r30, 0x15	; 21
    2b24:	ed bf       	out	0x3d, r30	; 61
    2b26:	fe bf       	out	0x3e, r31	; 62
    2b28:	ed 81       	ldd	r30, Y+5	; 0x05
    2b2a:	fe 81       	ldd	r31, Y+6	; 0x06
    2b2c:	60 85       	ldd	r22, Z+8	; 0x08
    2b2e:	71 85       	ldd	r23, Z+9	; 0x09
    2b30:	82 85       	ldd	r24, Z+10	; 0x0a
    2b32:	93 85       	ldd	r25, Z+11	; 0x0b
    2b34:	24 85       	ldd	r18, Z+12	; 0x0c
    2b36:	35 85       	ldd	r19, Z+13	; 0x0d
    2b38:	46 85       	ldd	r20, Z+14	; 0x0e
    2b3a:	57 85       	ldd	r21, Z+15	; 0x0f
    2b3c:	e0 88       	ldd	r14, Z+16	; 0x10
    2b3e:	f1 88       	ldd	r15, Z+17	; 0x11
    2b40:	02 89       	ldd	r16, Z+18	; 0x12
    2b42:	13 89       	ldd	r17, Z+19	; 0x13
    2b44:	a0 80       	ld	r10, Z
    2b46:	b1 80       	ldd	r11, Z+1	; 0x01
    2b48:	c2 80       	ldd	r12, Z+2	; 0x02
    2b4a:	d3 80       	ldd	r13, Z+3	; 0x03
    2b4c:	0e 94 8e 14 	call	0x291c	; 0x291c <st_print_four_ints>

	// compute the timer intervals we will need (in microseconds)
	step_rate_x = (ln->microseconds / ln->steps_x);	// step_rate in microseconds per step
    2b50:	ed 81       	ldd	r30, Y+5	; 0x05
    2b52:	fe 81       	ldd	r31, Y+6	; 0x06
    2b54:	a0 80       	ld	r10, Z
    2b56:	b1 80       	ldd	r11, Z+1	; 0x01
    2b58:	c2 80       	ldd	r12, Z+2	; 0x02
    2b5a:	d3 80       	ldd	r13, Z+3	; 0x03
    2b5c:	20 85       	ldd	r18, Z+8	; 0x08
    2b5e:	31 85       	ldd	r19, Z+9	; 0x09
    2b60:	42 85       	ldd	r20, Z+10	; 0x0a
    2b62:	53 85       	ldd	r21, Z+11	; 0x0b
    2b64:	c6 01       	movw	r24, r12
    2b66:	b5 01       	movw	r22, r10
    2b68:	0e 94 a9 1c 	call	0x3952	; 0x3952 <__udivmodsi4>
    2b6c:	92 2e       	mov	r9, r18
    2b6e:	83 2e       	mov	r8, r19
    2b70:	74 2e       	mov	r7, r20
    2b72:	65 2e       	mov	r6, r21
	step_rate_y = (ln->microseconds / ln->steps_y);
    2b74:	ed 81       	ldd	r30, Y+5	; 0x05
    2b76:	fe 81       	ldd	r31, Y+6	; 0x06
    2b78:	24 85       	ldd	r18, Z+12	; 0x0c
    2b7a:	35 85       	ldd	r19, Z+13	; 0x0d
    2b7c:	46 85       	ldd	r20, Z+14	; 0x0e
    2b7e:	57 85       	ldd	r21, Z+15	; 0x0f
    2b80:	c6 01       	movw	r24, r12
    2b82:	b5 01       	movw	r22, r10
    2b84:	0e 94 a9 1c 	call	0x3952	; 0x3952 <__udivmodsi4>
    2b88:	52 2e       	mov	r5, r18
    2b8a:	43 2e       	mov	r4, r19
    2b8c:	34 2e       	mov	r3, r20
    2b8e:	25 2e       	mov	r2, r21
	step_rate_z = (ln->microseconds / ln->steps_z);
    2b90:	ed 81       	ldd	r30, Y+5	; 0x05
    2b92:	fe 81       	ldd	r31, Y+6	; 0x06
    2b94:	20 89       	ldd	r18, Z+16	; 0x10
    2b96:	31 89       	ldd	r19, Z+17	; 0x11
    2b98:	42 89       	ldd	r20, Z+18	; 0x12
    2b9a:	53 89       	ldd	r21, Z+19	; 0x13
    2b9c:	c6 01       	movw	r24, r12
    2b9e:	b5 01       	movw	r22, r10
    2ba0:	0e 94 a9 1c 	call	0x3952	; 0x3952 <__udivmodsi4>
    2ba4:	29 83       	std	Y+1, r18	; 0x01
    2ba6:	3a 83       	std	Y+2, r19	; 0x02
    2ba8:	4b 83       	std	Y+3, r20	; 0x03
    2baa:	5c 83       	std	Y+4, r21	; 0x04
	st_print_four_ints(step_rate_x, step_rate_y, step_rate_z, ln->microseconds);
    2bac:	69 2d       	mov	r22, r9
    2bae:	78 2d       	mov	r23, r8
    2bb0:	87 2d       	mov	r24, r7
    2bb2:	96 2d       	mov	r25, r6
    2bb4:	25 2d       	mov	r18, r5
    2bb6:	34 2d       	mov	r19, r4
    2bb8:	43 2d       	mov	r20, r3
    2bba:	52 2d       	mov	r21, r2
    2bbc:	e9 80       	ldd	r14, Y+1	; 0x01
    2bbe:	fa 80       	ldd	r15, Y+2	; 0x02
    2bc0:	0b 81       	ldd	r16, Y+3	; 0x03
    2bc2:	1c 81       	ldd	r17, Y+4	; 0x04
    2bc4:	0e 94 8e 14 	call	0x291c	; 0x291c <st_print_four_ints>
//	st_print_four_ints(((step_rate_x >> 8) & 0x000000FF), (step_rate_x & 0x000000FF), 0, 0);
	
	// set direction bits
	if (ln->direction_bits & X_DIRECTION_BIT_bm) {			// if X is set (CW)
    2bc8:	ed 81       	ldd	r30, Y+5	; 0x05
    2bca:	fe 81       	ldd	r31, Y+6	; 0x06
    2bcc:	84 89       	ldd	r24, Z+20	; 0x14
    2bce:	84 ff       	sbrs	r24, 4
    2bd0:	07 c0       	rjmp	.+14     	; 0x2be0 <st_execute_line+0x128>
		ax.x.port->OUTSET = DIRECTION_BIT_bm;
    2bd2:	e0 91 16 21 	lds	r30, 0x2116
    2bd6:	f0 91 17 21 	lds	r31, 0x2117
    2bda:	82 e0       	ldi	r24, 0x02	; 2
    2bdc:	85 83       	std	Z+5, r24	; 0x05
    2bde:	06 c0       	rjmp	.+12     	; 0x2bec <st_execute_line+0x134>
	} else {
		ax.x.port->OUTCLR = DIRECTION_BIT_bm;
    2be0:	e0 91 16 21 	lds	r30, 0x2116
    2be4:	f0 91 17 21 	lds	r31, 0x2117
    2be8:	82 e0       	ldi	r24, 0x02	; 2
    2bea:	86 83       	std	Z+6, r24	; 0x06
	}
	if (ln->direction_bits & Y_DIRECTION_BIT_bm) {
    2bec:	ed 81       	ldd	r30, Y+5	; 0x05
    2bee:	fe 81       	ldd	r31, Y+6	; 0x06
    2bf0:	84 89       	ldd	r24, Z+20	; 0x14
    2bf2:	85 ff       	sbrs	r24, 5
    2bf4:	07 c0       	rjmp	.+14     	; 0x2c04 <st_execute_line+0x14c>
		ax.y.port->OUTSET = DIRECTION_BIT_bm;
    2bf6:	e0 91 33 21 	lds	r30, 0x2133
    2bfa:	f0 91 34 21 	lds	r31, 0x2134
    2bfe:	82 e0       	ldi	r24, 0x02	; 2
    2c00:	85 83       	std	Z+5, r24	; 0x05
    2c02:	06 c0       	rjmp	.+12     	; 0x2c10 <st_execute_line+0x158>
	} else {
		ax.y.port->OUTCLR = DIRECTION_BIT_bm;
    2c04:	e0 91 33 21 	lds	r30, 0x2133
    2c08:	f0 91 34 21 	lds	r31, 0x2134
    2c0c:	82 e0       	ldi	r24, 0x02	; 2
    2c0e:	86 83       	std	Z+6, r24	; 0x06
	}
	if (ln->direction_bits & Z_DIRECTION_BIT_bm) {
    2c10:	ed 81       	ldd	r30, Y+5	; 0x05
    2c12:	fe 81       	ldd	r31, Y+6	; 0x06
    2c14:	84 89       	ldd	r24, Z+20	; 0x14
    2c16:	86 ff       	sbrs	r24, 6
    2c18:	07 c0       	rjmp	.+14     	; 0x2c28 <st_execute_line+0x170>
		ax.z.port->OUTSET = DIRECTION_BIT_bm;
    2c1a:	e0 91 50 21 	lds	r30, 0x2150
    2c1e:	f0 91 51 21 	lds	r31, 0x2151
    2c22:	82 e0       	ldi	r24, 0x02	; 2
    2c24:	85 83       	std	Z+5, r24	; 0x05
    2c26:	06 c0       	rjmp	.+12     	; 0x2c34 <st_execute_line+0x17c>
	} else {
		ax.z.port->OUTCLR = DIRECTION_BIT_bm;
    2c28:	e0 91 50 21 	lds	r30, 0x2150
    2c2c:	f0 91 51 21 	lds	r31, 0x2151
    2c30:	82 e0       	ldi	r24, 0x02	; 2
    2c32:	86 83       	std	Z+6, r24	; 0x06
	}

	// load timers
	_st_load_timer(&ax.x, step_rate_x, ln->microseconds);
    2c34:	ed 81       	ldd	r30, Y+5	; 0x05
    2c36:	fe 81       	ldd	r31, Y+6	; 0x06
    2c38:	00 81       	ld	r16, Z
    2c3a:	11 81       	ldd	r17, Z+1	; 0x01
    2c3c:	22 81       	ldd	r18, Z+2	; 0x02
    2c3e:	33 81       	ldd	r19, Z+3	; 0x03
    2c40:	8d ef       	ldi	r24, 0xFD	; 253
    2c42:	90 e2       	ldi	r25, 0x20	; 32
    2c44:	49 2d       	mov	r20, r9
    2c46:	58 2d       	mov	r21, r8
    2c48:	67 2d       	mov	r22, r7
    2c4a:	76 2d       	mov	r23, r6
    2c4c:	0e 94 96 12 	call	0x252c	; 0x252c <_st_load_timer>
	_st_load_timer(&ax.y, step_rate_y, ln->microseconds);
    2c50:	ed 81       	ldd	r30, Y+5	; 0x05
    2c52:	fe 81       	ldd	r31, Y+6	; 0x06
    2c54:	00 81       	ld	r16, Z
    2c56:	11 81       	ldd	r17, Z+1	; 0x01
    2c58:	22 81       	ldd	r18, Z+2	; 0x02
    2c5a:	33 81       	ldd	r19, Z+3	; 0x03
    2c5c:	8a e1       	ldi	r24, 0x1A	; 26
    2c5e:	91 e2       	ldi	r25, 0x21	; 33
    2c60:	45 2d       	mov	r20, r5
    2c62:	54 2d       	mov	r21, r4
    2c64:	63 2d       	mov	r22, r3
    2c66:	72 2d       	mov	r23, r2
    2c68:	0e 94 96 12 	call	0x252c	; 0x252c <_st_load_timer>
	_st_load_timer(&ax.z, step_rate_z, ln->microseconds);
    2c6c:	ed 81       	ldd	r30, Y+5	; 0x05
    2c6e:	fe 81       	ldd	r31, Y+6	; 0x06
    2c70:	00 81       	ld	r16, Z
    2c72:	11 81       	ldd	r17, Z+1	; 0x01
    2c74:	22 81       	ldd	r18, Z+2	; 0x02
    2c76:	33 81       	ldd	r19, Z+3	; 0x03
    2c78:	87 e3       	ldi	r24, 0x37	; 55
    2c7a:	91 e2       	ldi	r25, 0x21	; 33
    2c7c:	49 81       	ldd	r20, Y+1	; 0x01
    2c7e:	5a 81       	ldd	r21, Y+2	; 0x02
    2c80:	6b 81       	ldd	r22, Y+3	; 0x03
    2c82:	7c 81       	ldd	r23, Y+4	; 0x04
    2c84:	0e 94 96 12 	call	0x252c	; 0x252c <_st_load_timer>
}
    2c88:	26 96       	adiw	r28, 0x06	; 6
    2c8a:	cd bf       	out	0x3d, r28	; 61
    2c8c:	de bf       	out	0x3e, r29	; 62
    2c8e:	cf 91       	pop	r28
    2c90:	df 91       	pop	r29
    2c92:	1f 91       	pop	r17
    2c94:	0f 91       	pop	r16
    2c96:	ff 90       	pop	r15
    2c98:	ef 90       	pop	r14
    2c9a:	df 90       	pop	r13
    2c9c:	cf 90       	pop	r12
    2c9e:	bf 90       	pop	r11
    2ca0:	af 90       	pop	r10
    2ca2:	9f 90       	pop	r9
    2ca4:	8f 90       	pop	r8
    2ca6:	7f 90       	pop	r7
    2ca8:	6f 90       	pop	r6
    2caa:	5f 90       	pop	r5
    2cac:	4f 90       	pop	r4
    2cae:	3f 90       	pop	r3
    2cb0:	2f 90       	pop	r2
    2cb2:	08 95       	ret

00002cb4 <st_print_active>:
	printInteger(u);
	printPgmString(PSTR("\r\n"));
}

void st_print_active() {
	printPgmString(PSTR("ACTIVE = "));		// ++++ DEBUG CODE
    2cb4:	86 e1       	ldi	r24, 0x16	; 22
    2cb6:	94 e0       	ldi	r25, 0x04	; 4
    2cb8:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
	printHex(ax.active_axes);
    2cbc:	60 91 71 21 	lds	r22, 0x2171
    2cc0:	70 e0       	ldi	r23, 0x00	; 0
    2cc2:	80 e0       	ldi	r24, 0x00	; 0
    2cc4:	90 e0       	ldi	r25, 0x00	; 0
    2cc6:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <printHex>
	printPgmString(PSTR("\r\n"));		// ++++ DEBUG CODE
    2cca:	83 e1       	ldi	r24, 0x13	; 19
    2ccc:	94 e0       	ldi	r25, 0x04	; 4
    2cce:	0e 94 20 17 	call	0x2e40	; 0x2e40 <printPgmString>
}
    2cd2:	08 95       	ret

00002cd4 <beginSerial>:
   "baud" value is ignored and set internally to the routine
 */

void beginSerial(long baud) 
{
	PORTC.DIRCLR = (1<<2); 					// clr PORTC:6 receive pin as input
    2cd4:	e0 e4       	ldi	r30, 0x40	; 64
    2cd6:	f6 e0       	ldi	r31, 0x06	; 6
    2cd8:	84 e0       	ldi	r24, 0x04	; 4
    2cda:	82 83       	std	Z+2, r24	; 0x02
	PORTC.DIRSET = (1<<3); 					// set PORTC:7 transmit pin as output
    2cdc:	88 e0       	ldi	r24, 0x08	; 8
    2cde:	81 83       	std	Z+1, r24	; 0x01
	PORTC.OUTSET = (1<<3);					// set TX pin HI as initial state
    2ce0:	85 83       	std	Z+5, r24	; 0x05

	USARTC0.BAUDCTRLA = USB_BSEL;
    2ce2:	e0 ea       	ldi	r30, 0xA0	; 160
    2ce4:	f8 e0       	ldi	r31, 0x08	; 8
    2ce6:	81 e2       	ldi	r24, 0x21	; 33
    2ce8:	86 83       	std	Z+6, r24	; 0x06
	USARTC0.BAUDCTRLB = USB_BSCALE;
    2cea:	80 ef       	ldi	r24, 0xF0	; 240
    2cec:	87 83       	std	Z+7, r24	; 0x07
	USARTC0.CTRLB = USART_TXEN_bm | USART_RXEN_bm; // enable tx and rx on USART
    2cee:	88 e1       	ldi	r24, 0x18	; 24
    2cf0:	84 83       	std	Z+4, r24	; 0x04
	USARTC0.CTRLA = USART_RXCINTLVL_MED_gc;		   // receive interrupt medium level
    2cf2:	80 e2       	ldi	r24, 0x20	; 32
    2cf4:	83 83       	std	Z+3, r24	; 0x03
    2cf6:	80 e2       	ldi	r24, 0x20	; 32
    2cf8:	93 e0       	ldi	r25, 0x03	; 3
    2cfa:	01 97       	sbiw	r24, 0x01	; 1
    2cfc:	f1 f7       	brne	.-4      	; 0x2cfa <beginSerial+0x26>

	_delay_us(100);							// give it a chance to settle before use
}
    2cfe:	08 95       	ret

00002d00 <beginSerialC1>:

void beginSerialC1(long baud) 
{
	PORTC.DIRCLR = (1<<6); 					// clr PORTC:6 receive pin as input
    2d00:	e0 e4       	ldi	r30, 0x40	; 64
    2d02:	f6 e0       	ldi	r31, 0x06	; 6
    2d04:	80 e4       	ldi	r24, 0x40	; 64
    2d06:	82 83       	std	Z+2, r24	; 0x02
	PORTC.DIRSET = (1<<7); 					// set PORTC:7 transmit pin as output
    2d08:	80 e8       	ldi	r24, 0x80	; 128
    2d0a:	81 83       	std	Z+1, r24	; 0x01
	PORTC.OUTSET = (1<<7);					// set TX pin HI as initial state
    2d0c:	85 83       	std	Z+5, r24	; 0x05
//	PORTC.DIRSET = enableDE_bm;				// set PORTC:5 for DE line as output
//	PORTC.OUTCLR = enableDE_bm;        		// clr PORTC:5 (disabled)
//	PORTC.DIRSET = enableRE_bm;				// set PORTC:4 for ~RE line as output
//	PORTC.OUTCLR = enableRE_bm;				// clr PORTC:4 (enabled) 

	USARTC1.BAUDCTRLA = USB_BSEL;
    2d0e:	e0 eb       	ldi	r30, 0xB0	; 176
    2d10:	f8 e0       	ldi	r31, 0x08	; 8
    2d12:	81 e2       	ldi	r24, 0x21	; 33
    2d14:	86 83       	std	Z+6, r24	; 0x06
	USARTC1.BAUDCTRLB = USB_BSCALE;
    2d16:	80 ef       	ldi	r24, 0xF0	; 240
    2d18:	87 83       	std	Z+7, r24	; 0x07
	USARTC1.CTRLB = USART_TXEN_bm | USART_RXEN_bm; // enable tx and rx on USART
    2d1a:	88 e1       	ldi	r24, 0x18	; 24
    2d1c:	84 83       	std	Z+4, r24	; 0x04
	USARTC1.CTRLA = USART_RXCINTLVL_MED_gc;		   // receive interrupt medium level
    2d1e:	80 e2       	ldi	r24, 0x20	; 32
    2d20:	83 83       	std	Z+3, r24	; 0x03
    2d22:	80 e2       	ldi	r24, 0x20	; 32
    2d24:	93 e0       	ldi	r25, 0x03	; 3
    2d26:	01 97       	sbiw	r24, 0x01	; 1
    2d28:	f1 f7       	brne	.-4      	; 0x2d26 <beginSerialC1+0x26>

	_delay_us(100);							// give it a chance to settle before use
}
    2d2a:	08 95       	ret

00002d2c <__vector_25>:

/* ISR for USB serial RX - receive serial byte from USB port*/

ISR(USARTC0_RXC_vect)
{
    2d2c:	1f 92       	push	r1
    2d2e:	0f 92       	push	r0
    2d30:	0f b6       	in	r0, 0x3f	; 63
    2d32:	0f 92       	push	r0
    2d34:	0b b6       	in	r0, 0x3b	; 59
    2d36:	0f 92       	push	r0
    2d38:	11 24       	eor	r1, r1
    2d3a:	2f 93       	push	r18
    2d3c:	8f 93       	push	r24
    2d3e:	9f 93       	push	r25
    2d40:	ef 93       	push	r30
    2d42:	ff 93       	push	r31
	unsigned char c = USARTC0.DATA;
    2d44:	20 91 a0 08 	lds	r18, 0x08A0
	uint8_t i = (rx_buffer_head + 1) & RX_BUFFER_MASK;
    2d48:	e0 91 31 20 	lds	r30, 0x2031
    2d4c:	ef 5f       	subi	r30, 0xFF	; 255
    2d4e:	9e 2f       	mov	r25, r30
    2d50:	9f 77       	andi	r25, 0x7F	; 127
    2d52:	e1 50       	subi	r30, 0x01	; 1
	/*  If we should be storing the received character into the location
		just before the tail (meaning that the head would advance to the
		current location of the tail), we're about to overflow the buffer
		and so we don't write the character or advance the head. */

	if (i != rx_buffer_tail) {
    2d54:	80 91 32 20 	lds	r24, 0x2032
    2d58:	98 17       	cp	r25, r24
    2d5a:	31 f0       	breq	.+12     	; 0x2d68 <__vector_25+0x3c>
		rx_buffer[rx_buffer_head] = c;
    2d5c:	f0 e0       	ldi	r31, 0x00	; 0
    2d5e:	e6 54       	subi	r30, 0x46	; 70
    2d60:	fb 4d       	sbci	r31, 0xDB	; 219
    2d62:	20 83       	st	Z, r18
		rx_buffer_head = i;
    2d64:	90 93 31 20 	sts	0x2031, r25
	}
}
    2d68:	ff 91       	pop	r31
    2d6a:	ef 91       	pop	r30
    2d6c:	9f 91       	pop	r25
    2d6e:	8f 91       	pop	r24
    2d70:	2f 91       	pop	r18
    2d72:	0f 90       	pop	r0
    2d74:	0b be       	out	0x3b, r0	; 59
    2d76:	0f 90       	pop	r0
    2d78:	0f be       	out	0x3f, r0	; 63
    2d7a:	0f 90       	pop	r0
    2d7c:	1f 90       	pop	r1
    2d7e:	18 95       	reti

00002d80 <__vector_28>:

ISR(USARTC1_RXC_vect)
{
    2d80:	1f 92       	push	r1
    2d82:	0f 92       	push	r0
    2d84:	0f b6       	in	r0, 0x3f	; 63
    2d86:	0f 92       	push	r0
    2d88:	0b b6       	in	r0, 0x3b	; 59
    2d8a:	0f 92       	push	r0
    2d8c:	11 24       	eor	r1, r1
    2d8e:	2f 93       	push	r18
    2d90:	8f 93       	push	r24
    2d92:	9f 93       	push	r25
    2d94:	ef 93       	push	r30
    2d96:	ff 93       	push	r31
	unsigned char c = USARTC1.DATA;
    2d98:	20 91 b0 08 	lds	r18, 0x08B0
	uint8_t i = (rx_buffer_head + 1) & RX_BUFFER_MASK;
    2d9c:	e0 91 31 20 	lds	r30, 0x2031
    2da0:	ef 5f       	subi	r30, 0xFF	; 255
    2da2:	9e 2f       	mov	r25, r30
    2da4:	9f 77       	andi	r25, 0x7F	; 127
    2da6:	e1 50       	subi	r30, 0x01	; 1
	/*  If we should be storing the received character into the location
		just before the tail (meaning that the head would advance to the
		current location of the tail), we're about to overflow the buffer
		and so we don't write the character or advance the head. */

	if (i != rx_buffer_tail) {
    2da8:	80 91 32 20 	lds	r24, 0x2032
    2dac:	98 17       	cp	r25, r24
    2dae:	31 f0       	breq	.+12     	; 0x2dbc <__vector_28+0x3c>
		rx_buffer[rx_buffer_head] = c;
    2db0:	f0 e0       	ldi	r31, 0x00	; 0
    2db2:	e6 54       	subi	r30, 0x46	; 70
    2db4:	fb 4d       	sbci	r31, 0xDB	; 219
    2db6:	20 83       	st	Z, r18
		rx_buffer_head = i;
    2db8:	90 93 31 20 	sts	0x2031, r25
	}
}
    2dbc:	ff 91       	pop	r31
    2dbe:	ef 91       	pop	r30
    2dc0:	9f 91       	pop	r25
    2dc2:	8f 91       	pop	r24
    2dc4:	2f 91       	pop	r18
    2dc6:	0f 90       	pop	r0
    2dc8:	0b be       	out	0x3b, r0	; 59
    2dca:	0f 90       	pop	r0
    2dcc:	0f be       	out	0x3f, r0	; 63
    2dce:	0f 90       	pop	r0
    2dd0:	1f 90       	pop	r1
    2dd2:	18 95       	reti

00002dd4 <serialWrite>:

/* writeSerial() - write character to serial port */

void serialWrite(unsigned char c) 
{
    2dd4:	98 2f       	mov	r25, r24
	while(!(USARTC0.STATUS & USART_DREIF_bm)); 	// spin until TX data register is available
    2dd6:	80 91 a1 08 	lds	r24, 0x08A1
    2dda:	85 ff       	sbrs	r24, 5
    2ddc:	fc cf       	rjmp	.-8      	; 0x2dd6 <serialWrite+0x2>
	USARTC0.DATA = c;							// write data register
    2dde:	90 93 a0 08 	sts	0x08A0, r25
}
    2de2:	08 95       	ret

00002de4 <serialAvailable>:
*/

/* serialAvailable() - optimized for 8 bit operation */

uint8_t serialAvailable() 
{
    2de4:	80 91 31 20 	lds	r24, 0x2031
    2de8:	90 91 32 20 	lds	r25, 0x2032
    2dec:	89 1b       	sub	r24, r25
	return (RX_BUFFER_SIZE + rx_buffer_head - rx_buffer_tail) & RX_BUFFER_MASK;
}
    2dee:	8f 77       	andi	r24, 0x7F	; 127
    2df0:	08 95       	ret

00002df2 <serialRead>:
*/

char serialRead() 
{
	/* if the head isn't ahead of the tail, we don't have any characters */
	if (rx_buffer_head == rx_buffer_tail) {
    2df2:	90 91 32 20 	lds	r25, 0x2032
    2df6:	80 91 31 20 	lds	r24, 0x2031
    2dfa:	89 17       	cp	r24, r25
    2dfc:	11 f4       	brne	.+4      	; 0x2e02 <serialRead+0x10>
    2dfe:	e4 e0       	ldi	r30, 0x04	; 4
    2e00:	0b c0       	rjmp	.+22     	; 0x2e18 <serialRead+0x26>
		return 0x04;											// ASCII EOT
	} else {
		char c = rx_buffer[rx_buffer_tail];
    2e02:	89 2f       	mov	r24, r25
    2e04:	90 e0       	ldi	r25, 0x00	; 0
    2e06:	fc 01       	movw	r30, r24
    2e08:	e6 54       	subi	r30, 0x46	; 70
    2e0a:	fb 4d       	sbci	r31, 0xDB	; 219
    2e0c:	e0 81       	ld	r30, Z
		rx_buffer_tail = (rx_buffer_tail + 1) % RX_BUFFER_SIZE;	// original code
    2e0e:	01 96       	adiw	r24, 0x01	; 1
    2e10:	8f 77       	andi	r24, 0x7F	; 127
    2e12:	90 70       	andi	r25, 0x00	; 0
    2e14:	80 93 32 20 	sts	0x2032, r24
		return c;
	}
}
    2e18:	8e 2f       	mov	r24, r30
    2e1a:	08 95       	ret

00002e1c <serialFlush>:
	/*  don't reverse this or there may be problems if the RX interrupt
		occurs after reading the value of rx_buffer_head but before writing
		the value to rx_buffer_tail; the previous value of rx_buffer_head
		may be written to rx_buffer_tail, making it appear as if the buffer
		were full, not empty. */
	rx_buffer_head = rx_buffer_tail;
    2e1c:	80 91 32 20 	lds	r24, 0x2032
    2e20:	80 93 31 20 	sts	0x2031, r24
}
    2e24:	08 95       	ret

00002e26 <printString>:
	serialWrite(c);
}
*/

void printString(const char *s)
{
    2e26:	fc 01       	movw	r30, r24
    2e28:	07 c0       	rjmp	.+14     	; 0x2e38 <printString+0x12>

/* writeSerial() - write character to serial port */

void serialWrite(unsigned char c) 
{
	while(!(USARTC0.STATUS & USART_DREIF_bm)); 	// spin until TX data register is available
    2e2a:	80 91 a1 08 	lds	r24, 0x08A1
    2e2e:	85 ff       	sbrs	r24, 5
    2e30:	fc cf       	rjmp	.-8      	; 0x2e2a <printString+0x4>
*/

void printString(const char *s)
{
	while (*s) {
		printByte(*s++);
    2e32:	31 96       	adiw	r30, 0x01	; 1
/* writeSerial() - write character to serial port */

void serialWrite(unsigned char c) 
{
	while(!(USARTC0.STATUS & USART_DREIF_bm)); 	// spin until TX data register is available
	USARTC0.DATA = c;							// write data register
    2e34:	90 93 a0 08 	sts	0x08A0, r25
}
*/

void printString(const char *s)
{
	while (*s) {
    2e38:	90 81       	ld	r25, Z
    2e3a:	99 23       	and	r25, r25
    2e3c:	b1 f7       	brne	.-20     	; 0x2e2a <printString+0x4>
		printByte(*s++);
	}
}
    2e3e:	08 95       	ret

00002e40 <printPgmString>:

/*  printPgmString() - print a string stored in PGM-memory */
void printPgmString(const char *s)
{
    2e40:	9c 01       	movw	r18, r24
    2e42:	06 c0       	rjmp	.+12     	; 0x2e50 <printPgmString+0x10>

/* writeSerial() - write character to serial port */

void serialWrite(unsigned char c) 
{
	while(!(USARTC0.STATUS & USART_DREIF_bm)); 	// spin until TX data register is available
    2e44:	80 91 a1 08 	lds	r24, 0x08A1
    2e48:	85 ff       	sbrs	r24, 5
    2e4a:	fc cf       	rjmp	.-8      	; 0x2e44 <printPgmString+0x4>
	USARTC0.DATA = c;							// write data register
    2e4c:	90 93 a0 08 	sts	0x08A0, r25
    2e50:	f9 01       	movw	r30, r18

/*  printPgmString() - print a string stored in PGM-memory */
void printPgmString(const char *s)
{
	unsigned char c;
	while ((c = pgm_read_byte_near(s++))) {
    2e52:	2f 5f       	subi	r18, 0xFF	; 255
    2e54:	3f 4f       	sbci	r19, 0xFF	; 255
    2e56:	94 91       	lpm	r25, Z+
    2e58:	99 23       	and	r25, r25
    2e5a:	a1 f7       	brne	.-24     	; 0x2e44 <printPgmString+0x4>
		printByte(c);
	}
}
    2e5c:	08 95       	ret

00002e5e <printIntegerInBase>:

/* printIntegerInBase() */

void printIntegerInBase(unsigned long n, unsigned long base)
{ 
    2e5e:	2f 92       	push	r2
    2e60:	3f 92       	push	r3
    2e62:	4f 92       	push	r4
    2e64:	5f 92       	push	r5
    2e66:	6f 92       	push	r6
    2e68:	7f 92       	push	r7
    2e6a:	8f 92       	push	r8
    2e6c:	9f 92       	push	r9
    2e6e:	af 92       	push	r10
    2e70:	bf 92       	push	r11
    2e72:	cf 92       	push	r12
    2e74:	df 92       	push	r13
    2e76:	ef 92       	push	r14
    2e78:	ff 92       	push	r15
    2e7a:	0f 93       	push	r16
    2e7c:	1f 93       	push	r17
    2e7e:	df 93       	push	r29
    2e80:	cf 93       	push	r28
    2e82:	cd b7       	in	r28, 0x3d	; 61
    2e84:	de b7       	in	r29, 0x3e	; 62
    2e86:	a0 97       	sbiw	r28, 0x20	; 32
    2e88:	cd bf       	out	0x3d, r28	; 61
    2e8a:	de bf       	out	0x3e, r29	; 62
    2e8c:	6b 01       	movw	r12, r22
    2e8e:	7c 01       	movw	r14, r24
    2e90:	29 01       	movw	r4, r18
    2e92:	3a 01       	movw	r6, r20
	unsigned char buf[8 * sizeof(long)]; // Assumes 8-bit chars. 
	unsigned long i = 0;

	if (n == 0) {
    2e94:	61 15       	cp	r22, r1
    2e96:	71 05       	cpc	r23, r1
    2e98:	81 05       	cpc	r24, r1
    2e9a:	91 05       	cpc	r25, r1
    2e9c:	41 f4       	brne	.+16     	; 0x2eae <printIntegerInBase+0x50>

/* writeSerial() - write character to serial port */

void serialWrite(unsigned char c) 
{
	while(!(USARTC0.STATUS & USART_DREIF_bm)); 	// spin until TX data register is available
    2e9e:	80 91 a1 08 	lds	r24, 0x08A1
    2ea2:	85 ff       	sbrs	r24, 5
    2ea4:	fc cf       	rjmp	.-8      	; 0x2e9e <printIntegerInBase+0x40>
	USARTC0.DATA = c;							// write data register
    2ea6:	80 e3       	ldi	r24, 0x30	; 48
    2ea8:	80 93 a0 08 	sts	0x08A0, r24
    2eac:	49 c0       	rjmp	.+146    	; 0x2f40 <printIntegerInBase+0xe2>
	unsigned char buf[8 * sizeof(long)]; // Assumes 8-bit chars. 
	unsigned long i = 0;

	if (n == 0) {
		printByte('0');
		return;
    2eae:	88 24       	eor	r8, r8
    2eb0:	99 24       	eor	r9, r9
    2eb2:	54 01       	movw	r10, r8
	} 

	while (n > 0) {
		buf[i++] = n % base;
    2eb4:	1e 01       	movw	r2, r28
    2eb6:	08 94       	sec
    2eb8:	21 1c       	adc	r2, r1
    2eba:	31 1c       	adc	r3, r1
    2ebc:	81 01       	movw	r16, r2
    2ebe:	08 0d       	add	r16, r8
    2ec0:	19 1d       	adc	r17, r9
    2ec2:	c7 01       	movw	r24, r14
    2ec4:	b6 01       	movw	r22, r12
    2ec6:	a3 01       	movw	r20, r6
    2ec8:	92 01       	movw	r18, r4
    2eca:	0e 94 a9 1c 	call	0x3952	; 0x3952 <__udivmodsi4>
    2ece:	f8 01       	movw	r30, r16
    2ed0:	60 83       	st	Z, r22
    2ed2:	08 94       	sec
    2ed4:	81 1c       	adc	r8, r1
    2ed6:	91 1c       	adc	r9, r1
    2ed8:	a1 1c       	adc	r10, r1
    2eda:	b1 1c       	adc	r11, r1
		n /= base;
    2edc:	c7 01       	movw	r24, r14
    2ede:	b6 01       	movw	r22, r12
    2ee0:	a3 01       	movw	r20, r6
    2ee2:	92 01       	movw	r18, r4
    2ee4:	0e 94 a9 1c 	call	0x3952	; 0x3952 <__udivmodsi4>
    2ee8:	c9 01       	movw	r24, r18
    2eea:	da 01       	movw	r26, r20
    2eec:	6c 01       	movw	r12, r24
    2eee:	7d 01       	movw	r14, r26
	if (n == 0) {
		printByte('0');
		return;
	} 

	while (n > 0) {
    2ef0:	c1 14       	cp	r12, r1
    2ef2:	d1 04       	cpc	r13, r1
    2ef4:	e1 04       	cpc	r14, r1
    2ef6:	f1 04       	cpc	r15, r1
    2ef8:	09 f7       	brne	.-62     	; 0x2ebc <printIntegerInBase+0x5e>
    2efa:	91 01       	movw	r18, r2
    2efc:	28 0d       	add	r18, r8
    2efe:	39 1d       	adc	r19, r9
		buf[i++] = n % base;
		n /= base;
	}

	for (; i > 0; i--)
    2f00:	be 01       	movw	r22, r28
    2f02:	6f 5f       	subi	r22, 0xFF	; 255
    2f04:	7f 4f       	sbci	r23, 0xFF	; 255
		printByte(buf[i - 1] < 10 ?
    2f06:	d5 01       	movw	r26, r10
    2f08:	c4 01       	movw	r24, r8
    2f0a:	01 97       	sbiw	r24, 0x01	; 1
    2f0c:	a1 09       	sbc	r26, r1
    2f0e:	b1 09       	sbc	r27, r1
    2f10:	ac 01       	movw	r20, r24
    2f12:	48 19       	sub	r20, r8
    2f14:	59 09       	sbc	r21, r9
    2f16:	11 c0       	rjmp	.+34     	; 0x2f3a <printIntegerInBase+0xdc>
    2f18:	fa 01       	movw	r30, r20
    2f1a:	e2 0f       	add	r30, r18
    2f1c:	f3 1f       	adc	r31, r19
    2f1e:	e0 81       	ld	r30, Z
    2f20:	ea 30       	cpi	r30, 0x0A	; 10
    2f22:	10 f4       	brcc	.+4      	; 0x2f28 <printIntegerInBase+0xca>
    2f24:	e0 5d       	subi	r30, 0xD0	; 208
    2f26:	01 c0       	rjmp	.+2      	; 0x2f2a <printIntegerInBase+0xcc>
    2f28:	e9 5c       	subi	r30, 0xC9	; 201

/* writeSerial() - write character to serial port */

void serialWrite(unsigned char c) 
{
	while(!(USARTC0.STATUS & USART_DREIF_bm)); 	// spin until TX data register is available
    2f2a:	80 91 a1 08 	lds	r24, 0x08A1
    2f2e:	85 ff       	sbrs	r24, 5
    2f30:	fc cf       	rjmp	.-8      	; 0x2f2a <printIntegerInBase+0xcc>
	USARTC0.DATA = c;							// write data register
    2f32:	e0 93 a0 08 	sts	0x08A0, r30
    2f36:	21 50       	subi	r18, 0x01	; 1
    2f38:	30 40       	sbci	r19, 0x00	; 0
	while (n > 0) {
		buf[i++] = n % base;
		n /= base;
	}

	for (; i > 0; i--)
    2f3a:	62 17       	cp	r22, r18
    2f3c:	73 07       	cpc	r23, r19
    2f3e:	61 f7       	brne	.-40     	; 0x2f18 <printIntegerInBase+0xba>
		printByte(buf[i - 1] < 10 ?
			'0' + buf[i - 1] :
			'A' + buf[i - 1] - 10);
}
    2f40:	a0 96       	adiw	r28, 0x20	; 32
    2f42:	cd bf       	out	0x3d, r28	; 61
    2f44:	de bf       	out	0x3e, r29	; 62
    2f46:	cf 91       	pop	r28
    2f48:	df 91       	pop	r29
    2f4a:	1f 91       	pop	r17
    2f4c:	0f 91       	pop	r16
    2f4e:	ff 90       	pop	r15
    2f50:	ef 90       	pop	r14
    2f52:	df 90       	pop	r13
    2f54:	cf 90       	pop	r12
    2f56:	bf 90       	pop	r11
    2f58:	af 90       	pop	r10
    2f5a:	9f 90       	pop	r9
    2f5c:	8f 90       	pop	r8
    2f5e:	7f 90       	pop	r7
    2f60:	6f 90       	pop	r6
    2f62:	5f 90       	pop	r5
    2f64:	4f 90       	pop	r4
    2f66:	3f 90       	pop	r3
    2f68:	2f 90       	pop	r2
    2f6a:	08 95       	ret

00002f6c <printInteger>:

/* printInteger() */

void printInteger(long n)
{
    2f6c:	9b 01       	movw	r18, r22
    2f6e:	ac 01       	movw	r20, r24
	if (n < 0) {
    2f70:	97 ff       	sbrs	r25, 7
    2f72:	0e c0       	rjmp	.+28     	; 0x2f90 <printInteger+0x24>

/* writeSerial() - write character to serial port */

void serialWrite(unsigned char c) 
{
	while(!(USARTC0.STATUS & USART_DREIF_bm)); 	// spin until TX data register is available
    2f74:	80 91 a1 08 	lds	r24, 0x08A1
    2f78:	85 ff       	sbrs	r24, 5
    2f7a:	fc cf       	rjmp	.-8      	; 0x2f74 <printInteger+0x8>
	USARTC0.DATA = c;							// write data register
    2f7c:	8d e2       	ldi	r24, 0x2D	; 45
    2f7e:	80 93 a0 08 	sts	0x08A0, r24

void printInteger(long n)
{
	if (n < 0) {
		printByte('-');
		n = -n;
    2f82:	50 95       	com	r21
    2f84:	40 95       	com	r20
    2f86:	30 95       	com	r19
    2f88:	21 95       	neg	r18
    2f8a:	3f 4f       	sbci	r19, 0xFF	; 255
    2f8c:	4f 4f       	sbci	r20, 0xFF	; 255
    2f8e:	5f 4f       	sbci	r21, 0xFF	; 255
	}
	printIntegerInBase(n, 10);
    2f90:	ca 01       	movw	r24, r20
    2f92:	b9 01       	movw	r22, r18
    2f94:	2a e0       	ldi	r18, 0x0A	; 10
    2f96:	30 e0       	ldi	r19, 0x00	; 0
    2f98:	40 e0       	ldi	r20, 0x00	; 0
    2f9a:	50 e0       	ldi	r21, 0x00	; 0
    2f9c:	0e 94 2f 17 	call	0x2e5e	; 0x2e5e <printIntegerInBase>
}
    2fa0:	08 95       	ret

00002fa2 <printHex>:

/* printHex() */

void printHex(unsigned long n)
{
	printIntegerInBase(n, 16);
    2fa2:	20 e1       	ldi	r18, 0x10	; 16
    2fa4:	30 e0       	ldi	r19, 0x00	; 0
    2fa6:	40 e0       	ldi	r20, 0x00	; 0
    2fa8:	50 e0       	ldi	r21, 0x00	; 0
    2faa:	0e 94 2f 17 	call	0x2e5e	; 0x2e5e <printIntegerInBase>
}
    2fae:	08 95       	ret

00002fb0 <printFloat>:
}

/* printFloat() */

void printFloat(double n)
{
    2fb0:	ef 92       	push	r14
    2fb2:	ff 92       	push	r15
    2fb4:	0f 93       	push	r16
    2fb6:	1f 93       	push	r17
    2fb8:	df 93       	push	r29
    2fba:	cf 93       	push	r28
    2fbc:	00 d0       	rcall	.+0      	; 0x2fbe <printFloat+0xe>
    2fbe:	0f 92       	push	r0
    2fc0:	cd b7       	in	r28, 0x3d	; 61
    2fc2:	de b7       	in	r29, 0x3e	; 62
	double integer_part, fractional_part;
	fractional_part = modf(n, &integer_part);
    2fc4:	ae 01       	movw	r20, r28
    2fc6:	4f 5f       	subi	r20, 0xFF	; 255
    2fc8:	5f 4f       	sbci	r21, 0xFF	; 255
    2fca:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <modf>
    2fce:	7b 01       	movw	r14, r22
    2fd0:	8c 01       	movw	r16, r24
	printInteger(integer_part);
    2fd2:	69 81       	ldd	r22, Y+1	; 0x01
    2fd4:	7a 81       	ldd	r23, Y+2	; 0x02
    2fd6:	8b 81       	ldd	r24, Y+3	; 0x03
    2fd8:	9c 81       	ldd	r25, Y+4	; 0x04
    2fda:	0e 94 1f 19 	call	0x323e	; 0x323e <__fixsfsi>
    2fde:	0e 94 b6 17 	call	0x2f6c	; 0x2f6c <printInteger>

/* writeSerial() - write character to serial port */

void serialWrite(unsigned char c) 
{
	while(!(USARTC0.STATUS & USART_DREIF_bm)); 	// spin until TX data register is available
    2fe2:	80 91 a1 08 	lds	r24, 0x08A1
    2fe6:	85 ff       	sbrs	r24, 5
    2fe8:	fc cf       	rjmp	.-8      	; 0x2fe2 <printFloat+0x32>
	USARTC0.DATA = c;							// write data register
    2fea:	8e e2       	ldi	r24, 0x2E	; 46
    2fec:	80 93 a0 08 	sts	0x08A0, r24
{
	double integer_part, fractional_part;
	fractional_part = modf(n, &integer_part);
	printInteger(integer_part);
	printByte('.');
	printInteger(round(fractional_part*1000));
    2ff0:	c8 01       	movw	r24, r16
    2ff2:	b7 01       	movw	r22, r14
    2ff4:	20 e0       	ldi	r18, 0x00	; 0
    2ff6:	30 e0       	ldi	r19, 0x00	; 0
    2ff8:	4a e7       	ldi	r20, 0x7A	; 122
    2ffa:	54 e4       	ldi	r21, 0x44	; 68
    2ffc:	0e 94 a5 1b 	call	0x374a	; 0x374a <__mulsf3>
    3000:	0e 94 08 1c 	call	0x3810	; 0x3810 <round>
    3004:	0e 94 1f 19 	call	0x323e	; 0x323e <__fixsfsi>
    3008:	0e 94 b6 17 	call	0x2f6c	; 0x2f6c <printInteger>
}
    300c:	24 96       	adiw	r28, 0x04	; 4
    300e:	cd bf       	out	0x3d, r28	; 61
    3010:	de bf       	out	0x3e, r29	; 62
    3012:	cf 91       	pop	r28
    3014:	df 91       	pop	r29
    3016:	1f 91       	pop	r17
    3018:	0f 91       	pop	r16
    301a:	ff 90       	pop	r15
    301c:	ef 90       	pop	r14
    301e:	08 95       	ret

00003020 <__subsf3>:
    3020:	50 58       	subi	r21, 0x80	; 128

00003022 <__addsf3>:
    3022:	bb 27       	eor	r27, r27
    3024:	aa 27       	eor	r26, r26
    3026:	0e d0       	rcall	.+28     	; 0x3044 <__addsf3x>
    3028:	29 c2       	rjmp	.+1106   	; 0x347c <__fp_round>
    302a:	f2 d1       	rcall	.+996    	; 0x3410 <__fp_pscA>
    302c:	30 f0       	brcs	.+12     	; 0x303a <__addsf3+0x18>
    302e:	f7 d1       	rcall	.+1006   	; 0x341e <__fp_pscB>
    3030:	20 f0       	brcs	.+8      	; 0x303a <__addsf3+0x18>
    3032:	31 f4       	brne	.+12     	; 0x3040 <__addsf3+0x1e>
    3034:	9f 3f       	cpi	r25, 0xFF	; 255
    3036:	11 f4       	brne	.+4      	; 0x303c <__addsf3+0x1a>
    3038:	1e f4       	brtc	.+6      	; 0x3040 <__addsf3+0x1e>
    303a:	c2 c1       	rjmp	.+900    	; 0x33c0 <__fp_nan>
    303c:	0e f4       	brtc	.+2      	; 0x3040 <__addsf3+0x1e>
    303e:	e0 95       	com	r30
    3040:	e7 fb       	bst	r30, 7
    3042:	8f c1       	rjmp	.+798    	; 0x3362 <__fp_inf>

00003044 <__addsf3x>:
    3044:	e9 2f       	mov	r30, r25
    3046:	3c d2       	rcall	.+1144   	; 0x34c0 <__fp_split3>
    3048:	80 f3       	brcs	.-32     	; 0x302a <__addsf3+0x8>
    304a:	ba 17       	cp	r27, r26
    304c:	62 07       	cpc	r22, r18
    304e:	73 07       	cpc	r23, r19
    3050:	84 07       	cpc	r24, r20
    3052:	95 07       	cpc	r25, r21
    3054:	18 f0       	brcs	.+6      	; 0x305c <__addsf3x+0x18>
    3056:	71 f4       	brne	.+28     	; 0x3074 <__addsf3x+0x30>
    3058:	9e f5       	brtc	.+102    	; 0x30c0 <__addsf3x+0x7c>
    305a:	6b c2       	rjmp	.+1238   	; 0x3532 <__fp_zero>
    305c:	0e f4       	brtc	.+2      	; 0x3060 <__addsf3x+0x1c>
    305e:	e0 95       	com	r30
    3060:	0b 2e       	mov	r0, r27
    3062:	ba 2f       	mov	r27, r26
    3064:	a0 2d       	mov	r26, r0
    3066:	0b 01       	movw	r0, r22
    3068:	b9 01       	movw	r22, r18
    306a:	90 01       	movw	r18, r0
    306c:	0c 01       	movw	r0, r24
    306e:	ca 01       	movw	r24, r20
    3070:	a0 01       	movw	r20, r0
    3072:	11 24       	eor	r1, r1
    3074:	ff 27       	eor	r31, r31
    3076:	59 1b       	sub	r21, r25
    3078:	99 f0       	breq	.+38     	; 0x30a0 <__addsf3x+0x5c>
    307a:	59 3f       	cpi	r21, 0xF9	; 249
    307c:	50 f4       	brcc	.+20     	; 0x3092 <__addsf3x+0x4e>
    307e:	50 3e       	cpi	r21, 0xE0	; 224
    3080:	68 f1       	brcs	.+90     	; 0x30dc <__addsf3x+0x98>
    3082:	1a 16       	cp	r1, r26
    3084:	f0 40       	sbci	r31, 0x00	; 0
    3086:	a2 2f       	mov	r26, r18
    3088:	23 2f       	mov	r18, r19
    308a:	34 2f       	mov	r19, r20
    308c:	44 27       	eor	r20, r20
    308e:	58 5f       	subi	r21, 0xF8	; 248
    3090:	f3 cf       	rjmp	.-26     	; 0x3078 <__addsf3x+0x34>
    3092:	46 95       	lsr	r20
    3094:	37 95       	ror	r19
    3096:	27 95       	ror	r18
    3098:	a7 95       	ror	r26
    309a:	f0 40       	sbci	r31, 0x00	; 0
    309c:	53 95       	inc	r21
    309e:	c9 f7       	brne	.-14     	; 0x3092 <__addsf3x+0x4e>
    30a0:	7e f4       	brtc	.+30     	; 0x30c0 <__addsf3x+0x7c>
    30a2:	1f 16       	cp	r1, r31
    30a4:	ba 0b       	sbc	r27, r26
    30a6:	62 0b       	sbc	r22, r18
    30a8:	73 0b       	sbc	r23, r19
    30aa:	84 0b       	sbc	r24, r20
    30ac:	ba f0       	brmi	.+46     	; 0x30dc <__addsf3x+0x98>
    30ae:	91 50       	subi	r25, 0x01	; 1
    30b0:	a1 f0       	breq	.+40     	; 0x30da <__addsf3x+0x96>
    30b2:	ff 0f       	add	r31, r31
    30b4:	bb 1f       	adc	r27, r27
    30b6:	66 1f       	adc	r22, r22
    30b8:	77 1f       	adc	r23, r23
    30ba:	88 1f       	adc	r24, r24
    30bc:	c2 f7       	brpl	.-16     	; 0x30ae <__addsf3x+0x6a>
    30be:	0e c0       	rjmp	.+28     	; 0x30dc <__addsf3x+0x98>
    30c0:	ba 0f       	add	r27, r26
    30c2:	62 1f       	adc	r22, r18
    30c4:	73 1f       	adc	r23, r19
    30c6:	84 1f       	adc	r24, r20
    30c8:	48 f4       	brcc	.+18     	; 0x30dc <__addsf3x+0x98>
    30ca:	87 95       	ror	r24
    30cc:	77 95       	ror	r23
    30ce:	67 95       	ror	r22
    30d0:	b7 95       	ror	r27
    30d2:	f7 95       	ror	r31
    30d4:	9e 3f       	cpi	r25, 0xFE	; 254
    30d6:	08 f0       	brcs	.+2      	; 0x30da <__addsf3x+0x96>
    30d8:	b3 cf       	rjmp	.-154    	; 0x3040 <__addsf3+0x1e>
    30da:	93 95       	inc	r25
    30dc:	88 0f       	add	r24, r24
    30de:	08 f0       	brcs	.+2      	; 0x30e2 <__addsf3x+0x9e>
    30e0:	99 27       	eor	r25, r25
    30e2:	ee 0f       	add	r30, r30
    30e4:	97 95       	ror	r25
    30e6:	87 95       	ror	r24
    30e8:	08 95       	ret

000030ea <atan>:
    30ea:	df 93       	push	r29
    30ec:	dd 27       	eor	r29, r29
    30ee:	b9 2f       	mov	r27, r25
    30f0:	bf 77       	andi	r27, 0x7F	; 127
    30f2:	40 e8       	ldi	r20, 0x80	; 128
    30f4:	5f e3       	ldi	r21, 0x3F	; 63
    30f6:	16 16       	cp	r1, r22
    30f8:	17 06       	cpc	r1, r23
    30fa:	48 07       	cpc	r20, r24
    30fc:	5b 07       	cpc	r21, r27
    30fe:	10 f4       	brcc	.+4      	; 0x3104 <atan+0x1a>
    3100:	d9 2f       	mov	r29, r25
    3102:	83 d2       	rcall	.+1286   	; 0x360a <inverse>
    3104:	9f 93       	push	r25
    3106:	8f 93       	push	r24
    3108:	7f 93       	push	r23
    310a:	6f 93       	push	r22
    310c:	e9 d3       	rcall	.+2002   	; 0x38e0 <square>
    310e:	e8 ee       	ldi	r30, 0xE8	; 232
    3110:	f1 e0       	ldi	r31, 0x01	; 1
    3112:	59 d1       	rcall	.+690    	; 0x33c6 <__fp_powser>
    3114:	b3 d1       	rcall	.+870    	; 0x347c <__fp_round>
    3116:	2f 91       	pop	r18
    3118:	3f 91       	pop	r19
    311a:	4f 91       	pop	r20
    311c:	5f 91       	pop	r21
    311e:	21 d3       	rcall	.+1602   	; 0x3762 <__mulsf3x>
    3120:	dd 23       	and	r29, r29
    3122:	49 f0       	breq	.+18     	; 0x3136 <atan+0x4c>
    3124:	90 58       	subi	r25, 0x80	; 128
    3126:	a2 ea       	ldi	r26, 0xA2	; 162
    3128:	2a ed       	ldi	r18, 0xDA	; 218
    312a:	3f e0       	ldi	r19, 0x0F	; 15
    312c:	49 ec       	ldi	r20, 0xC9	; 201
    312e:	5f e3       	ldi	r21, 0x3F	; 63
    3130:	d0 78       	andi	r29, 0x80	; 128
    3132:	5d 27       	eor	r21, r29
    3134:	87 df       	rcall	.-242    	; 0x3044 <__addsf3x>
    3136:	df 91       	pop	r29
    3138:	a1 c1       	rjmp	.+834    	; 0x347c <__fp_round>

0000313a <ceil>:
    313a:	e4 d1       	rcall	.+968    	; 0x3504 <__fp_trunc>
    313c:	80 f0       	brcs	.+32     	; 0x315e <ceil+0x24>
    313e:	9f 37       	cpi	r25, 0x7F	; 127
    3140:	40 f4       	brcc	.+16     	; 0x3152 <ceil+0x18>
    3142:	91 11       	cpse	r25, r1
    3144:	0e f4       	brtc	.+2      	; 0x3148 <ceil+0xe>
    3146:	f6 c1       	rjmp	.+1004   	; 0x3534 <__fp_szero>
    3148:	60 e0       	ldi	r22, 0x00	; 0
    314a:	70 e0       	ldi	r23, 0x00	; 0
    314c:	80 e8       	ldi	r24, 0x80	; 128
    314e:	9f e3       	ldi	r25, 0x3F	; 63
    3150:	08 95       	ret
    3152:	26 f0       	brts	.+8      	; 0x315c <ceil+0x22>
    3154:	1b 16       	cp	r1, r27
    3156:	61 1d       	adc	r22, r1
    3158:	71 1d       	adc	r23, r1
    315a:	81 1d       	adc	r24, r1
    315c:	08 c1       	rjmp	.+528    	; 0x336e <__fp_mintl>
    315e:	22 c1       	rjmp	.+580    	; 0x33a4 <__fp_mpack>

00003160 <__cmpsf2>:
    3160:	dc d0       	rcall	.+440    	; 0x331a <__fp_cmp>
    3162:	08 f4       	brcc	.+2      	; 0x3166 <__cmpsf2+0x6>
    3164:	81 e0       	ldi	r24, 0x01	; 1
    3166:	08 95       	ret

00003168 <cos>:
    3168:	62 d1       	rcall	.+708    	; 0x342e <__fp_rempio2>
    316a:	e3 95       	inc	r30
    316c:	98 c1       	rjmp	.+816    	; 0x349e <__fp_sinus>

0000316e <__divsf3>:
    316e:	0c d0       	rcall	.+24     	; 0x3188 <__divsf3x>
    3170:	85 c1       	rjmp	.+778    	; 0x347c <__fp_round>
    3172:	55 d1       	rcall	.+682    	; 0x341e <__fp_pscB>
    3174:	40 f0       	brcs	.+16     	; 0x3186 <__divsf3+0x18>
    3176:	4c d1       	rcall	.+664    	; 0x3410 <__fp_pscA>
    3178:	30 f0       	brcs	.+12     	; 0x3186 <__divsf3+0x18>
    317a:	21 f4       	brne	.+8      	; 0x3184 <__divsf3+0x16>
    317c:	5f 3f       	cpi	r21, 0xFF	; 255
    317e:	19 f0       	breq	.+6      	; 0x3186 <__divsf3+0x18>
    3180:	f0 c0       	rjmp	.+480    	; 0x3362 <__fp_inf>
    3182:	51 11       	cpse	r21, r1
    3184:	d7 c1       	rjmp	.+942    	; 0x3534 <__fp_szero>
    3186:	1c c1       	rjmp	.+568    	; 0x33c0 <__fp_nan>

00003188 <__divsf3x>:
    3188:	9b d1       	rcall	.+822    	; 0x34c0 <__fp_split3>
    318a:	98 f3       	brcs	.-26     	; 0x3172 <__divsf3+0x4>

0000318c <__divsf3_pse>:
    318c:	99 23       	and	r25, r25
    318e:	c9 f3       	breq	.-14     	; 0x3182 <__divsf3+0x14>
    3190:	55 23       	and	r21, r21
    3192:	b1 f3       	breq	.-20     	; 0x3180 <__divsf3+0x12>
    3194:	95 1b       	sub	r25, r21
    3196:	55 0b       	sbc	r21, r21
    3198:	bb 27       	eor	r27, r27
    319a:	aa 27       	eor	r26, r26
    319c:	62 17       	cp	r22, r18
    319e:	73 07       	cpc	r23, r19
    31a0:	84 07       	cpc	r24, r20
    31a2:	38 f0       	brcs	.+14     	; 0x31b2 <__divsf3_pse+0x26>
    31a4:	9f 5f       	subi	r25, 0xFF	; 255
    31a6:	5f 4f       	sbci	r21, 0xFF	; 255
    31a8:	22 0f       	add	r18, r18
    31aa:	33 1f       	adc	r19, r19
    31ac:	44 1f       	adc	r20, r20
    31ae:	aa 1f       	adc	r26, r26
    31b0:	a9 f3       	breq	.-22     	; 0x319c <__divsf3_pse+0x10>
    31b2:	33 d0       	rcall	.+102    	; 0x321a <__divsf3_pse+0x8e>
    31b4:	0e 2e       	mov	r0, r30
    31b6:	3a f0       	brmi	.+14     	; 0x31c6 <__divsf3_pse+0x3a>
    31b8:	e0 e8       	ldi	r30, 0x80	; 128
    31ba:	30 d0       	rcall	.+96     	; 0x321c <__divsf3_pse+0x90>
    31bc:	91 50       	subi	r25, 0x01	; 1
    31be:	50 40       	sbci	r21, 0x00	; 0
    31c0:	e6 95       	lsr	r30
    31c2:	00 1c       	adc	r0, r0
    31c4:	ca f7       	brpl	.-14     	; 0x31b8 <__divsf3_pse+0x2c>
    31c6:	29 d0       	rcall	.+82     	; 0x321a <__divsf3_pse+0x8e>
    31c8:	fe 2f       	mov	r31, r30
    31ca:	27 d0       	rcall	.+78     	; 0x321a <__divsf3_pse+0x8e>
    31cc:	66 0f       	add	r22, r22
    31ce:	77 1f       	adc	r23, r23
    31d0:	88 1f       	adc	r24, r24
    31d2:	bb 1f       	adc	r27, r27
    31d4:	26 17       	cp	r18, r22
    31d6:	37 07       	cpc	r19, r23
    31d8:	48 07       	cpc	r20, r24
    31da:	ab 07       	cpc	r26, r27
    31dc:	b0 e8       	ldi	r27, 0x80	; 128
    31de:	09 f0       	breq	.+2      	; 0x31e2 <__divsf3_pse+0x56>
    31e0:	bb 0b       	sbc	r27, r27
    31e2:	80 2d       	mov	r24, r0
    31e4:	bf 01       	movw	r22, r30
    31e6:	ff 27       	eor	r31, r31
    31e8:	93 58       	subi	r25, 0x83	; 131
    31ea:	5f 4f       	sbci	r21, 0xFF	; 255
    31ec:	2a f0       	brmi	.+10     	; 0x31f8 <__divsf3_pse+0x6c>
    31ee:	9e 3f       	cpi	r25, 0xFE	; 254
    31f0:	51 05       	cpc	r21, r1
    31f2:	68 f0       	brcs	.+26     	; 0x320e <__divsf3_pse+0x82>
    31f4:	b6 c0       	rjmp	.+364    	; 0x3362 <__fp_inf>
    31f6:	9e c1       	rjmp	.+828    	; 0x3534 <__fp_szero>
    31f8:	5f 3f       	cpi	r21, 0xFF	; 255
    31fa:	ec f3       	brlt	.-6      	; 0x31f6 <__divsf3_pse+0x6a>
    31fc:	98 3e       	cpi	r25, 0xE8	; 232
    31fe:	dc f3       	brlt	.-10     	; 0x31f6 <__divsf3_pse+0x6a>
    3200:	86 95       	lsr	r24
    3202:	77 95       	ror	r23
    3204:	67 95       	ror	r22
    3206:	b7 95       	ror	r27
    3208:	f7 95       	ror	r31
    320a:	9f 5f       	subi	r25, 0xFF	; 255
    320c:	c9 f7       	brne	.-14     	; 0x3200 <__divsf3_pse+0x74>
    320e:	88 0f       	add	r24, r24
    3210:	91 1d       	adc	r25, r1
    3212:	96 95       	lsr	r25
    3214:	87 95       	ror	r24
    3216:	97 f9       	bld	r25, 7
    3218:	08 95       	ret
    321a:	e1 e0       	ldi	r30, 0x01	; 1
    321c:	66 0f       	add	r22, r22
    321e:	77 1f       	adc	r23, r23
    3220:	88 1f       	adc	r24, r24
    3222:	bb 1f       	adc	r27, r27
    3224:	62 17       	cp	r22, r18
    3226:	73 07       	cpc	r23, r19
    3228:	84 07       	cpc	r24, r20
    322a:	ba 07       	cpc	r27, r26
    322c:	20 f0       	brcs	.+8      	; 0x3236 <__divsf3_pse+0xaa>
    322e:	62 1b       	sub	r22, r18
    3230:	73 0b       	sbc	r23, r19
    3232:	84 0b       	sbc	r24, r20
    3234:	ba 0b       	sbc	r27, r26
    3236:	ee 1f       	adc	r30, r30
    3238:	88 f7       	brcc	.-30     	; 0x321c <__divsf3_pse+0x90>
    323a:	e0 95       	com	r30
    323c:	08 95       	ret

0000323e <__fixsfsi>:
    323e:	04 d0       	rcall	.+8      	; 0x3248 <__fixunssfsi>
    3240:	68 94       	set
    3242:	b1 11       	cpse	r27, r1
    3244:	77 c1       	rjmp	.+750    	; 0x3534 <__fp_szero>
    3246:	08 95       	ret

00003248 <__fixunssfsi>:
    3248:	43 d1       	rcall	.+646    	; 0x34d0 <__fp_splitA>
    324a:	88 f0       	brcs	.+34     	; 0x326e <__fixunssfsi+0x26>
    324c:	9f 57       	subi	r25, 0x7F	; 127
    324e:	90 f0       	brcs	.+36     	; 0x3274 <__fixunssfsi+0x2c>
    3250:	b9 2f       	mov	r27, r25
    3252:	99 27       	eor	r25, r25
    3254:	b7 51       	subi	r27, 0x17	; 23
    3256:	a0 f0       	brcs	.+40     	; 0x3280 <__fixunssfsi+0x38>
    3258:	d1 f0       	breq	.+52     	; 0x328e <__fixunssfsi+0x46>
    325a:	66 0f       	add	r22, r22
    325c:	77 1f       	adc	r23, r23
    325e:	88 1f       	adc	r24, r24
    3260:	99 1f       	adc	r25, r25
    3262:	1a f0       	brmi	.+6      	; 0x326a <__fixunssfsi+0x22>
    3264:	ba 95       	dec	r27
    3266:	c9 f7       	brne	.-14     	; 0x325a <__fixunssfsi+0x12>
    3268:	12 c0       	rjmp	.+36     	; 0x328e <__fixunssfsi+0x46>
    326a:	b1 30       	cpi	r27, 0x01	; 1
    326c:	81 f0       	breq	.+32     	; 0x328e <__fixunssfsi+0x46>
    326e:	61 d1       	rcall	.+706    	; 0x3532 <__fp_zero>
    3270:	b1 e0       	ldi	r27, 0x01	; 1
    3272:	08 95       	ret
    3274:	5e c1       	rjmp	.+700    	; 0x3532 <__fp_zero>
    3276:	67 2f       	mov	r22, r23
    3278:	78 2f       	mov	r23, r24
    327a:	88 27       	eor	r24, r24
    327c:	b8 5f       	subi	r27, 0xF8	; 248
    327e:	39 f0       	breq	.+14     	; 0x328e <__fixunssfsi+0x46>
    3280:	b9 3f       	cpi	r27, 0xF9	; 249
    3282:	cc f3       	brlt	.-14     	; 0x3276 <__fixunssfsi+0x2e>
    3284:	86 95       	lsr	r24
    3286:	77 95       	ror	r23
    3288:	67 95       	ror	r22
    328a:	b3 95       	inc	r27
    328c:	d9 f7       	brne	.-10     	; 0x3284 <__fixunssfsi+0x3c>
    328e:	3e f4       	brtc	.+14     	; 0x329e <__fixunssfsi+0x56>
    3290:	90 95       	com	r25
    3292:	80 95       	com	r24
    3294:	70 95       	com	r23
    3296:	61 95       	neg	r22
    3298:	7f 4f       	sbci	r23, 0xFF	; 255
    329a:	8f 4f       	sbci	r24, 0xFF	; 255
    329c:	9f 4f       	sbci	r25, 0xFF	; 255
    329e:	08 95       	ret

000032a0 <__floatunsisf>:
    32a0:	e8 94       	clt
    32a2:	09 c0       	rjmp	.+18     	; 0x32b6 <__floatsisf+0x12>

000032a4 <__floatsisf>:
    32a4:	97 fb       	bst	r25, 7
    32a6:	3e f4       	brtc	.+14     	; 0x32b6 <__floatsisf+0x12>
    32a8:	90 95       	com	r25
    32aa:	80 95       	com	r24
    32ac:	70 95       	com	r23
    32ae:	61 95       	neg	r22
    32b0:	7f 4f       	sbci	r23, 0xFF	; 255
    32b2:	8f 4f       	sbci	r24, 0xFF	; 255
    32b4:	9f 4f       	sbci	r25, 0xFF	; 255
    32b6:	99 23       	and	r25, r25
    32b8:	a9 f0       	breq	.+42     	; 0x32e4 <__floatsisf+0x40>
    32ba:	f9 2f       	mov	r31, r25
    32bc:	96 e9       	ldi	r25, 0x96	; 150
    32be:	bb 27       	eor	r27, r27
    32c0:	93 95       	inc	r25
    32c2:	f6 95       	lsr	r31
    32c4:	87 95       	ror	r24
    32c6:	77 95       	ror	r23
    32c8:	67 95       	ror	r22
    32ca:	b7 95       	ror	r27
    32cc:	f1 11       	cpse	r31, r1
    32ce:	f8 cf       	rjmp	.-16     	; 0x32c0 <__floatsisf+0x1c>
    32d0:	fa f4       	brpl	.+62     	; 0x3310 <__floatsisf+0x6c>
    32d2:	bb 0f       	add	r27, r27
    32d4:	11 f4       	brne	.+4      	; 0x32da <__floatsisf+0x36>
    32d6:	60 ff       	sbrs	r22, 0
    32d8:	1b c0       	rjmp	.+54     	; 0x3310 <__floatsisf+0x6c>
    32da:	6f 5f       	subi	r22, 0xFF	; 255
    32dc:	7f 4f       	sbci	r23, 0xFF	; 255
    32de:	8f 4f       	sbci	r24, 0xFF	; 255
    32e0:	9f 4f       	sbci	r25, 0xFF	; 255
    32e2:	16 c0       	rjmp	.+44     	; 0x3310 <__floatsisf+0x6c>
    32e4:	88 23       	and	r24, r24
    32e6:	11 f0       	breq	.+4      	; 0x32ec <__floatsisf+0x48>
    32e8:	96 e9       	ldi	r25, 0x96	; 150
    32ea:	11 c0       	rjmp	.+34     	; 0x330e <__floatsisf+0x6a>
    32ec:	77 23       	and	r23, r23
    32ee:	21 f0       	breq	.+8      	; 0x32f8 <__floatsisf+0x54>
    32f0:	9e e8       	ldi	r25, 0x8E	; 142
    32f2:	87 2f       	mov	r24, r23
    32f4:	76 2f       	mov	r23, r22
    32f6:	05 c0       	rjmp	.+10     	; 0x3302 <__floatsisf+0x5e>
    32f8:	66 23       	and	r22, r22
    32fa:	71 f0       	breq	.+28     	; 0x3318 <__floatsisf+0x74>
    32fc:	96 e8       	ldi	r25, 0x86	; 134
    32fe:	86 2f       	mov	r24, r22
    3300:	70 e0       	ldi	r23, 0x00	; 0
    3302:	60 e0       	ldi	r22, 0x00	; 0
    3304:	2a f0       	brmi	.+10     	; 0x3310 <__floatsisf+0x6c>
    3306:	9a 95       	dec	r25
    3308:	66 0f       	add	r22, r22
    330a:	77 1f       	adc	r23, r23
    330c:	88 1f       	adc	r24, r24
    330e:	da f7       	brpl	.-10     	; 0x3306 <__floatsisf+0x62>
    3310:	88 0f       	add	r24, r24
    3312:	96 95       	lsr	r25
    3314:	87 95       	ror	r24
    3316:	97 f9       	bld	r25, 7
    3318:	08 95       	ret

0000331a <__fp_cmp>:
    331a:	99 0f       	add	r25, r25
    331c:	00 08       	sbc	r0, r0
    331e:	55 0f       	add	r21, r21
    3320:	aa 0b       	sbc	r26, r26
    3322:	e0 e8       	ldi	r30, 0x80	; 128
    3324:	fe ef       	ldi	r31, 0xFE	; 254
    3326:	16 16       	cp	r1, r22
    3328:	17 06       	cpc	r1, r23
    332a:	e8 07       	cpc	r30, r24
    332c:	f9 07       	cpc	r31, r25
    332e:	c0 f0       	brcs	.+48     	; 0x3360 <__fp_cmp+0x46>
    3330:	12 16       	cp	r1, r18
    3332:	13 06       	cpc	r1, r19
    3334:	e4 07       	cpc	r30, r20
    3336:	f5 07       	cpc	r31, r21
    3338:	98 f0       	brcs	.+38     	; 0x3360 <__fp_cmp+0x46>
    333a:	62 1b       	sub	r22, r18
    333c:	73 0b       	sbc	r23, r19
    333e:	84 0b       	sbc	r24, r20
    3340:	95 0b       	sbc	r25, r21
    3342:	39 f4       	brne	.+14     	; 0x3352 <__fp_cmp+0x38>
    3344:	0a 26       	eor	r0, r26
    3346:	61 f0       	breq	.+24     	; 0x3360 <__fp_cmp+0x46>
    3348:	23 2b       	or	r18, r19
    334a:	24 2b       	or	r18, r20
    334c:	25 2b       	or	r18, r21
    334e:	21 f4       	brne	.+8      	; 0x3358 <__fp_cmp+0x3e>
    3350:	08 95       	ret
    3352:	0a 26       	eor	r0, r26
    3354:	09 f4       	brne	.+2      	; 0x3358 <__fp_cmp+0x3e>
    3356:	a1 40       	sbci	r26, 0x01	; 1
    3358:	a6 95       	lsr	r26
    335a:	8f ef       	ldi	r24, 0xFF	; 255
    335c:	81 1d       	adc	r24, r1
    335e:	81 1d       	adc	r24, r1
    3360:	08 95       	ret

00003362 <__fp_inf>:
    3362:	97 f9       	bld	r25, 7
    3364:	9f 67       	ori	r25, 0x7F	; 127
    3366:	80 e8       	ldi	r24, 0x80	; 128
    3368:	70 e0       	ldi	r23, 0x00	; 0
    336a:	60 e0       	ldi	r22, 0x00	; 0
    336c:	08 95       	ret

0000336e <__fp_mintl>:
    336e:	88 23       	and	r24, r24
    3370:	71 f4       	brne	.+28     	; 0x338e <__fp_mintl+0x20>
    3372:	77 23       	and	r23, r23
    3374:	21 f0       	breq	.+8      	; 0x337e <__fp_mintl+0x10>
    3376:	98 50       	subi	r25, 0x08	; 8
    3378:	87 2b       	or	r24, r23
    337a:	76 2f       	mov	r23, r22
    337c:	07 c0       	rjmp	.+14     	; 0x338c <__fp_mintl+0x1e>
    337e:	66 23       	and	r22, r22
    3380:	11 f4       	brne	.+4      	; 0x3386 <__fp_mintl+0x18>
    3382:	99 27       	eor	r25, r25
    3384:	0d c0       	rjmp	.+26     	; 0x33a0 <__fp_mintl+0x32>
    3386:	90 51       	subi	r25, 0x10	; 16
    3388:	86 2b       	or	r24, r22
    338a:	70 e0       	ldi	r23, 0x00	; 0
    338c:	60 e0       	ldi	r22, 0x00	; 0
    338e:	2a f0       	brmi	.+10     	; 0x339a <__fp_mintl+0x2c>
    3390:	9a 95       	dec	r25
    3392:	66 0f       	add	r22, r22
    3394:	77 1f       	adc	r23, r23
    3396:	88 1f       	adc	r24, r24
    3398:	da f7       	brpl	.-10     	; 0x3390 <__fp_mintl+0x22>
    339a:	88 0f       	add	r24, r24
    339c:	96 95       	lsr	r25
    339e:	87 95       	ror	r24
    33a0:	97 f9       	bld	r25, 7
    33a2:	08 95       	ret

000033a4 <__fp_mpack>:
    33a4:	9f 3f       	cpi	r25, 0xFF	; 255
    33a6:	31 f0       	breq	.+12     	; 0x33b4 <__fp_mpack_finite+0xc>

000033a8 <__fp_mpack_finite>:
    33a8:	91 50       	subi	r25, 0x01	; 1
    33aa:	20 f4       	brcc	.+8      	; 0x33b4 <__fp_mpack_finite+0xc>
    33ac:	87 95       	ror	r24
    33ae:	77 95       	ror	r23
    33b0:	67 95       	ror	r22
    33b2:	b7 95       	ror	r27
    33b4:	88 0f       	add	r24, r24
    33b6:	91 1d       	adc	r25, r1
    33b8:	96 95       	lsr	r25
    33ba:	87 95       	ror	r24
    33bc:	97 f9       	bld	r25, 7
    33be:	08 95       	ret

000033c0 <__fp_nan>:
    33c0:	9f ef       	ldi	r25, 0xFF	; 255
    33c2:	80 ec       	ldi	r24, 0xC0	; 192
    33c4:	08 95       	ret

000033c6 <__fp_powser>:
    33c6:	df 93       	push	r29
    33c8:	cf 93       	push	r28
    33ca:	1f 93       	push	r17
    33cc:	0f 93       	push	r16
    33ce:	ff 92       	push	r15
    33d0:	ef 92       	push	r14
    33d2:	df 92       	push	r13
    33d4:	7b 01       	movw	r14, r22
    33d6:	8c 01       	movw	r16, r24
    33d8:	68 94       	set
    33da:	05 c0       	rjmp	.+10     	; 0x33e6 <__fp_powser+0x20>
    33dc:	da 2e       	mov	r13, r26
    33de:	ef 01       	movw	r28, r30
    33e0:	c0 d1       	rcall	.+896    	; 0x3762 <__mulsf3x>
    33e2:	fe 01       	movw	r30, r28
    33e4:	e8 94       	clt
    33e6:	a5 91       	lpm	r26, Z+
    33e8:	25 91       	lpm	r18, Z+
    33ea:	35 91       	lpm	r19, Z+
    33ec:	45 91       	lpm	r20, Z+
    33ee:	55 91       	lpm	r21, Z+
    33f0:	ae f3       	brts	.-22     	; 0x33dc <__fp_powser+0x16>
    33f2:	ef 01       	movw	r28, r30
    33f4:	27 de       	rcall	.-946    	; 0x3044 <__addsf3x>
    33f6:	fe 01       	movw	r30, r28
    33f8:	97 01       	movw	r18, r14
    33fa:	a8 01       	movw	r20, r16
    33fc:	da 94       	dec	r13
    33fe:	79 f7       	brne	.-34     	; 0x33de <__fp_powser+0x18>
    3400:	df 90       	pop	r13
    3402:	ef 90       	pop	r14
    3404:	ff 90       	pop	r15
    3406:	0f 91       	pop	r16
    3408:	1f 91       	pop	r17
    340a:	cf 91       	pop	r28
    340c:	df 91       	pop	r29
    340e:	08 95       	ret

00003410 <__fp_pscA>:
    3410:	00 24       	eor	r0, r0
    3412:	0a 94       	dec	r0
    3414:	16 16       	cp	r1, r22
    3416:	17 06       	cpc	r1, r23
    3418:	18 06       	cpc	r1, r24
    341a:	09 06       	cpc	r0, r25
    341c:	08 95       	ret

0000341e <__fp_pscB>:
    341e:	00 24       	eor	r0, r0
    3420:	0a 94       	dec	r0
    3422:	12 16       	cp	r1, r18
    3424:	13 06       	cpc	r1, r19
    3426:	14 06       	cpc	r1, r20
    3428:	05 06       	cpc	r0, r21
    342a:	08 95       	ret
    342c:	c9 cf       	rjmp	.-110    	; 0x33c0 <__fp_nan>

0000342e <__fp_rempio2>:
    342e:	50 d0       	rcall	.+160    	; 0x34d0 <__fp_splitA>
    3430:	e8 f3       	brcs	.-6      	; 0x342c <__fp_pscB+0xe>
    3432:	e8 94       	clt
    3434:	e0 e0       	ldi	r30, 0x00	; 0
    3436:	bb 27       	eor	r27, r27
    3438:	9f 57       	subi	r25, 0x7F	; 127
    343a:	f0 f0       	brcs	.+60     	; 0x3478 <__fp_rempio2+0x4a>
    343c:	2a ed       	ldi	r18, 0xDA	; 218
    343e:	3f e0       	ldi	r19, 0x0F	; 15
    3440:	49 ec       	ldi	r20, 0xC9	; 201
    3442:	06 c0       	rjmp	.+12     	; 0x3450 <__fp_rempio2+0x22>
    3444:	ee 0f       	add	r30, r30
    3446:	bb 0f       	add	r27, r27
    3448:	66 1f       	adc	r22, r22
    344a:	77 1f       	adc	r23, r23
    344c:	88 1f       	adc	r24, r24
    344e:	28 f0       	brcs	.+10     	; 0x345a <__fp_rempio2+0x2c>
    3450:	b2 3a       	cpi	r27, 0xA2	; 162
    3452:	62 07       	cpc	r22, r18
    3454:	73 07       	cpc	r23, r19
    3456:	84 07       	cpc	r24, r20
    3458:	28 f0       	brcs	.+10     	; 0x3464 <__fp_rempio2+0x36>
    345a:	b2 5a       	subi	r27, 0xA2	; 162
    345c:	62 0b       	sbc	r22, r18
    345e:	73 0b       	sbc	r23, r19
    3460:	84 0b       	sbc	r24, r20
    3462:	e3 95       	inc	r30
    3464:	9a 95       	dec	r25
    3466:	72 f7       	brpl	.-36     	; 0x3444 <__fp_rempio2+0x16>
    3468:	80 38       	cpi	r24, 0x80	; 128
    346a:	30 f4       	brcc	.+12     	; 0x3478 <__fp_rempio2+0x4a>
    346c:	9a 95       	dec	r25
    346e:	bb 0f       	add	r27, r27
    3470:	66 1f       	adc	r22, r22
    3472:	77 1f       	adc	r23, r23
    3474:	88 1f       	adc	r24, r24
    3476:	d2 f7       	brpl	.-12     	; 0x346c <__fp_rempio2+0x3e>
    3478:	90 48       	sbci	r25, 0x80	; 128
    347a:	96 cf       	rjmp	.-212    	; 0x33a8 <__fp_mpack_finite>

0000347c <__fp_round>:
    347c:	09 2e       	mov	r0, r25
    347e:	03 94       	inc	r0
    3480:	00 0c       	add	r0, r0
    3482:	11 f4       	brne	.+4      	; 0x3488 <__fp_round+0xc>
    3484:	88 23       	and	r24, r24
    3486:	52 f0       	brmi	.+20     	; 0x349c <__fp_round+0x20>
    3488:	bb 0f       	add	r27, r27
    348a:	40 f4       	brcc	.+16     	; 0x349c <__fp_round+0x20>
    348c:	bf 2b       	or	r27, r31
    348e:	11 f4       	brne	.+4      	; 0x3494 <__fp_round+0x18>
    3490:	60 ff       	sbrs	r22, 0
    3492:	04 c0       	rjmp	.+8      	; 0x349c <__fp_round+0x20>
    3494:	6f 5f       	subi	r22, 0xFF	; 255
    3496:	7f 4f       	sbci	r23, 0xFF	; 255
    3498:	8f 4f       	sbci	r24, 0xFF	; 255
    349a:	9f 4f       	sbci	r25, 0xFF	; 255
    349c:	08 95       	ret

0000349e <__fp_sinus>:
    349e:	ef 93       	push	r30
    34a0:	e0 ff       	sbrs	r30, 0
    34a2:	06 c0       	rjmp	.+12     	; 0x34b0 <__fp_sinus+0x12>
    34a4:	a2 ea       	ldi	r26, 0xA2	; 162
    34a6:	2a ed       	ldi	r18, 0xDA	; 218
    34a8:	3f e0       	ldi	r19, 0x0F	; 15
    34aa:	49 ec       	ldi	r20, 0xC9	; 201
    34ac:	5f eb       	ldi	r21, 0xBF	; 191
    34ae:	ca dd       	rcall	.-1132   	; 0x3044 <__addsf3x>
    34b0:	e5 df       	rcall	.-54     	; 0x347c <__fp_round>
    34b2:	0f 90       	pop	r0
    34b4:	03 94       	inc	r0
    34b6:	01 fc       	sbrc	r0, 1
    34b8:	90 58       	subi	r25, 0x80	; 128
    34ba:	e5 e1       	ldi	r30, 0x15	; 21
    34bc:	f2 e0       	ldi	r31, 0x02	; 2
    34be:	25 c2       	rjmp	.+1098   	; 0x390a <__fp_powsodd>

000034c0 <__fp_split3>:
    34c0:	57 fd       	sbrc	r21, 7
    34c2:	90 58       	subi	r25, 0x80	; 128
    34c4:	44 0f       	add	r20, r20
    34c6:	55 1f       	adc	r21, r21
    34c8:	59 f0       	breq	.+22     	; 0x34e0 <__fp_splitA+0x10>
    34ca:	5f 3f       	cpi	r21, 0xFF	; 255
    34cc:	71 f0       	breq	.+28     	; 0x34ea <__fp_splitA+0x1a>
    34ce:	47 95       	ror	r20

000034d0 <__fp_splitA>:
    34d0:	88 0f       	add	r24, r24
    34d2:	97 fb       	bst	r25, 7
    34d4:	99 1f       	adc	r25, r25
    34d6:	61 f0       	breq	.+24     	; 0x34f0 <__fp_splitA+0x20>
    34d8:	9f 3f       	cpi	r25, 0xFF	; 255
    34da:	79 f0       	breq	.+30     	; 0x34fa <__fp_splitA+0x2a>
    34dc:	87 95       	ror	r24
    34de:	08 95       	ret
    34e0:	12 16       	cp	r1, r18
    34e2:	13 06       	cpc	r1, r19
    34e4:	14 06       	cpc	r1, r20
    34e6:	55 1f       	adc	r21, r21
    34e8:	f2 cf       	rjmp	.-28     	; 0x34ce <__fp_split3+0xe>
    34ea:	46 95       	lsr	r20
    34ec:	f1 df       	rcall	.-30     	; 0x34d0 <__fp_splitA>
    34ee:	08 c0       	rjmp	.+16     	; 0x3500 <__fp_splitA+0x30>
    34f0:	16 16       	cp	r1, r22
    34f2:	17 06       	cpc	r1, r23
    34f4:	18 06       	cpc	r1, r24
    34f6:	99 1f       	adc	r25, r25
    34f8:	f1 cf       	rjmp	.-30     	; 0x34dc <__fp_splitA+0xc>
    34fa:	86 95       	lsr	r24
    34fc:	71 05       	cpc	r23, r1
    34fe:	61 05       	cpc	r22, r1
    3500:	08 94       	sec
    3502:	08 95       	ret

00003504 <__fp_trunc>:
    3504:	e5 df       	rcall	.-54     	; 0x34d0 <__fp_splitA>
    3506:	a0 f0       	brcs	.+40     	; 0x3530 <__fp_trunc+0x2c>
    3508:	be e7       	ldi	r27, 0x7E	; 126
    350a:	b9 17       	cp	r27, r25
    350c:	88 f4       	brcc	.+34     	; 0x3530 <__fp_trunc+0x2c>
    350e:	bb 27       	eor	r27, r27
    3510:	9f 38       	cpi	r25, 0x8F	; 143
    3512:	60 f4       	brcc	.+24     	; 0x352c <__fp_trunc+0x28>
    3514:	16 16       	cp	r1, r22
    3516:	b1 1d       	adc	r27, r1
    3518:	67 2f       	mov	r22, r23
    351a:	78 2f       	mov	r23, r24
    351c:	88 27       	eor	r24, r24
    351e:	98 5f       	subi	r25, 0xF8	; 248
    3520:	f7 cf       	rjmp	.-18     	; 0x3510 <__fp_trunc+0xc>
    3522:	86 95       	lsr	r24
    3524:	77 95       	ror	r23
    3526:	67 95       	ror	r22
    3528:	b1 1d       	adc	r27, r1
    352a:	93 95       	inc	r25
    352c:	96 39       	cpi	r25, 0x96	; 150
    352e:	c8 f3       	brcs	.-14     	; 0x3522 <__fp_trunc+0x1e>
    3530:	08 95       	ret

00003532 <__fp_zero>:
    3532:	e8 94       	clt

00003534 <__fp_szero>:
    3534:	bb 27       	eor	r27, r27
    3536:	66 27       	eor	r22, r22
    3538:	77 27       	eor	r23, r23
    353a:	cb 01       	movw	r24, r22
    353c:	97 f9       	bld	r25, 7
    353e:	08 95       	ret

00003540 <__gesf2>:
    3540:	ec de       	rcall	.-552    	; 0x331a <__fp_cmp>
    3542:	08 f4       	brcc	.+2      	; 0x3546 <__gesf2+0x6>
    3544:	8f ef       	ldi	r24, 0xFF	; 255
    3546:	08 95       	ret
    3548:	63 df       	rcall	.-314    	; 0x3410 <__fp_pscA>
    354a:	19 f0       	breq	.+6      	; 0x3552 <__gesf2+0x12>
    354c:	68 df       	rcall	.-304    	; 0x341e <__fp_pscB>
    354e:	09 f0       	breq	.+2      	; 0x3552 <__gesf2+0x12>
    3550:	37 cf       	rjmp	.-402    	; 0x33c0 <__fp_nan>
    3552:	07 cf       	rjmp	.-498    	; 0x3362 <__fp_inf>
    3554:	b9 01       	movw	r22, r18
    3556:	ca 01       	movw	r24, r20
    3558:	25 cf       	rjmp	.-438    	; 0x33a4 <__fp_mpack>

0000355a <hypot>:
    355a:	9f 77       	andi	r25, 0x7F	; 127
    355c:	5f 77       	andi	r21, 0x7F	; 127
    355e:	b0 df       	rcall	.-160    	; 0x34c0 <__fp_split3>
    3560:	98 f3       	brcs	.-26     	; 0x3548 <__gesf2+0x8>
    3562:	99 23       	and	r25, r25
    3564:	b9 f3       	breq	.-18     	; 0x3554 <__gesf2+0x14>
    3566:	55 23       	and	r21, r21
    3568:	b9 f3       	breq	.-18     	; 0x3558 <__gesf2+0x18>
    356a:	ff 27       	eor	r31, r31
    356c:	95 17       	cp	r25, r21
    356e:	58 f4       	brcc	.+22     	; 0x3586 <hypot+0x2c>
    3570:	e5 2f       	mov	r30, r21
    3572:	e9 1b       	sub	r30, r25
    3574:	ed 30       	cpi	r30, 0x0D	; 13
    3576:	70 f7       	brcc	.-36     	; 0x3554 <__gesf2+0x14>
    3578:	5e 3b       	cpi	r21, 0xBE	; 190
    357a:	10 f0       	brcs	.+4      	; 0x3580 <hypot+0x26>
    357c:	f1 e4       	ldi	r31, 0x41	; 65
    357e:	1c c0       	rjmp	.+56     	; 0x35b8 <hypot+0x5e>
    3580:	90 34       	cpi	r25, 0x40	; 64
    3582:	e0 f4       	brcc	.+56     	; 0x35bc <hypot+0x62>
    3584:	0a c0       	rjmp	.+20     	; 0x359a <hypot+0x40>
    3586:	e9 2f       	mov	r30, r25
    3588:	e5 1b       	sub	r30, r21
    358a:	ed 30       	cpi	r30, 0x0D	; 13
    358c:	28 f7       	brcc	.-54     	; 0x3558 <__gesf2+0x18>
    358e:	9e 3b       	cpi	r25, 0xBE	; 190
    3590:	10 f0       	brcs	.+4      	; 0x3596 <hypot+0x3c>
    3592:	f1 e4       	ldi	r31, 0x41	; 65
    3594:	11 c0       	rjmp	.+34     	; 0x35b8 <hypot+0x5e>
    3596:	50 34       	cpi	r21, 0x40	; 64
    3598:	88 f4       	brcc	.+34     	; 0x35bc <hypot+0x62>
    359a:	f9 ea       	ldi	r31, 0xA9	; 169
    359c:	88 23       	and	r24, r24
    359e:	2a f0       	brmi	.+10     	; 0x35aa <hypot+0x50>
    35a0:	9a 95       	dec	r25
    35a2:	66 0f       	add	r22, r22
    35a4:	77 1f       	adc	r23, r23
    35a6:	88 1f       	adc	r24, r24
    35a8:	da f7       	brpl	.-10     	; 0x35a0 <hypot+0x46>
    35aa:	44 23       	and	r20, r20
    35ac:	2a f0       	brmi	.+10     	; 0x35b8 <hypot+0x5e>
    35ae:	5a 95       	dec	r21
    35b0:	22 0f       	add	r18, r18
    35b2:	33 1f       	adc	r19, r19
    35b4:	44 1f       	adc	r20, r20
    35b6:	da f7       	brpl	.-10     	; 0x35ae <hypot+0x54>
    35b8:	9f 1b       	sub	r25, r31
    35ba:	5f 1b       	sub	r21, r31
    35bc:	ff 93       	push	r31
    35be:	1f 93       	push	r17
    35c0:	0f 93       	push	r16
    35c2:	ff 92       	push	r15
    35c4:	ef 92       	push	r14
    35c6:	79 01       	movw	r14, r18
    35c8:	8a 01       	movw	r16, r20
    35ca:	bb 27       	eor	r27, r27
    35cc:	ab 2f       	mov	r26, r27
    35ce:	9b 01       	movw	r18, r22
    35d0:	ac 01       	movw	r20, r24
    35d2:	c9 d0       	rcall	.+402    	; 0x3766 <__mulsf3_pse>
    35d4:	97 01       	movw	r18, r14
    35d6:	a8 01       	movw	r20, r16
    35d8:	bf 93       	push	r27
    35da:	7b 01       	movw	r14, r22
    35dc:	8c 01       	movw	r16, r24
    35de:	aa 27       	eor	r26, r26
    35e0:	ba 2f       	mov	r27, r26
    35e2:	b9 01       	movw	r22, r18
    35e4:	ca 01       	movw	r24, r20
    35e6:	bf d0       	rcall	.+382    	; 0x3766 <__mulsf3_pse>
    35e8:	af 91       	pop	r26
    35ea:	97 01       	movw	r18, r14
    35ec:	a8 01       	movw	r20, r16
    35ee:	ef 90       	pop	r14
    35f0:	ff 90       	pop	r15
    35f2:	0f 91       	pop	r16
    35f4:	1f 91       	pop	r17
    35f6:	26 dd       	rcall	.-1460   	; 0x3044 <__addsf3x>
    35f8:	41 df       	rcall	.-382    	; 0x347c <__fp_round>
    35fa:	34 d1       	rcall	.+616    	; 0x3864 <sqrt>
    35fc:	4f 91       	pop	r20
    35fe:	40 ff       	sbrs	r20, 0
    3600:	08 95       	ret
    3602:	55 27       	eor	r21, r21
    3604:	47 fd       	sbrc	r20, 7
    3606:	50 95       	com	r21
    3608:	09 c0       	rjmp	.+18     	; 0x361c <ldexp>

0000360a <inverse>:
    360a:	9b 01       	movw	r18, r22
    360c:	ac 01       	movw	r20, r24
    360e:	60 e0       	ldi	r22, 0x00	; 0
    3610:	70 e0       	ldi	r23, 0x00	; 0
    3612:	80 e8       	ldi	r24, 0x80	; 128
    3614:	9f e3       	ldi	r25, 0x3F	; 63
    3616:	ab cd       	rjmp	.-1194   	; 0x316e <__divsf3>
    3618:	a4 ce       	rjmp	.-696    	; 0x3362 <__fp_inf>
    361a:	c4 ce       	rjmp	.-632    	; 0x33a4 <__fp_mpack>

0000361c <ldexp>:
    361c:	59 df       	rcall	.-334    	; 0x34d0 <__fp_splitA>
    361e:	e8 f3       	brcs	.-6      	; 0x361a <inverse+0x10>
    3620:	99 23       	and	r25, r25
    3622:	d9 f3       	breq	.-10     	; 0x361a <inverse+0x10>
    3624:	94 0f       	add	r25, r20
    3626:	51 1d       	adc	r21, r1
    3628:	bb f3       	brvs	.-18     	; 0x3618 <inverse+0xe>
    362a:	91 50       	subi	r25, 0x01	; 1
    362c:	50 40       	sbci	r21, 0x00	; 0
    362e:	94 f0       	brlt	.+36     	; 0x3654 <ldexp+0x38>
    3630:	59 f0       	breq	.+22     	; 0x3648 <ldexp+0x2c>
    3632:	88 23       	and	r24, r24
    3634:	32 f0       	brmi	.+12     	; 0x3642 <ldexp+0x26>
    3636:	66 0f       	add	r22, r22
    3638:	77 1f       	adc	r23, r23
    363a:	88 1f       	adc	r24, r24
    363c:	91 50       	subi	r25, 0x01	; 1
    363e:	50 40       	sbci	r21, 0x00	; 0
    3640:	c1 f7       	brne	.-16     	; 0x3632 <ldexp+0x16>
    3642:	9e 3f       	cpi	r25, 0xFE	; 254
    3644:	51 05       	cpc	r21, r1
    3646:	44 f7       	brge	.-48     	; 0x3618 <inverse+0xe>
    3648:	88 0f       	add	r24, r24
    364a:	91 1d       	adc	r25, r1
    364c:	96 95       	lsr	r25
    364e:	87 95       	ror	r24
    3650:	97 f9       	bld	r25, 7
    3652:	08 95       	ret
    3654:	5f 3f       	cpi	r21, 0xFF	; 255
    3656:	ac f0       	brlt	.+42     	; 0x3682 <ldexp+0x66>
    3658:	98 3e       	cpi	r25, 0xE8	; 232
    365a:	9c f0       	brlt	.+38     	; 0x3682 <ldexp+0x66>
    365c:	bb 27       	eor	r27, r27
    365e:	86 95       	lsr	r24
    3660:	77 95       	ror	r23
    3662:	67 95       	ror	r22
    3664:	b7 95       	ror	r27
    3666:	08 f4       	brcc	.+2      	; 0x366a <ldexp+0x4e>
    3668:	b1 60       	ori	r27, 0x01	; 1
    366a:	93 95       	inc	r25
    366c:	c1 f7       	brne	.-16     	; 0x365e <ldexp+0x42>
    366e:	bb 0f       	add	r27, r27
    3670:	58 f7       	brcc	.-42     	; 0x3648 <ldexp+0x2c>
    3672:	11 f4       	brne	.+4      	; 0x3678 <ldexp+0x5c>
    3674:	60 ff       	sbrs	r22, 0
    3676:	e8 cf       	rjmp	.-48     	; 0x3648 <ldexp+0x2c>
    3678:	6f 5f       	subi	r22, 0xFF	; 255
    367a:	7f 4f       	sbci	r23, 0xFF	; 255
    367c:	8f 4f       	sbci	r24, 0xFF	; 255
    367e:	9f 4f       	sbci	r25, 0xFF	; 255
    3680:	e3 cf       	rjmp	.-58     	; 0x3648 <ldexp+0x2c>
    3682:	58 cf       	rjmp	.-336    	; 0x3534 <__fp_szero>

00003684 <lround>:
    3684:	25 df       	rcall	.-438    	; 0x34d0 <__fp_splitA>
    3686:	58 f1       	brcs	.+86     	; 0x36de <lround+0x5a>
    3688:	9e 57       	subi	r25, 0x7E	; 126
    368a:	58 f1       	brcs	.+86     	; 0x36e2 <lround+0x5e>
    368c:	98 51       	subi	r25, 0x18	; 24
    368e:	a0 f0       	brcs	.+40     	; 0x36b8 <lround+0x34>
    3690:	e9 f0       	breq	.+58     	; 0x36cc <lround+0x48>
    3692:	98 30       	cpi	r25, 0x08	; 8
    3694:	20 f5       	brcc	.+72     	; 0x36de <lround+0x5a>
    3696:	09 2e       	mov	r0, r25
    3698:	99 27       	eor	r25, r25
    369a:	66 0f       	add	r22, r22
    369c:	77 1f       	adc	r23, r23
    369e:	88 1f       	adc	r24, r24
    36a0:	99 1f       	adc	r25, r25
    36a2:	0a 94       	dec	r0
    36a4:	d1 f7       	brne	.-12     	; 0x369a <lround+0x16>
    36a6:	12 c0       	rjmp	.+36     	; 0x36cc <lround+0x48>
    36a8:	06 2e       	mov	r0, r22
    36aa:	67 2f       	mov	r22, r23
    36ac:	78 2f       	mov	r23, r24
    36ae:	88 27       	eor	r24, r24
    36b0:	98 5f       	subi	r25, 0xF8	; 248
    36b2:	11 f4       	brne	.+4      	; 0x36b8 <lround+0x34>
    36b4:	00 0c       	add	r0, r0
    36b6:	07 c0       	rjmp	.+14     	; 0x36c6 <lround+0x42>
    36b8:	99 3f       	cpi	r25, 0xF9	; 249
    36ba:	b4 f3       	brlt	.-20     	; 0x36a8 <lround+0x24>
    36bc:	86 95       	lsr	r24
    36be:	77 95       	ror	r23
    36c0:	67 95       	ror	r22
    36c2:	93 95       	inc	r25
    36c4:	d9 f7       	brne	.-10     	; 0x36bc <lround+0x38>
    36c6:	61 1d       	adc	r22, r1
    36c8:	71 1d       	adc	r23, r1
    36ca:	81 1d       	adc	r24, r1
    36cc:	3e f4       	brtc	.+14     	; 0x36dc <lround+0x58>
    36ce:	90 95       	com	r25
    36d0:	80 95       	com	r24
    36d2:	70 95       	com	r23
    36d4:	61 95       	neg	r22
    36d6:	7f 4f       	sbci	r23, 0xFF	; 255
    36d8:	8f 4f       	sbci	r24, 0xFF	; 255
    36da:	9f 4f       	sbci	r25, 0xFF	; 255
    36dc:	08 95       	ret
    36de:	68 94       	set
    36e0:	29 cf       	rjmp	.-430    	; 0x3534 <__fp_szero>
    36e2:	27 cf       	rjmp	.-434    	; 0x3532 <__fp_zero>

000036e4 <modf>:
    36e4:	fa 01       	movw	r30, r20
    36e6:	dc 01       	movw	r26, r24
    36e8:	aa 0f       	add	r26, r26
    36ea:	bb 1f       	adc	r27, r27
    36ec:	9b 01       	movw	r18, r22
    36ee:	ac 01       	movw	r20, r24
    36f0:	bf 57       	subi	r27, 0x7F	; 127
    36f2:	28 f4       	brcc	.+10     	; 0x36fe <modf+0x1a>
    36f4:	22 27       	eor	r18, r18
    36f6:	33 27       	eor	r19, r19
    36f8:	44 27       	eor	r20, r20
    36fa:	50 78       	andi	r21, 0x80	; 128
    36fc:	1f c0       	rjmp	.+62     	; 0x373c <modf+0x58>
    36fe:	b7 51       	subi	r27, 0x17	; 23
    3700:	88 f4       	brcc	.+34     	; 0x3724 <modf+0x40>
    3702:	ab 2f       	mov	r26, r27
    3704:	00 24       	eor	r0, r0
    3706:	46 95       	lsr	r20
    3708:	37 95       	ror	r19
    370a:	27 95       	ror	r18
    370c:	01 1c       	adc	r0, r1
    370e:	a3 95       	inc	r26
    3710:	d2 f3       	brmi	.-12     	; 0x3706 <modf+0x22>
    3712:	00 20       	and	r0, r0
    3714:	69 f0       	breq	.+26     	; 0x3730 <modf+0x4c>
    3716:	22 0f       	add	r18, r18
    3718:	33 1f       	adc	r19, r19
    371a:	44 1f       	adc	r20, r20
    371c:	b3 95       	inc	r27
    371e:	da f3       	brmi	.-10     	; 0x3716 <modf+0x32>
    3720:	0d d0       	rcall	.+26     	; 0x373c <modf+0x58>
    3722:	7e cc       	rjmp	.-1796   	; 0x3020 <__subsf3>
    3724:	61 30       	cpi	r22, 0x01	; 1
    3726:	71 05       	cpc	r23, r1
    3728:	a0 e8       	ldi	r26, 0x80	; 128
    372a:	8a 07       	cpc	r24, r26
    372c:	b9 46       	sbci	r27, 0x69	; 105
    372e:	30 f4       	brcc	.+12     	; 0x373c <modf+0x58>
    3730:	9b 01       	movw	r18, r22
    3732:	ac 01       	movw	r20, r24
    3734:	66 27       	eor	r22, r22
    3736:	77 27       	eor	r23, r23
    3738:	88 27       	eor	r24, r24
    373a:	90 78       	andi	r25, 0x80	; 128
    373c:	30 96       	adiw	r30, 0x00	; 0
    373e:	21 f0       	breq	.+8      	; 0x3748 <modf+0x64>
    3740:	20 83       	st	Z, r18
    3742:	31 83       	std	Z+1, r19	; 0x01
    3744:	42 83       	std	Z+2, r20	; 0x02
    3746:	53 83       	std	Z+3, r21	; 0x03
    3748:	08 95       	ret

0000374a <__mulsf3>:
    374a:	0b d0       	rcall	.+22     	; 0x3762 <__mulsf3x>
    374c:	97 ce       	rjmp	.-722    	; 0x347c <__fp_round>
    374e:	60 de       	rcall	.-832    	; 0x3410 <__fp_pscA>
    3750:	28 f0       	brcs	.+10     	; 0x375c <__mulsf3+0x12>
    3752:	65 de       	rcall	.-822    	; 0x341e <__fp_pscB>
    3754:	18 f0       	brcs	.+6      	; 0x375c <__mulsf3+0x12>
    3756:	95 23       	and	r25, r21
    3758:	09 f0       	breq	.+2      	; 0x375c <__mulsf3+0x12>
    375a:	03 ce       	rjmp	.-1018   	; 0x3362 <__fp_inf>
    375c:	31 ce       	rjmp	.-926    	; 0x33c0 <__fp_nan>
    375e:	11 24       	eor	r1, r1
    3760:	e9 ce       	rjmp	.-558    	; 0x3534 <__fp_szero>

00003762 <__mulsf3x>:
    3762:	ae de       	rcall	.-676    	; 0x34c0 <__fp_split3>
    3764:	a0 f3       	brcs	.-24     	; 0x374e <__mulsf3+0x4>

00003766 <__mulsf3_pse>:
    3766:	95 9f       	mul	r25, r21
    3768:	d1 f3       	breq	.-12     	; 0x375e <__mulsf3+0x14>
    376a:	95 0f       	add	r25, r21
    376c:	50 e0       	ldi	r21, 0x00	; 0
    376e:	55 1f       	adc	r21, r21
    3770:	62 9f       	mul	r22, r18
    3772:	f0 01       	movw	r30, r0
    3774:	72 9f       	mul	r23, r18
    3776:	bb 27       	eor	r27, r27
    3778:	f0 0d       	add	r31, r0
    377a:	b1 1d       	adc	r27, r1
    377c:	63 9f       	mul	r22, r19
    377e:	aa 27       	eor	r26, r26
    3780:	f0 0d       	add	r31, r0
    3782:	b1 1d       	adc	r27, r1
    3784:	aa 1f       	adc	r26, r26
    3786:	64 9f       	mul	r22, r20
    3788:	66 27       	eor	r22, r22
    378a:	b0 0d       	add	r27, r0
    378c:	a1 1d       	adc	r26, r1
    378e:	66 1f       	adc	r22, r22
    3790:	82 9f       	mul	r24, r18
    3792:	22 27       	eor	r18, r18
    3794:	b0 0d       	add	r27, r0
    3796:	a1 1d       	adc	r26, r1
    3798:	62 1f       	adc	r22, r18
    379a:	73 9f       	mul	r23, r19
    379c:	b0 0d       	add	r27, r0
    379e:	a1 1d       	adc	r26, r1
    37a0:	62 1f       	adc	r22, r18
    37a2:	83 9f       	mul	r24, r19
    37a4:	a0 0d       	add	r26, r0
    37a6:	61 1d       	adc	r22, r1
    37a8:	22 1f       	adc	r18, r18
    37aa:	74 9f       	mul	r23, r20
    37ac:	33 27       	eor	r19, r19
    37ae:	a0 0d       	add	r26, r0
    37b0:	61 1d       	adc	r22, r1
    37b2:	23 1f       	adc	r18, r19
    37b4:	84 9f       	mul	r24, r20
    37b6:	60 0d       	add	r22, r0
    37b8:	21 1d       	adc	r18, r1
    37ba:	82 2f       	mov	r24, r18
    37bc:	76 2f       	mov	r23, r22
    37be:	6a 2f       	mov	r22, r26
    37c0:	11 24       	eor	r1, r1
    37c2:	9f 57       	subi	r25, 0x7F	; 127
    37c4:	50 40       	sbci	r21, 0x00	; 0
    37c6:	8a f0       	brmi	.+34     	; 0x37ea <__mulsf3_pse+0x84>
    37c8:	e1 f0       	breq	.+56     	; 0x3802 <__mulsf3_pse+0x9c>
    37ca:	88 23       	and	r24, r24
    37cc:	4a f0       	brmi	.+18     	; 0x37e0 <__mulsf3_pse+0x7a>
    37ce:	ee 0f       	add	r30, r30
    37d0:	ff 1f       	adc	r31, r31
    37d2:	bb 1f       	adc	r27, r27
    37d4:	66 1f       	adc	r22, r22
    37d6:	77 1f       	adc	r23, r23
    37d8:	88 1f       	adc	r24, r24
    37da:	91 50       	subi	r25, 0x01	; 1
    37dc:	50 40       	sbci	r21, 0x00	; 0
    37de:	a9 f7       	brne	.-22     	; 0x37ca <__mulsf3_pse+0x64>
    37e0:	9e 3f       	cpi	r25, 0xFE	; 254
    37e2:	51 05       	cpc	r21, r1
    37e4:	70 f0       	brcs	.+28     	; 0x3802 <__mulsf3_pse+0x9c>
    37e6:	bd cd       	rjmp	.-1158   	; 0x3362 <__fp_inf>
    37e8:	a5 ce       	rjmp	.-694    	; 0x3534 <__fp_szero>
    37ea:	5f 3f       	cpi	r21, 0xFF	; 255
    37ec:	ec f3       	brlt	.-6      	; 0x37e8 <__mulsf3_pse+0x82>
    37ee:	98 3e       	cpi	r25, 0xE8	; 232
    37f0:	dc f3       	brlt	.-10     	; 0x37e8 <__mulsf3_pse+0x82>
    37f2:	86 95       	lsr	r24
    37f4:	77 95       	ror	r23
    37f6:	67 95       	ror	r22
    37f8:	b7 95       	ror	r27
    37fa:	f7 95       	ror	r31
    37fc:	e7 95       	ror	r30
    37fe:	9f 5f       	subi	r25, 0xFF	; 255
    3800:	c1 f7       	brne	.-16     	; 0x37f2 <__mulsf3_pse+0x8c>
    3802:	fe 2b       	or	r31, r30
    3804:	88 0f       	add	r24, r24
    3806:	91 1d       	adc	r25, r1
    3808:	96 95       	lsr	r25
    380a:	87 95       	ror	r24
    380c:	97 f9       	bld	r25, 7
    380e:	08 95       	ret

00003810 <round>:
    3810:	5f de       	rcall	.-834    	; 0x34d0 <__fp_splitA>
    3812:	e0 f0       	brcs	.+56     	; 0x384c <round+0x3c>
    3814:	9e 37       	cpi	r25, 0x7E	; 126
    3816:	d8 f0       	brcs	.+54     	; 0x384e <round+0x3e>
    3818:	96 39       	cpi	r25, 0x96	; 150
    381a:	b8 f4       	brcc	.+46     	; 0x384a <round+0x3a>
    381c:	9e 38       	cpi	r25, 0x8E	; 142
    381e:	48 f4       	brcc	.+18     	; 0x3832 <round+0x22>
    3820:	67 2f       	mov	r22, r23
    3822:	78 2f       	mov	r23, r24
    3824:	88 27       	eor	r24, r24
    3826:	98 5f       	subi	r25, 0xF8	; 248
    3828:	f9 cf       	rjmp	.-14     	; 0x381c <round+0xc>
    382a:	86 95       	lsr	r24
    382c:	77 95       	ror	r23
    382e:	67 95       	ror	r22
    3830:	93 95       	inc	r25
    3832:	95 39       	cpi	r25, 0x95	; 149
    3834:	d0 f3       	brcs	.-12     	; 0x382a <round+0x1a>
    3836:	b6 2f       	mov	r27, r22
    3838:	b1 70       	andi	r27, 0x01	; 1
    383a:	6b 0f       	add	r22, r27
    383c:	71 1d       	adc	r23, r1
    383e:	81 1d       	adc	r24, r1
    3840:	20 f4       	brcc	.+8      	; 0x384a <round+0x3a>
    3842:	87 95       	ror	r24
    3844:	77 95       	ror	r23
    3846:	67 95       	ror	r22
    3848:	93 95       	inc	r25
    384a:	91 cd       	rjmp	.-1246   	; 0x336e <__fp_mintl>
    384c:	ab cd       	rjmp	.-1194   	; 0x33a4 <__fp_mpack>
    384e:	72 ce       	rjmp	.-796    	; 0x3534 <__fp_szero>

00003850 <sin>:
    3850:	9f 93       	push	r25
    3852:	ed dd       	rcall	.-1062   	; 0x342e <__fp_rempio2>
    3854:	0f 90       	pop	r0
    3856:	07 fc       	sbrc	r0, 7
    3858:	ee 5f       	subi	r30, 0xFE	; 254
    385a:	21 ce       	rjmp	.-958    	; 0x349e <__fp_sinus>
    385c:	11 f4       	brne	.+4      	; 0x3862 <sin+0x12>
    385e:	0e f4       	brtc	.+2      	; 0x3862 <sin+0x12>
    3860:	af cd       	rjmp	.-1186   	; 0x33c0 <__fp_nan>
    3862:	a0 cd       	rjmp	.-1216   	; 0x33a4 <__fp_mpack>

00003864 <sqrt>:
    3864:	35 de       	rcall	.-918    	; 0x34d0 <__fp_splitA>
    3866:	d0 f3       	brcs	.-12     	; 0x385c <sin+0xc>
    3868:	99 23       	and	r25, r25
    386a:	d9 f3       	breq	.-10     	; 0x3862 <sin+0x12>
    386c:	ce f3       	brts	.-14     	; 0x3860 <sin+0x10>
    386e:	9f 57       	subi	r25, 0x7F	; 127
    3870:	55 0b       	sbc	r21, r21
    3872:	87 ff       	sbrs	r24, 7
    3874:	43 d0       	rcall	.+134    	; 0x38fc <__fp_norm2>
    3876:	00 24       	eor	r0, r0
    3878:	a0 e6       	ldi	r26, 0x60	; 96
    387a:	40 ea       	ldi	r20, 0xA0	; 160
    387c:	90 01       	movw	r18, r0
    387e:	80 58       	subi	r24, 0x80	; 128
    3880:	56 95       	lsr	r21
    3882:	97 95       	ror	r25
    3884:	28 f4       	brcc	.+10     	; 0x3890 <sqrt+0x2c>
    3886:	80 5c       	subi	r24, 0xC0	; 192
    3888:	66 0f       	add	r22, r22
    388a:	77 1f       	adc	r23, r23
    388c:	88 1f       	adc	r24, r24
    388e:	20 f0       	brcs	.+8      	; 0x3898 <sqrt+0x34>
    3890:	26 17       	cp	r18, r22
    3892:	37 07       	cpc	r19, r23
    3894:	48 07       	cpc	r20, r24
    3896:	30 f4       	brcc	.+12     	; 0x38a4 <sqrt+0x40>
    3898:	62 1b       	sub	r22, r18
    389a:	73 0b       	sbc	r23, r19
    389c:	84 0b       	sbc	r24, r20
    389e:	20 29       	or	r18, r0
    38a0:	31 29       	or	r19, r1
    38a2:	4a 2b       	or	r20, r26
    38a4:	a6 95       	lsr	r26
    38a6:	17 94       	ror	r1
    38a8:	07 94       	ror	r0
    38aa:	20 25       	eor	r18, r0
    38ac:	31 25       	eor	r19, r1
    38ae:	4a 27       	eor	r20, r26
    38b0:	58 f7       	brcc	.-42     	; 0x3888 <sqrt+0x24>
    38b2:	66 0f       	add	r22, r22
    38b4:	77 1f       	adc	r23, r23
    38b6:	88 1f       	adc	r24, r24
    38b8:	20 f0       	brcs	.+8      	; 0x38c2 <sqrt+0x5e>
    38ba:	26 17       	cp	r18, r22
    38bc:	37 07       	cpc	r19, r23
    38be:	48 07       	cpc	r20, r24
    38c0:	30 f4       	brcc	.+12     	; 0x38ce <sqrt+0x6a>
    38c2:	62 0b       	sbc	r22, r18
    38c4:	73 0b       	sbc	r23, r19
    38c6:	84 0b       	sbc	r24, r20
    38c8:	20 0d       	add	r18, r0
    38ca:	31 1d       	adc	r19, r1
    38cc:	41 1d       	adc	r20, r1
    38ce:	a0 95       	com	r26
    38d0:	81 f7       	brne	.-32     	; 0x38b2 <sqrt+0x4e>
    38d2:	b9 01       	movw	r22, r18
    38d4:	84 2f       	mov	r24, r20
    38d6:	91 58       	subi	r25, 0x81	; 129
    38d8:	88 0f       	add	r24, r24
    38da:	96 95       	lsr	r25
    38dc:	87 95       	ror	r24
    38de:	08 95       	ret

000038e0 <square>:
    38e0:	9b 01       	movw	r18, r22
    38e2:	ac 01       	movw	r20, r24
    38e4:	32 cf       	rjmp	.-412    	; 0x374a <__mulsf3>

000038e6 <trunc>:
    38e6:	0e de       	rcall	.-996    	; 0x3504 <__fp_trunc>
    38e8:	20 f0       	brcs	.+8      	; 0x38f2 <trunc+0xc>
    38ea:	9f 37       	cpi	r25, 0x7F	; 127
    38ec:	08 f4       	brcc	.+2      	; 0x38f0 <trunc+0xa>
    38ee:	22 ce       	rjmp	.-956    	; 0x3534 <__fp_szero>
    38f0:	3e cd       	rjmp	.-1412   	; 0x336e <__fp_mintl>
    38f2:	58 cd       	rjmp	.-1360   	; 0x33a4 <__fp_mpack>

000038f4 <__unordsf2>:
    38f4:	12 dd       	rcall	.-1500   	; 0x331a <__fp_cmp>
    38f6:	88 0b       	sbc	r24, r24
    38f8:	99 0b       	sbc	r25, r25
    38fa:	08 95       	ret

000038fc <__fp_norm2>:
    38fc:	91 50       	subi	r25, 0x01	; 1
    38fe:	50 40       	sbci	r21, 0x00	; 0
    3900:	66 0f       	add	r22, r22
    3902:	77 1f       	adc	r23, r23
    3904:	88 1f       	adc	r24, r24
    3906:	d2 f7       	brpl	.-12     	; 0x38fc <__fp_norm2>
    3908:	08 95       	ret

0000390a <__fp_powsodd>:
    390a:	9f 93       	push	r25
    390c:	8f 93       	push	r24
    390e:	7f 93       	push	r23
    3910:	6f 93       	push	r22
    3912:	ff 93       	push	r31
    3914:	ef 93       	push	r30
    3916:	9b 01       	movw	r18, r22
    3918:	ac 01       	movw	r20, r24
    391a:	17 df       	rcall	.-466    	; 0x374a <__mulsf3>
    391c:	ef 91       	pop	r30
    391e:	ff 91       	pop	r31
    3920:	52 dd       	rcall	.-1372   	; 0x33c6 <__fp_powser>
    3922:	2f 91       	pop	r18
    3924:	3f 91       	pop	r19
    3926:	4f 91       	pop	r20
    3928:	5f 91       	pop	r21
    392a:	0f cf       	rjmp	.-482    	; 0x374a <__mulsf3>

0000392c <__divmodhi4>:
    392c:	97 fb       	bst	r25, 7
    392e:	09 2e       	mov	r0, r25
    3930:	07 26       	eor	r0, r23
    3932:	0a d0       	rcall	.+20     	; 0x3948 <__divmodhi4_neg1>
    3934:	77 fd       	sbrc	r23, 7
    3936:	04 d0       	rcall	.+8      	; 0x3940 <__divmodhi4_neg2>
    3938:	2e d0       	rcall	.+92     	; 0x3996 <__udivmodhi4>
    393a:	06 d0       	rcall	.+12     	; 0x3948 <__divmodhi4_neg1>
    393c:	00 20       	and	r0, r0
    393e:	1a f4       	brpl	.+6      	; 0x3946 <__divmodhi4_exit>

00003940 <__divmodhi4_neg2>:
    3940:	70 95       	com	r23
    3942:	61 95       	neg	r22
    3944:	7f 4f       	sbci	r23, 0xFF	; 255

00003946 <__divmodhi4_exit>:
    3946:	08 95       	ret

00003948 <__divmodhi4_neg1>:
    3948:	f6 f7       	brtc	.-4      	; 0x3946 <__divmodhi4_exit>
    394a:	90 95       	com	r25
    394c:	81 95       	neg	r24
    394e:	9f 4f       	sbci	r25, 0xFF	; 255
    3950:	08 95       	ret

00003952 <__udivmodsi4>:
    3952:	a1 e2       	ldi	r26, 0x21	; 33
    3954:	1a 2e       	mov	r1, r26
    3956:	aa 1b       	sub	r26, r26
    3958:	bb 1b       	sub	r27, r27
    395a:	fd 01       	movw	r30, r26
    395c:	0d c0       	rjmp	.+26     	; 0x3978 <__udivmodsi4_ep>

0000395e <__udivmodsi4_loop>:
    395e:	aa 1f       	adc	r26, r26
    3960:	bb 1f       	adc	r27, r27
    3962:	ee 1f       	adc	r30, r30
    3964:	ff 1f       	adc	r31, r31
    3966:	a2 17       	cp	r26, r18
    3968:	b3 07       	cpc	r27, r19
    396a:	e4 07       	cpc	r30, r20
    396c:	f5 07       	cpc	r31, r21
    396e:	20 f0       	brcs	.+8      	; 0x3978 <__udivmodsi4_ep>
    3970:	a2 1b       	sub	r26, r18
    3972:	b3 0b       	sbc	r27, r19
    3974:	e4 0b       	sbc	r30, r20
    3976:	f5 0b       	sbc	r31, r21

00003978 <__udivmodsi4_ep>:
    3978:	66 1f       	adc	r22, r22
    397a:	77 1f       	adc	r23, r23
    397c:	88 1f       	adc	r24, r24
    397e:	99 1f       	adc	r25, r25
    3980:	1a 94       	dec	r1
    3982:	69 f7       	brne	.-38     	; 0x395e <__udivmodsi4_loop>
    3984:	60 95       	com	r22
    3986:	70 95       	com	r23
    3988:	80 95       	com	r24
    398a:	90 95       	com	r25
    398c:	9b 01       	movw	r18, r22
    398e:	ac 01       	movw	r20, r24
    3990:	bd 01       	movw	r22, r26
    3992:	cf 01       	movw	r24, r30
    3994:	08 95       	ret

00003996 <__udivmodhi4>:
    3996:	aa 1b       	sub	r26, r26
    3998:	bb 1b       	sub	r27, r27
    399a:	51 e1       	ldi	r21, 0x11	; 17
    399c:	07 c0       	rjmp	.+14     	; 0x39ac <__udivmodhi4_ep>

0000399e <__udivmodhi4_loop>:
    399e:	aa 1f       	adc	r26, r26
    39a0:	bb 1f       	adc	r27, r27
    39a2:	a6 17       	cp	r26, r22
    39a4:	b7 07       	cpc	r27, r23
    39a6:	10 f0       	brcs	.+4      	; 0x39ac <__udivmodhi4_ep>
    39a8:	a6 1b       	sub	r26, r22
    39aa:	b7 0b       	sbc	r27, r23

000039ac <__udivmodhi4_ep>:
    39ac:	88 1f       	adc	r24, r24
    39ae:	99 1f       	adc	r25, r25
    39b0:	5a 95       	dec	r21
    39b2:	a9 f7       	brne	.-22     	; 0x399e <__udivmodhi4_loop>
    39b4:	80 95       	com	r24
    39b6:	90 95       	com	r25
    39b8:	bc 01       	movw	r22, r24
    39ba:	cd 01       	movw	r24, r26
    39bc:	08 95       	ret

000039be <strtod>:
    39be:	8f 92       	push	r8
    39c0:	9f 92       	push	r9
    39c2:	af 92       	push	r10
    39c4:	bf 92       	push	r11
    39c6:	cf 92       	push	r12
    39c8:	df 92       	push	r13
    39ca:	ef 92       	push	r14
    39cc:	ff 92       	push	r15
    39ce:	0f 93       	push	r16
    39d0:	1f 93       	push	r17
    39d2:	cf 93       	push	r28
    39d4:	df 93       	push	r29
    39d6:	ec 01       	movw	r28, r24
    39d8:	5b 01       	movw	r10, r22
    39da:	61 15       	cp	r22, r1
    39dc:	71 05       	cpc	r23, r1
    39de:	19 f0       	breq	.+6      	; 0x39e6 <strtod+0x28>
    39e0:	fb 01       	movw	r30, r22
    39e2:	80 83       	st	Z, r24
    39e4:	91 83       	std	Z+1, r25	; 0x01
    39e6:	f9 90       	ld	r15, Y+
    39e8:	8f 2d       	mov	r24, r15
    39ea:	90 e0       	ldi	r25, 0x00	; 0
    39ec:	0e 94 4d 1e 	call	0x3c9a	; 0x3c9a <isspace>
    39f0:	89 2b       	or	r24, r25
    39f2:	c9 f7       	brne	.-14     	; 0x39e6 <strtod+0x28>
    39f4:	fd e2       	ldi	r31, 0x2D	; 45
    39f6:	ff 16       	cp	r15, r31
    39f8:	21 f4       	brne	.+8      	; 0x3a02 <strtod+0x44>
    39fa:	f9 90       	ld	r15, Y+
    39fc:	ee 24       	eor	r14, r14
    39fe:	e3 94       	inc	r14
    3a00:	05 c0       	rjmp	.+10     	; 0x3a0c <strtod+0x4e>
    3a02:	2b e2       	ldi	r18, 0x2B	; 43
    3a04:	f2 16       	cp	r15, r18
    3a06:	09 f4       	brne	.+2      	; 0x3a0a <strtod+0x4c>
    3a08:	f9 90       	ld	r15, Y+
    3a0a:	ee 24       	eor	r14, r14
    3a0c:	8e 01       	movw	r16, r28
    3a0e:	01 50       	subi	r16, 0x01	; 1
    3a10:	10 40       	sbci	r17, 0x00	; 0
    3a12:	c8 01       	movw	r24, r16
    3a14:	69 e3       	ldi	r22, 0x39	; 57
    3a16:	74 e0       	ldi	r23, 0x04	; 4
    3a18:	43 e0       	ldi	r20, 0x03	; 3
    3a1a:	50 e0       	ldi	r21, 0x00	; 0
    3a1c:	0e 94 55 1e 	call	0x3caa	; 0x3caa <strncasecmp_P>
    3a20:	89 2b       	or	r24, r25
    3a22:	01 f5       	brne	.+64     	; 0x3a64 <strtod+0xa6>
    3a24:	8e 01       	movw	r16, r28
    3a26:	0e 5f       	subi	r16, 0xFE	; 254
    3a28:	1f 4f       	sbci	r17, 0xFF	; 255
    3a2a:	c8 01       	movw	r24, r16
    3a2c:	6c e3       	ldi	r22, 0x3C	; 60
    3a2e:	74 e0       	ldi	r23, 0x04	; 4
    3a30:	45 e0       	ldi	r20, 0x05	; 5
    3a32:	50 e0       	ldi	r21, 0x00	; 0
    3a34:	0e 94 55 1e 	call	0x3caa	; 0x3caa <strncasecmp_P>
    3a38:	89 2b       	or	r24, r25
    3a3a:	19 f4       	brne	.+6      	; 0x3a42 <strtod+0x84>
    3a3c:	8e 01       	movw	r16, r28
    3a3e:	09 5f       	subi	r16, 0xF9	; 249
    3a40:	1f 4f       	sbci	r17, 0xFF	; 255
    3a42:	a1 14       	cp	r10, r1
    3a44:	b1 04       	cpc	r11, r1
    3a46:	19 f0       	breq	.+6      	; 0x3a4e <strtod+0x90>
    3a48:	f5 01       	movw	r30, r10
    3a4a:	00 83       	st	Z, r16
    3a4c:	11 83       	std	Z+1, r17	; 0x01
    3a4e:	e0 fc       	sbrc	r14, 0
    3a50:	04 c0       	rjmp	.+8      	; 0x3a5a <strtod+0x9c>
    3a52:	70 e0       	ldi	r23, 0x00	; 0
    3a54:	90 e0       	ldi	r25, 0x00	; 0
    3a56:	80 e8       	ldi	r24, 0x80	; 128
    3a58:	14 c0       	rjmp	.+40     	; 0x3a82 <strtod+0xc4>
    3a5a:	70 e0       	ldi	r23, 0x00	; 0
    3a5c:	90 e0       	ldi	r25, 0x00	; 0
    3a5e:	80 e8       	ldi	r24, 0x80	; 128
    3a60:	6f ef       	ldi	r22, 0xFF	; 255
    3a62:	08 c1       	rjmp	.+528    	; 0x3c74 <strtod+0x2b6>
    3a64:	c8 01       	movw	r24, r16
    3a66:	61 e4       	ldi	r22, 0x41	; 65
    3a68:	74 e0       	ldi	r23, 0x04	; 4
    3a6a:	43 e0       	ldi	r20, 0x03	; 3
    3a6c:	50 e0       	ldi	r21, 0x00	; 0
    3a6e:	0e 94 55 1e 	call	0x3caa	; 0x3caa <strncasecmp_P>
    3a72:	89 2b       	or	r24, r25
    3a74:	69 f4       	brne	.+26     	; 0x3a90 <strtod+0xd2>
    3a76:	a1 14       	cp	r10, r1
    3a78:	b1 04       	cpc	r11, r1
    3a7a:	29 f4       	brne	.+10     	; 0x3a86 <strtod+0xc8>
    3a7c:	70 e0       	ldi	r23, 0x00	; 0
    3a7e:	90 e0       	ldi	r25, 0x00	; 0
    3a80:	80 ec       	ldi	r24, 0xC0	; 192
    3a82:	6f e7       	ldi	r22, 0x7F	; 127
    3a84:	f7 c0       	rjmp	.+494    	; 0x3c74 <strtod+0x2b6>
    3a86:	22 96       	adiw	r28, 0x02	; 2
    3a88:	f5 01       	movw	r30, r10
    3a8a:	c0 83       	st	Z, r28
    3a8c:	d1 83       	std	Z+1, r29	; 0x01
    3a8e:	f6 cf       	rjmp	.-20     	; 0x3a7c <strtod+0xbe>
    3a90:	88 24       	eor	r8, r8
    3a92:	99 24       	eor	r9, r9
    3a94:	40 e0       	ldi	r20, 0x00	; 0
    3a96:	50 e0       	ldi	r21, 0x00	; 0
    3a98:	60 e0       	ldi	r22, 0x00	; 0
    3a9a:	70 e0       	ldi	r23, 0x00	; 0
    3a9c:	ef 2d       	mov	r30, r15
    3a9e:	e0 53       	subi	r30, 0x30	; 48
    3aa0:	ea 30       	cpi	r30, 0x0A	; 10
    3aa2:	a0 f5       	brcc	.+104    	; 0x3b0c <strtod+0x14e>
    3aa4:	f2 e0       	ldi	r31, 0x02	; 2
    3aa6:	ef 2a       	or	r14, r31
    3aa8:	8e 2d       	mov	r24, r14
    3aaa:	90 e0       	ldi	r25, 0x00	; 0
    3aac:	9c 01       	movw	r18, r24
    3aae:	28 70       	andi	r18, 0x08	; 8
    3ab0:	30 70       	andi	r19, 0x00	; 0
    3ab2:	e2 fe       	sbrs	r14, 2
    3ab4:	06 c0       	rjmp	.+12     	; 0x3ac2 <strtod+0x104>
    3ab6:	23 2b       	or	r18, r19
    3ab8:	79 f5       	brne	.+94     	; 0x3b18 <strtod+0x15a>
    3aba:	08 94       	sec
    3abc:	81 1c       	adc	r8, r1
    3abe:	91 1c       	adc	r9, r1
    3ac0:	2b c0       	rjmp	.+86     	; 0x3b18 <strtod+0x15a>
    3ac2:	23 2b       	or	r18, r19
    3ac4:	19 f0       	breq	.+6      	; 0x3acc <strtod+0x10e>
    3ac6:	08 94       	sec
    3ac8:	81 08       	sbc	r8, r1
    3aca:	91 08       	sbc	r9, r1
    3acc:	db 01       	movw	r26, r22
    3ace:	ca 01       	movw	r24, r20
    3ad0:	12 e0       	ldi	r17, 0x02	; 2
    3ad2:	88 0f       	add	r24, r24
    3ad4:	99 1f       	adc	r25, r25
    3ad6:	aa 1f       	adc	r26, r26
    3ad8:	bb 1f       	adc	r27, r27
    3ada:	1a 95       	dec	r17
    3adc:	d1 f7       	brne	.-12     	; 0x3ad2 <strtod+0x114>
    3ade:	48 0f       	add	r20, r24
    3ae0:	59 1f       	adc	r21, r25
    3ae2:	6a 1f       	adc	r22, r26
    3ae4:	7b 1f       	adc	r23, r27
    3ae6:	44 0f       	add	r20, r20
    3ae8:	55 1f       	adc	r21, r21
    3aea:	66 1f       	adc	r22, r22
    3aec:	77 1f       	adc	r23, r23
    3aee:	4e 0f       	add	r20, r30
    3af0:	51 1d       	adc	r21, r1
    3af2:	61 1d       	adc	r22, r1
    3af4:	71 1d       	adc	r23, r1
    3af6:	48 39       	cpi	r20, 0x98	; 152
    3af8:	29 e9       	ldi	r18, 0x99	; 153
    3afa:	52 07       	cpc	r21, r18
    3afc:	29 e9       	ldi	r18, 0x99	; 153
    3afe:	62 07       	cpc	r22, r18
    3b00:	29 e1       	ldi	r18, 0x19	; 25
    3b02:	72 07       	cpc	r23, r18
    3b04:	48 f0       	brcs	.+18     	; 0x3b18 <strtod+0x15a>
    3b06:	84 e0       	ldi	r24, 0x04	; 4
    3b08:	e8 2a       	or	r14, r24
    3b0a:	06 c0       	rjmp	.+12     	; 0x3b18 <strtod+0x15a>
    3b0c:	ee 3f       	cpi	r30, 0xFE	; 254
    3b0e:	31 f4       	brne	.+12     	; 0x3b1c <strtod+0x15e>
    3b10:	e3 fc       	sbrc	r14, 3
    3b12:	39 c0       	rjmp	.+114    	; 0x3b86 <strtod+0x1c8>
    3b14:	98 e0       	ldi	r25, 0x08	; 8
    3b16:	e9 2a       	or	r14, r25
    3b18:	f9 90       	ld	r15, Y+
    3b1a:	c0 cf       	rjmp	.-128    	; 0x3a9c <strtod+0xde>
    3b1c:	e5 33       	cpi	r30, 0x35	; 53
    3b1e:	11 f0       	breq	.+4      	; 0x3b24 <strtod+0x166>
    3b20:	e5 31       	cpi	r30, 0x15	; 21
    3b22:	89 f5       	brne	.+98     	; 0x3b86 <strtod+0x1c8>
    3b24:	29 91       	ld	r18, Y+
    3b26:	2d 32       	cpi	r18, 0x2D	; 45
    3b28:	19 f4       	brne	.+6      	; 0x3b30 <strtod+0x172>
    3b2a:	e0 e1       	ldi	r30, 0x10	; 16
    3b2c:	ee 2a       	or	r14, r30
    3b2e:	05 c0       	rjmp	.+10     	; 0x3b3a <strtod+0x17c>
    3b30:	2b 32       	cpi	r18, 0x2B	; 43
    3b32:	19 f0       	breq	.+6      	; 0x3b3a <strtod+0x17c>
    3b34:	81 e0       	ldi	r24, 0x01	; 1
    3b36:	90 e0       	ldi	r25, 0x00	; 0
    3b38:	03 c0       	rjmp	.+6      	; 0x3b40 <strtod+0x182>
    3b3a:	29 91       	ld	r18, Y+
    3b3c:	82 e0       	ldi	r24, 0x02	; 2
    3b3e:	90 e0       	ldi	r25, 0x00	; 0
    3b40:	e2 2f       	mov	r30, r18
    3b42:	e0 53       	subi	r30, 0x30	; 48
    3b44:	ea 30       	cpi	r30, 0x0A	; 10
    3b46:	18 f0       	brcs	.+6      	; 0x3b4e <strtod+0x190>
    3b48:	c8 1b       	sub	r28, r24
    3b4a:	d9 0b       	sbc	r29, r25
    3b4c:	1c c0       	rjmp	.+56     	; 0x3b86 <strtod+0x1c8>
    3b4e:	20 e0       	ldi	r18, 0x00	; 0
    3b50:	30 e0       	ldi	r19, 0x00	; 0
    3b52:	fc e0       	ldi	r31, 0x0C	; 12
    3b54:	20 38       	cpi	r18, 0x80	; 128
    3b56:	3f 07       	cpc	r19, r31
    3b58:	5c f4       	brge	.+22     	; 0x3b70 <strtod+0x1b2>
    3b5a:	c9 01       	movw	r24, r18
    3b5c:	88 0f       	add	r24, r24
    3b5e:	99 1f       	adc	r25, r25
    3b60:	88 0f       	add	r24, r24
    3b62:	99 1f       	adc	r25, r25
    3b64:	28 0f       	add	r18, r24
    3b66:	39 1f       	adc	r19, r25
    3b68:	22 0f       	add	r18, r18
    3b6a:	33 1f       	adc	r19, r19
    3b6c:	2e 0f       	add	r18, r30
    3b6e:	31 1d       	adc	r19, r1
    3b70:	e9 91       	ld	r30, Y+
    3b72:	e0 53       	subi	r30, 0x30	; 48
    3b74:	ea 30       	cpi	r30, 0x0A	; 10
    3b76:	68 f3       	brcs	.-38     	; 0x3b52 <strtod+0x194>
    3b78:	e4 fe       	sbrs	r14, 4
    3b7a:	03 c0       	rjmp	.+6      	; 0x3b82 <strtod+0x1c4>
    3b7c:	30 95       	com	r19
    3b7e:	21 95       	neg	r18
    3b80:	3f 4f       	sbci	r19, 0xFF	; 255
    3b82:	82 0e       	add	r8, r18
    3b84:	93 1e       	adc	r9, r19
    3b86:	ce 2c       	mov	r12, r14
    3b88:	dd 24       	eor	r13, r13
    3b8a:	e1 fe       	sbrs	r14, 1
    3b8c:	07 c0       	rjmp	.+14     	; 0x3b9c <strtod+0x1de>
    3b8e:	a1 14       	cp	r10, r1
    3b90:	b1 04       	cpc	r11, r1
    3b92:	21 f0       	breq	.+8      	; 0x3b9c <strtod+0x1de>
    3b94:	21 97       	sbiw	r28, 0x01	; 1
    3b96:	f5 01       	movw	r30, r10
    3b98:	c0 83       	st	Z, r28
    3b9a:	d1 83       	std	Z+1, r29	; 0x01
    3b9c:	cb 01       	movw	r24, r22
    3b9e:	ba 01       	movw	r22, r20
    3ba0:	0e 94 50 19 	call	0x32a0	; 0x32a0 <__floatunsisf>
    3ba4:	7b 01       	movw	r14, r22
    3ba6:	8c 01       	movw	r16, r24
    3ba8:	f3 e0       	ldi	r31, 0x03	; 3
    3baa:	cf 22       	and	r12, r31
    3bac:	dd 24       	eor	r13, r13
    3bae:	23 e0       	ldi	r18, 0x03	; 3
    3bb0:	c2 16       	cp	r12, r18
    3bb2:	d1 04       	cpc	r13, r1
    3bb4:	21 f4       	brne	.+8      	; 0x3bbe <strtod+0x200>
    3bb6:	17 fb       	bst	r17, 7
    3bb8:	10 95       	com	r17
    3bba:	17 f9       	bld	r17, 7
    3bbc:	10 95       	com	r17
    3bbe:	57 01       	movw	r10, r14
    3bc0:	68 01       	movw	r12, r16
    3bc2:	c8 01       	movw	r24, r16
    3bc4:	b7 01       	movw	r22, r14
    3bc6:	20 e0       	ldi	r18, 0x00	; 0
    3bc8:	30 e0       	ldi	r19, 0x00	; 0
    3bca:	40 e0       	ldi	r20, 0x00	; 0
    3bcc:	50 e0       	ldi	r21, 0x00	; 0
    3bce:	0e 94 b0 18 	call	0x3160	; 0x3160 <__cmpsf2>
    3bd2:	88 23       	and	r24, r24
    3bd4:	09 f4       	brne	.+2      	; 0x3bd8 <strtod+0x21a>
    3bd6:	4a c0       	rjmp	.+148    	; 0x3c6c <strtod+0x2ae>
    3bd8:	97 fe       	sbrs	r9, 7
    3bda:	0d c0       	rjmp	.+26     	; 0x3bf6 <strtod+0x238>
    3bdc:	28 e5       	ldi	r18, 0x58	; 88
    3bde:	e2 2e       	mov	r14, r18
    3be0:	24 e0       	ldi	r18, 0x04	; 4
    3be2:	f2 2e       	mov	r15, r18
    3be4:	90 94       	com	r9
    3be6:	81 94       	neg	r8
    3be8:	91 08       	sbc	r9, r1
    3bea:	93 94       	inc	r9
    3bec:	c0 e2       	ldi	r28, 0x20	; 32
    3bee:	d0 e0       	ldi	r29, 0x00	; 0
    3bf0:	00 e0       	ldi	r16, 0x00	; 0
    3bf2:	10 e0       	ldi	r17, 0x00	; 0
    3bf4:	12 c0       	rjmp	.+36     	; 0x3c1a <strtod+0x25c>
    3bf6:	90 e7       	ldi	r25, 0x70	; 112
    3bf8:	e9 2e       	mov	r14, r25
    3bfa:	94 e0       	ldi	r25, 0x04	; 4
    3bfc:	f9 2e       	mov	r15, r25
    3bfe:	f6 cf       	rjmp	.-20     	; 0x3bec <strtod+0x22e>
    3c00:	f7 01       	movw	r30, r14
    3c02:	25 91       	lpm	r18, Z+
    3c04:	35 91       	lpm	r19, Z+
    3c06:	45 91       	lpm	r20, Z+
    3c08:	54 91       	lpm	r21, Z+
    3c0a:	c6 01       	movw	r24, r12
    3c0c:	b5 01       	movw	r22, r10
    3c0e:	0e 94 a5 1b 	call	0x374a	; 0x374a <__mulsf3>
    3c12:	5b 01       	movw	r10, r22
    3c14:	6c 01       	movw	r12, r24
    3c16:	8c 1a       	sub	r8, r28
    3c18:	9d 0a       	sbc	r9, r29
    3c1a:	8c 16       	cp	r8, r28
    3c1c:	9d 06       	cpc	r9, r29
    3c1e:	84 f7       	brge	.-32     	; 0x3c00 <strtod+0x242>
    3c20:	d5 95       	asr	r29
    3c22:	c7 95       	ror	r28
    3c24:	0f 5f       	subi	r16, 0xFF	; 255
    3c26:	1f 4f       	sbci	r17, 0xFF	; 255
    3c28:	06 30       	cpi	r16, 0x06	; 6
    3c2a:	11 05       	cpc	r17, r1
    3c2c:	29 f0       	breq	.+10     	; 0x3c38 <strtod+0x27a>
    3c2e:	8c ef       	ldi	r24, 0xFC	; 252
    3c30:	9f ef       	ldi	r25, 0xFF	; 255
    3c32:	e8 0e       	add	r14, r24
    3c34:	f9 1e       	adc	r15, r25
    3c36:	f1 cf       	rjmp	.-30     	; 0x3c1a <strtod+0x25c>
    3c38:	c5 01       	movw	r24, r10
    3c3a:	d6 01       	movw	r26, r12
    3c3c:	7c 01       	movw	r14, r24
    3c3e:	8d 01       	movw	r16, r26
    3c40:	8c 2d       	mov	r24, r12
    3c42:	88 0f       	add	r24, r24
    3c44:	8d 2d       	mov	r24, r13
    3c46:	88 1f       	adc	r24, r24
    3c48:	8f 3f       	cpi	r24, 0xFF	; 255
    3c4a:	51 f0       	breq	.+20     	; 0x3c60 <strtod+0x2a2>
    3c4c:	c6 01       	movw	r24, r12
    3c4e:	b5 01       	movw	r22, r10
    3c50:	20 e0       	ldi	r18, 0x00	; 0
    3c52:	30 e0       	ldi	r19, 0x00	; 0
    3c54:	40 e0       	ldi	r20, 0x00	; 0
    3c56:	50 e0       	ldi	r21, 0x00	; 0
    3c58:	0e 94 b0 18 	call	0x3160	; 0x3160 <__cmpsf2>
    3c5c:	88 23       	and	r24, r24
    3c5e:	31 f4       	brne	.+12     	; 0x3c6c <strtod+0x2ae>
    3c60:	82 e2       	ldi	r24, 0x22	; 34
    3c62:	90 e0       	ldi	r25, 0x00	; 0
    3c64:	80 93 3a 25 	sts	0x253A, r24
    3c68:	90 93 3b 25 	sts	0x253B, r25
    3c6c:	7e 2d       	mov	r23, r14
    3c6e:	9f 2d       	mov	r25, r15
    3c70:	80 2f       	mov	r24, r16
    3c72:	61 2f       	mov	r22, r17
    3c74:	27 2f       	mov	r18, r23
    3c76:	39 2f       	mov	r19, r25
    3c78:	48 2f       	mov	r20, r24
    3c7a:	56 2f       	mov	r21, r22
    3c7c:	b9 01       	movw	r22, r18
    3c7e:	ca 01       	movw	r24, r20
    3c80:	df 91       	pop	r29
    3c82:	cf 91       	pop	r28
    3c84:	1f 91       	pop	r17
    3c86:	0f 91       	pop	r16
    3c88:	ff 90       	pop	r15
    3c8a:	ef 90       	pop	r14
    3c8c:	df 90       	pop	r13
    3c8e:	cf 90       	pop	r12
    3c90:	bf 90       	pop	r11
    3c92:	af 90       	pop	r10
    3c94:	9f 90       	pop	r9
    3c96:	8f 90       	pop	r8
    3c98:	08 95       	ret

00003c9a <isspace>:
    3c9a:	91 11       	cpse	r25, r1
    3c9c:	1e c0       	rjmp	.+60     	; 0x3cda <__ctype_isfalse>
    3c9e:	80 32       	cpi	r24, 0x20	; 32
    3ca0:	19 f0       	breq	.+6      	; 0x3ca8 <isspace+0xe>
    3ca2:	89 50       	subi	r24, 0x09	; 9
    3ca4:	85 50       	subi	r24, 0x05	; 5
    3ca6:	d0 f7       	brcc	.-12     	; 0x3c9c <isspace+0x2>
    3ca8:	08 95       	ret

00003caa <strncasecmp_P>:
    3caa:	fb 01       	movw	r30, r22
    3cac:	dc 01       	movw	r26, r24
    3cae:	41 50       	subi	r20, 0x01	; 1
    3cb0:	50 40       	sbci	r21, 0x00	; 0
    3cb2:	88 f0       	brcs	.+34     	; 0x3cd6 <strncasecmp_P+0x2c>
    3cb4:	8d 91       	ld	r24, X+
    3cb6:	81 34       	cpi	r24, 0x41	; 65
    3cb8:	1c f0       	brlt	.+6      	; 0x3cc0 <strncasecmp_P+0x16>
    3cba:	8b 35       	cpi	r24, 0x5B	; 91
    3cbc:	0c f4       	brge	.+2      	; 0x3cc0 <strncasecmp_P+0x16>
    3cbe:	80 5e       	subi	r24, 0xE0	; 224
    3cc0:	65 91       	lpm	r22, Z+
    3cc2:	61 34       	cpi	r22, 0x41	; 65
    3cc4:	1c f0       	brlt	.+6      	; 0x3ccc <strncasecmp_P+0x22>
    3cc6:	6b 35       	cpi	r22, 0x5B	; 91
    3cc8:	0c f4       	brge	.+2      	; 0x3ccc <strncasecmp_P+0x22>
    3cca:	60 5e       	subi	r22, 0xE0	; 224
    3ccc:	86 1b       	sub	r24, r22
    3cce:	61 11       	cpse	r22, r1
    3cd0:	71 f3       	breq	.-36     	; 0x3cae <strncasecmp_P+0x4>
    3cd2:	99 0b       	sbc	r25, r25
    3cd4:	08 95       	ret
    3cd6:	88 1b       	sub	r24, r24
    3cd8:	fc cf       	rjmp	.-8      	; 0x3cd2 <strncasecmp_P+0x28>

00003cda <__ctype_isfalse>:
    3cda:	99 27       	eor	r25, r25
    3cdc:	88 27       	eor	r24, r24

00003cde <__ctype_istrue>:
    3cde:	08 95       	ret

00003ce0 <_exit>:
    3ce0:	f8 94       	cli

00003ce2 <__stop_program>:
    3ce2:	ff cf       	rjmp	.-2      	; 0x3ce2 <__stop_program>
